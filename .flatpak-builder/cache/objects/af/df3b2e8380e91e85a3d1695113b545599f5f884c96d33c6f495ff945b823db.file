/* RadioBrowser.c generated by valac 0.40.11, the Vala compiler
 * generated from RadioBrowser.vala, do not modify */



#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <json-glib/json-glib.h>
#include <libsoup/soup.h>
#include <gio/gio.h>


#define SERVICES_TYPE_RADIO_BROWSER (services_radio_browser_get_type ())
#define SERVICES_RADIO_BROWSER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SERVICES_TYPE_RADIO_BROWSER, ServicesRadioBrowser))
#define SERVICES_RADIO_BROWSER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SERVICES_TYPE_RADIO_BROWSER, ServicesRadioBrowserClass))
#define SERVICES_IS_RADIO_BROWSER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SERVICES_TYPE_RADIO_BROWSER))
#define SERVICES_IS_RADIO_BROWSER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SERVICES_TYPE_RADIO_BROWSER))
#define SERVICES_RADIO_BROWSER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SERVICES_TYPE_RADIO_BROWSER, ServicesRadioBrowserClass))

typedef struct _ServicesRadioBrowser ServicesRadioBrowser;
typedef struct _ServicesRadioBrowserClass ServicesRadioBrowserClass;
typedef struct _ServicesRadioBrowserPrivate ServicesRadioBrowserPrivate;
enum  {
	SERVICES_RADIO_BROWSER_0_PROPERTY,
	SERVICES_RADIO_BROWSER_NUM_PROPERTIES
};
static GParamSpec* services_radio_browser_properties[SERVICES_RADIO_BROWSER_NUM_PROPERTIES];
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))

#define OBJECTS_TYPE_RADIO (objects_radio_get_type ())
#define OBJECTS_RADIO(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), OBJECTS_TYPE_RADIO, ObjectsRadio))
#define OBJECTS_RADIO_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), OBJECTS_TYPE_RADIO, ObjectsRadioClass))
#define OBJECTS_IS_RADIO(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), OBJECTS_TYPE_RADIO))
#define OBJECTS_IS_RADIO_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), OBJECTS_TYPE_RADIO))
#define OBJECTS_RADIO_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), OBJECTS_TYPE_RADIO, ObjectsRadioClass))

typedef struct _ObjectsRadio ObjectsRadio;
typedef struct _ObjectsRadioClass ObjectsRadioClass;
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
typedef struct _ServicesRadioBrowserGetRadiosByNameData ServicesRadioBrowserGetRadiosByNameData;
enum  {
	SERVICES_RADIO_BROWSER_STARTED_SIGNAL,
	SERVICES_RADIO_BROWSER_FINISHED_SIGNAL,
	SERVICES_RADIO_BROWSER_ITEM_LOADED_SIGNAL,
	SERVICES_RADIO_BROWSER_NUM_SIGNALS
};
static guint services_radio_browser_signals[SERVICES_RADIO_BROWSER_NUM_SIGNALS] = {0};

struct _ServicesRadioBrowser {
	GObject parent_instance;
	ServicesRadioBrowserPrivate * priv;
	GData* parameters;
};

struct _ServicesRadioBrowserClass {
	GObjectClass parent_class;
};

struct _ServicesRadioBrowserPrivate {
	JsonParser* parser;
	SoupSession* session;
	GCancellable* cancellable;
	gchar* API_URL;
};

struct _ServicesRadioBrowserGetRadiosByNameData {
	int _state_;
	GObject* _source_object_;
	GAsyncResult* _res_;
	GTask* _async_result;
	GAsyncReadyCallback _callback_;
	gboolean _task_complete_;
	ServicesRadioBrowser* self;
	gchar* name;
	GCancellable* _tmp0_;
	gchar* url;
	const gchar* _tmp1_;
	gchar* _tmp2_;
	gchar* _tmp3_;
	gchar* _tmp4_;
	gchar* _tmp5_;
	SoupMessage* message;
	const gchar* _tmp6_;
	SoupMessage* _tmp7_;
	GInputStream* stream;
	SoupSession* _tmp8_;
	SoupMessage* _tmp9_;
	GCancellable* _tmp10_;
	GInputStream* _tmp11_;
	JsonParser* _tmp12_;
	GInputStream* _tmp13_;
	GError* e;
	GError* _tmp14_;
	const gchar* _tmp15_;
	GError * _inner_error_;
};


static gpointer services_radio_browser_parent_class = NULL;

GType services_radio_browser_get_type (void) G_GNUC_CONST;
#define SERVICES_RADIO_BROWSER_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), SERVICES_TYPE_RADIO_BROWSER, ServicesRadioBrowserPrivate))
ServicesRadioBrowser* services_radio_browser_new (void);
ServicesRadioBrowser* services_radio_browser_construct (GType object_type);
static void __lambda291_ (ServicesRadioBrowser* self);
static void ___lambda291__json_parser_array_start (JsonParser* _sender,
                                            gpointer self);
static void __lambda292_ (ServicesRadioBrowser* self,
                   JsonParser* parse,
                   JsonArray* array,
                   gint index);
GType objects_radio_get_type (void) G_GNUC_CONST;
static void ___lambda292__json_parser_array_element (JsonParser* _sender,
                                              JsonArray* array,
                                              gint index_,
                                              gpointer self);
static void __lambda293_ (ServicesRadioBrowser* self);
static void ___lambda293__json_parser_array_end (JsonParser* _sender,
                                          JsonArray* array,
                                          gpointer self);
void services_radio_browser_cancel (ServicesRadioBrowser* self);
static void services_radio_browser_get_radios_by_name_data_free (gpointer _data);
static void services_radio_browser_get_radios_by_name_async_ready_wrapper (GObject *source_object,
                                                                    GAsyncResult *res,
                                                                    void *user_data);
void services_radio_browser_get_radios_by_name (ServicesRadioBrowser* self,
                                                const gchar* name,
                                                GAsyncReadyCallback _callback_,
                                                gpointer _user_data_);
void services_radio_browser_get_radios_by_name_finish (ServicesRadioBrowser* self,
                                                       GAsyncResult* _res_);
static gboolean services_radio_browser_get_radios_by_name_co (ServicesRadioBrowserGetRadiosByNameData* _data_);
static void services_radio_browser_get_radios_by_name_ready (GObject* source_object,
                                                      GAsyncResult* _res_,
                                                      gpointer _user_data_);
static void services_radio_browser_finalize (GObject * obj);


static void
__lambda291_ (ServicesRadioBrowser* self)
{
	g_signal_emit (self, services_radio_browser_signals[SERVICES_RADIO_BROWSER_STARTED_SIGNAL], 0);
}


static void
___lambda291__json_parser_array_start (JsonParser* _sender,
                                       gpointer self)
{
	__lambda291_ ((ServicesRadioBrowser*) self);
}


static void
__lambda292_ (ServicesRadioBrowser* self,
              JsonParser* parse,
              JsonArray* array,
              gint index)
{
	JsonNode* _tmp0_;
	GObject* _tmp1_;
	ObjectsRadio* _tmp2_;
	ObjectsRadio* _tmp3_;
	g_return_if_fail (parse != NULL);
	g_return_if_fail (array != NULL);
	_tmp0_ = json_array_get_element (array, (guint) index);
	_tmp1_ = json_gobject_deserialize (OBJECTS_TYPE_RADIO, _tmp0_);
	_tmp2_ = G_TYPE_CHECK_INSTANCE_TYPE (_tmp1_, OBJECTS_TYPE_RADIO) ? ((ObjectsRadio*) _tmp1_) : NULL;
	if (_tmp2_ == NULL) {
		_g_object_unref0 (_tmp1_);
	}
	_tmp3_ = _tmp2_;
	g_signal_emit (self, services_radio_browser_signals[SERVICES_RADIO_BROWSER_ITEM_LOADED_SIGNAL], 0, _tmp3_);
	_g_object_unref0 (_tmp3_);
}


static void
___lambda292__json_parser_array_element (JsonParser* _sender,
                                         JsonArray* array,
                                         gint index_,
                                         gpointer self)
{
	__lambda292_ ((ServicesRadioBrowser*) self, _sender, array, index_);
}


static void
__lambda293_ (ServicesRadioBrowser* self)
{
	g_signal_emit (self, services_radio_browser_signals[SERVICES_RADIO_BROWSER_FINISHED_SIGNAL], 0);
}


static void
___lambda293__json_parser_array_end (JsonParser* _sender,
                                     JsonArray* array,
                                     gpointer self)
{
	__lambda293_ ((ServicesRadioBrowser*) self);
}


ServicesRadioBrowser*
services_radio_browser_construct (GType object_type)
{
	ServicesRadioBrowser * self = NULL;
	SoupSession* _tmp0_;
	SoupSession* _tmp1_;
	JsonParser* _tmp2_;
	JsonParser* _tmp3_;
	JsonParser* _tmp4_;
	JsonParser* _tmp5_;
	self = (ServicesRadioBrowser*) g_object_new (object_type, NULL);
	_tmp0_ = soup_session_new ();
	_g_object_unref0 (self->priv->session);
	self->priv->session = _tmp0_;
	_tmp1_ = self->priv->session;
	g_object_set (_tmp1_, "timeout", (guint) 10, NULL);
	_tmp2_ = json_parser_new ();
	_g_object_unref0 (self->priv->parser);
	self->priv->parser = _tmp2_;
	_tmp3_ = self->priv->parser;
	g_signal_connect_object (_tmp3_, "array-start", (GCallback) ___lambda291__json_parser_array_start, self, 0);
	_tmp4_ = self->priv->parser;
	g_signal_connect_object (_tmp4_, "array-element", (GCallback) ___lambda292__json_parser_array_element, self, 0);
	_tmp5_ = self->priv->parser;
	g_signal_connect_object (_tmp5_, "array-end", (GCallback) ___lambda293__json_parser_array_end, self, 0);
	return self;
}


ServicesRadioBrowser*
services_radio_browser_new (void)
{
	return services_radio_browser_construct (SERVICES_TYPE_RADIO_BROWSER);
}


void
services_radio_browser_cancel (ServicesRadioBrowser* self)
{
	GCancellable* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->cancellable;
	g_cancellable_cancel (_tmp0_);
}


static void
services_radio_browser_get_radios_by_name_data_free (gpointer _data)
{
	ServicesRadioBrowserGetRadiosByNameData* _data_;
	_data_ = _data;
	_g_free0 (_data_->name);
	_g_object_unref0 (_data_->self);
	g_slice_free (ServicesRadioBrowserGetRadiosByNameData, _data_);
}


static void
services_radio_browser_get_radios_by_name_async_ready_wrapper (GObject *source_object,
                                                               GAsyncResult *res,
                                                               void *user_data)
{
	ServicesRadioBrowserGetRadiosByNameData* _task_data_;
	_task_data_ = g_task_get_task_data (G_TASK (res));
	if (_task_data_->_callback_ != NULL) {
		_task_data_->_callback_ (source_object, res, user_data);
	}
	_task_data_->_task_complete_ = TRUE;
}


static gpointer
_g_object_ref0 (gpointer self)
{
	return self ? g_object_ref (self) : NULL;
}


void
services_radio_browser_get_radios_by_name (ServicesRadioBrowser* self,
                                           const gchar* name,
                                           GAsyncReadyCallback _callback_,
                                           gpointer _user_data_)
{
	ServicesRadioBrowserGetRadiosByNameData* _data_;
	ServicesRadioBrowser* _tmp0_;
	gchar* _tmp1_;
	_data_ = g_slice_new0 (ServicesRadioBrowserGetRadiosByNameData);
	_data_->_callback_ = _callback_;
	_data_->_async_result = g_task_new (G_OBJECT (self), NULL, services_radio_browser_get_radios_by_name_async_ready_wrapper, _user_data_);
	if (_callback_ == NULL) {
		_data_->_task_complete_ = TRUE;
	}
	g_task_set_task_data (_data_->_async_result, _data_, services_radio_browser_get_radios_by_name_data_free);
	_tmp0_ = _g_object_ref0 (self);
	_data_->self = _tmp0_;
	_tmp1_ = g_strdup (name);
	_g_free0 (_data_->name);
	_data_->name = _tmp1_;
	services_radio_browser_get_radios_by_name_co (_data_);
}


void
services_radio_browser_get_radios_by_name_finish (ServicesRadioBrowser* self,
                                                  GAsyncResult* _res_)
{
	ServicesRadioBrowserGetRadiosByNameData* _data_;
	_data_ = g_task_propagate_pointer (G_TASK (_res_), NULL);
}


static void
services_radio_browser_get_radios_by_name_ready (GObject* source_object,
                                                 GAsyncResult* _res_,
                                                 gpointer _user_data_)
{
	ServicesRadioBrowserGetRadiosByNameData* _data_;
	_data_ = _user_data_;
	_data_->_source_object_ = source_object;
	_data_->_res_ = _res_;
	_data_->_task_complete_ = TRUE;
	services_radio_browser_get_radios_by_name_co (_data_);
}


static gboolean
services_radio_browser_get_radios_by_name_co (ServicesRadioBrowserGetRadiosByNameData* _data_)
{
	switch (_data_->_state_) {
		case 0:
		goto _state_0;
		case 1:
		goto _state_1;
		case 2:
		goto _state_2;
		default:
		g_assert_not_reached ();
	}
	_state_0:
	g_signal_emit (_data_->self, services_radio_browser_signals[SERVICES_RADIO_BROWSER_STARTED_SIGNAL], 0);
	services_radio_browser_cancel (_data_->self);
	_data_->_tmp0_ = g_cancellable_new ();
	_g_object_unref0 (_data_->self->priv->cancellable);
	_data_->self->priv->cancellable = _data_->_tmp0_;
	_data_->_tmp1_ = _data_->self->priv->API_URL;
	_data_->_tmp2_ = g_strconcat (_data_->_tmp1_, _data_->name, NULL);
	_data_->_tmp3_ = _data_->_tmp2_;
	_data_->_tmp4_ = g_strconcat (_data_->_tmp3_, "?order=votes&reverse=true&limit=100", NULL);
	_data_->_tmp5_ = _data_->_tmp4_;
	_g_free0 (_data_->_tmp3_);
	_data_->url = _data_->_tmp5_;
	_data_->_tmp6_ = _data_->url;
	_data_->_tmp7_ = soup_message_new ("GET", _data_->_tmp6_);
	_data_->message = _data_->_tmp7_;
	{
		_data_->_tmp8_ = _data_->self->priv->session;
		_data_->_tmp9_ = _data_->message;
		_data_->_tmp10_ = _data_->self->priv->cancellable;
		_data_->_state_ = 1;
		soup_session_send_async (_data_->_tmp8_, _data_->_tmp9_, _data_->_tmp10_, services_radio_browser_get_radios_by_name_ready, _data_);
		return FALSE;
		_state_1:
		_data_->_tmp11_ = soup_session_send_finish (_data_->_tmp8_, _data_->_res_, &_data_->_inner_error_);
		_data_->stream = _data_->_tmp11_;
		if (G_UNLIKELY (_data_->_inner_error_ != NULL)) {
			goto __catch21_g_error;
		}
		_data_->_tmp12_ = _data_->self->priv->parser;
		_data_->_tmp13_ = _data_->stream;
		_data_->_state_ = 2;
		json_parser_load_from_stream_async (_data_->_tmp12_, _data_->_tmp13_, NULL, services_radio_browser_get_radios_by_name_ready, _data_);
		return FALSE;
		_state_2:
		json_parser_load_from_stream_finish (_data_->_tmp12_, _data_->_res_, &_data_->_inner_error_);
		if (G_UNLIKELY (_data_->_inner_error_ != NULL)) {
			_g_object_unref0 (_data_->stream);
			goto __catch21_g_error;
		}
		_g_object_unref0 (_data_->stream);
	}
	goto __finally21;
	__catch21_g_error:
	{
		_data_->e = _data_->_inner_error_;
		_data_->_inner_error_ = NULL;
		g_signal_emit (_data_->self, services_radio_browser_signals[SERVICES_RADIO_BROWSER_FINISHED_SIGNAL], 0);
		_data_->_tmp14_ = _data_->e;
		_data_->_tmp15_ = _data_->_tmp14_->message;
		g_print ("Error %s\n", _data_->_tmp15_);
		_g_error_free0 (_data_->e);
	}
	__finally21:
	if (G_UNLIKELY (_data_->_inner_error_ != NULL)) {
		_g_object_unref0 (_data_->message);
		_g_free0 (_data_->url);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _data_->_inner_error_->message, g_quark_to_string (_data_->_inner_error_->domain), _data_->_inner_error_->code);
		g_clear_error (&_data_->_inner_error_);
		g_object_unref (_data_->_async_result);
		return FALSE;
	}
	_g_object_unref0 (_data_->message);
	_g_free0 (_data_->url);
	g_task_return_pointer (_data_->_async_result, _data_, NULL);
	if (_data_->_state_ != 0) {
		while (_data_->_task_complete_ != TRUE) {
			g_main_context_iteration (g_task_get_context (_data_->_async_result), TRUE);
		}
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
}


static void
services_radio_browser_class_init (ServicesRadioBrowserClass * klass)
{
	services_radio_browser_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (ServicesRadioBrowserPrivate));
	G_OBJECT_CLASS (klass)->finalize = services_radio_browser_finalize;
	services_radio_browser_signals[SERVICES_RADIO_BROWSER_STARTED_SIGNAL] = g_signal_new ("started", SERVICES_TYPE_RADIO_BROWSER, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0);
	services_radio_browser_signals[SERVICES_RADIO_BROWSER_FINISHED_SIGNAL] = g_signal_new ("finished", SERVICES_TYPE_RADIO_BROWSER, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0);
	services_radio_browser_signals[SERVICES_RADIO_BROWSER_ITEM_LOADED_SIGNAL] = g_signal_new ("item-loaded", SERVICES_TYPE_RADIO_BROWSER, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__OBJECT, G_TYPE_NONE, 1, OBJECTS_TYPE_RADIO);
}


static void
services_radio_browser_instance_init (ServicesRadioBrowser * self)
{
	gchar* _tmp0_;
	self->priv = SERVICES_RADIO_BROWSER_GET_PRIVATE (self);
	g_datalist_init (&self->parameters);
	_tmp0_ = g_strdup ("http://www.radio-browser.info/webservice/json/stations/byname/");
	self->priv->API_URL = _tmp0_;
}


static void
services_radio_browser_finalize (GObject * obj)
{
	ServicesRadioBrowser * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, SERVICES_TYPE_RADIO_BROWSER, ServicesRadioBrowser);
	_g_object_unref0 (self->priv->parser);
	_g_object_unref0 (self->priv->session);
	_g_object_unref0 (self->priv->cancellable);
	_g_free0 (self->priv->API_URL);
	G_OBJECT_CLASS (services_radio_browser_parent_class)->finalize (obj);
}


GType
services_radio_browser_get_type (void)
{
	static volatile gsize services_radio_browser_type_id__volatile = 0;
	if (g_once_init_enter (&services_radio_browser_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (ServicesRadioBrowserClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) services_radio_browser_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (ServicesRadioBrowser), 0, (GInstanceInitFunc) services_radio_browser_instance_init, NULL };
		GType services_radio_browser_type_id;
		services_radio_browser_type_id = g_type_register_static (G_TYPE_OBJECT, "ServicesRadioBrowser", &g_define_type_info, 0);
		g_once_init_leave (&services_radio_browser_type_id__volatile, services_radio_browser_type_id);
	}
	return services_radio_browser_type_id__volatile;
}



