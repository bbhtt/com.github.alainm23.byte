/* TagManager.c generated by valac 0.40.11, the Vala compiler
 * generated from TagManager.vala, do not modify */



#include <glib.h>
#include <glib-object.h>
#include <gst/pbutils/pbutils.h>
#include <stdlib.h>
#include <string.h>
#include <glib/gi18n-lib.h>
#include <gst/gst.h>
#include <float.h>
#include <math.h>
#include <tag_c.h>
#include <gio/gio.h>


#define SERVICES_TYPE_TAG_MANAGER (services_tag_manager_get_type ())
#define SERVICES_TAG_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SERVICES_TYPE_TAG_MANAGER, ServicesTagManager))
#define SERVICES_TAG_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SERVICES_TYPE_TAG_MANAGER, ServicesTagManagerClass))
#define SERVICES_IS_TAG_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SERVICES_TYPE_TAG_MANAGER))
#define SERVICES_IS_TAG_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SERVICES_TYPE_TAG_MANAGER))
#define SERVICES_TAG_MANAGER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SERVICES_TYPE_TAG_MANAGER, ServicesTagManagerClass))

typedef struct _ServicesTagManager ServicesTagManager;
typedef struct _ServicesTagManagerClass ServicesTagManagerClass;
typedef struct _ServicesTagManagerPrivate ServicesTagManagerPrivate;
enum  {
	SERVICES_TAG_MANAGER_0_PROPERTY,
	SERVICES_TAG_MANAGER_NUM_PROPERTIES
};
static GParamSpec* services_tag_manager_properties[SERVICES_TAG_MANAGER_NUM_PROPERTIES];
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
typedef struct _Block4Data Block4Data;

#define OBJECTS_TYPE_TRACK (objects_track_get_type ())
#define OBJECTS_TRACK(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), OBJECTS_TYPE_TRACK, ObjectsTrack))
#define OBJECTS_TRACK_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), OBJECTS_TYPE_TRACK, ObjectsTrackClass))
#define OBJECTS_IS_TRACK(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), OBJECTS_TYPE_TRACK))
#define OBJECTS_IS_TRACK_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), OBJECTS_TYPE_TRACK))
#define OBJECTS_TRACK_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), OBJECTS_TYPE_TRACK, ObjectsTrackClass))

typedef struct _ObjectsTrack ObjectsTrack;
typedef struct _ObjectsTrackClass ObjectsTrackClass;
#define _g_date_time_unref0(var) ((var == NULL) ? NULL : (var = (g_date_time_unref (var), NULL)))
typedef struct _ObjectsTrackPrivate ObjectsTrackPrivate;

#define OBJECTS_TYPE_ALBUM (objects_album_get_type ())
#define OBJECTS_ALBUM(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), OBJECTS_TYPE_ALBUM, ObjectsAlbum))
#define OBJECTS_ALBUM_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), OBJECTS_TYPE_ALBUM, ObjectsAlbumClass))
#define OBJECTS_IS_ALBUM(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), OBJECTS_TYPE_ALBUM))
#define OBJECTS_IS_ALBUM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), OBJECTS_TYPE_ALBUM))
#define OBJECTS_ALBUM_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), OBJECTS_TYPE_ALBUM, ObjectsAlbumClass))

typedef struct _ObjectsAlbum ObjectsAlbum;
typedef struct _ObjectsAlbumClass ObjectsAlbumClass;
typedef struct _ObjectsAlbumPrivate ObjectsAlbumPrivate;
#define _gst_date_time_unref0(var) ((var == NULL) ? NULL : (var = (gst_date_time_unref (var), NULL)))

#define OBJECTS_TYPE_ARTIST (objects_artist_get_type ())
#define OBJECTS_ARTIST(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), OBJECTS_TYPE_ARTIST, ObjectsArtist))
#define OBJECTS_ARTIST_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), OBJECTS_TYPE_ARTIST, ObjectsArtistClass))
#define OBJECTS_IS_ARTIST(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), OBJECTS_TYPE_ARTIST))
#define OBJECTS_IS_ARTIST_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), OBJECTS_TYPE_ARTIST))
#define OBJECTS_ARTIST_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), OBJECTS_TYPE_ARTIST, ObjectsArtistClass))

typedef struct _ObjectsArtist ObjectsArtist;
typedef struct _ObjectsArtistClass ObjectsArtistClass;
typedef struct _ObjectsArtistPrivate ObjectsArtistPrivate;
#define _taglib_file_free0(var) ((var == NULL) ? NULL : (var = (taglib_file_free (var), NULL)))
#define _gst_tag_list_unref0(var) ((var == NULL) ? NULL : (var = (gst_tag_list_unref (var), NULL)))
#define _g_thread_unref0(var) ((var == NULL) ? NULL : (var = (g_thread_unref (var), NULL)))
enum  {
	SERVICES_TAG_MANAGER_DISCOVERED_NEW_ITEM_SIGNAL,
	SERVICES_TAG_MANAGER_NUM_SIGNALS
};
static guint services_tag_manager_signals[SERVICES_TAG_MANAGER_NUM_SIGNALS] = {0};

struct _ServicesTagManager {
	GObject parent_instance;
	ServicesTagManagerPrivate * priv;
};

struct _ServicesTagManagerClass {
	GObjectClass parent_class;
};

struct _ServicesTagManagerPrivate {
	GstDiscoverer* discoverer;
	gchar* unknown;
};

struct _Block4Data {
	int _ref_count_;
	ServicesTagManager* self;
	GstDiscovererInfo* info;
	GError* err;
};

struct _ObjectsTrack {
	GObject parent_instance;
	ObjectsTrackPrivate * priv;
	gint track_order;
	gint id;
	gint album_id;
	gint track;
	gint disc;
	gint play_count;
	gint is_favorite;
	gint bitrate;
	gint bpm;
	gint rating;
	gint samplerate;
	gint channels;
	gint year;
	gint playlist;
	guint64 duration;
	gchar* path;
	gchar* title;
	gchar* favorite_added;
	gchar* last_played;
	gchar* album_title;
	gchar* artist_name;
	gchar* composer;
	gchar* grouping;
	gchar* comment;
	gchar* lyrics;
	gchar* genre;
	gchar* album_artist;
	gchar* date_added;
};

struct _ObjectsTrackClass {
	GObjectClass parent_class;
};

struct _ObjectsAlbum {
	GObject parent_instance;
	ObjectsAlbumPrivate * priv;
	gint id;
	gint artist_id;
	gchar* artist_name;
	gint year;
	gchar* title;
	gchar* genre;
};

struct _ObjectsAlbumClass {
	GObjectClass parent_class;
};

struct _ObjectsArtist {
	GObject parent_instance;
	ObjectsArtistPrivate * priv;
	gint id;
	gchar* name;
};

struct _ObjectsArtistClass {
	GObjectClass parent_class;
};


static gpointer services_tag_manager_parent_class = NULL;

GType services_tag_manager_get_type (void) G_GNUC_CONST;
#define SERVICES_TAG_MANAGER_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), SERVICES_TYPE_TAG_MANAGER, ServicesTagManagerPrivate))
static void services_tag_manager_discovered (ServicesTagManager* self,
                                      GstDiscovererInfo* info,
                                      GError* err);
static Block4Data* block4_data_ref (Block4Data* _data4_);
static void block4_data_unref (void * _userdata_);
static void* __lambda14_ (Block4Data* _data4_);
const gchar* gst_pb_utils_discoverer_result_to_string (GstDiscovererResult self);
GType objects_track_get_type (void) G_GNUC_CONST;
ObjectsTrack* objects_track_new (gint track_order,
                                 gint id,
                                 gint album_id,
                                 gint track,
                                 gint disc,
                                 gint play_count,
                                 gint is_favorite,
                                 gint bitrate,
                                 gint bpm,
                                 gint rating,
                                 gint samplerate,
                                 gint channels,
                                 gint year,
                                 gint playlist,
                                 guint64 duration,
                                 const gchar* path,
                                 const gchar* title,
                                 const gchar* favorite_added,
                                 const gchar* last_played,
                                 const gchar* album_title,
                                 const gchar* artist_name,
                                 const gchar* composer,
                                 const gchar* grouping,
                                 const gchar* comment,
                                 const gchar* lyrics,
                                 const gchar* genre,
                                 const gchar* album_artist,
                                 const gchar* date_added);
ObjectsTrack* objects_track_construct (GType object_type,
                                       gint track_order,
                                       gint id,
                                       gint album_id,
                                       gint track,
                                       gint disc,
                                       gint play_count,
                                       gint is_favorite,
                                       gint bitrate,
                                       gint bpm,
                                       gint rating,
                                       gint samplerate,
                                       gint channels,
                                       gint year,
                                       gint playlist,
                                       guint64 duration,
                                       const gchar* path,
                                       const gchar* title,
                                       const gchar* favorite_added,
                                       const gchar* last_played,
                                       const gchar* album_title,
                                       const gchar* artist_name,
                                       const gchar* composer,
                                       const gchar* grouping,
                                       const gchar* comment,
                                       const gchar* lyrics,
                                       const gchar* genre,
                                       const gchar* album_artist,
                                       const gchar* date_added);
GType objects_album_get_type (void) G_GNUC_CONST;
ObjectsAlbum* objects_album_new (gint id,
                                 gint artist_id,
                                 const gchar* artist_name,
                                 gint year,
                                 const gchar* title,
                                 const gchar* genre);
ObjectsAlbum* objects_album_construct (GType object_type,
                                       gint id,
                                       gint artist_id,
                                       const gchar* artist_name,
                                       gint year,
                                       const gchar* title,
                                       const gchar* genre);
static GDate* _g_date_dup (GDate* self);
GType objects_artist_get_type (void) G_GNUC_CONST;
ObjectsArtist* objects_artist_new (gint id,
                                   const gchar* name);
ObjectsArtist* objects_artist_construct (GType object_type,
                                         gint id,
                                         const gchar* name);
static gpointer ___lambda14__gthread_func (gpointer self);
void services_tag_manager_add_discover_uri (ServicesTagManager* self,
                                            const gchar* uri);
ServicesTagManager* services_tag_manager_new (void);
ServicesTagManager* services_tag_manager_construct (GType object_type);
static void g_cclosure_user_marshal_VOID__OBJECT_OBJECT_OBJECT (GClosure * closure,
                                                         GValue * return_value,
                                                         guint n_param_values,
                                                         const GValue * param_values,
                                                         gpointer invocation_hint,
                                                         gpointer marshal_data);
static GObject * services_tag_manager_constructor (GType type,
                                            guint n_construct_properties,
                                            GObjectConstructParam * construct_properties);
static void _services_tag_manager_discovered_gst_discoverer_discovered (GstDiscoverer* _sender,
                                                                 GstDiscovererInfo* info,
                                                                 GError* err,
                                                                 gpointer self);
static void services_tag_manager_finalize (GObject * obj);


static gpointer
_g_object_ref0 (gpointer self)
{
	return self ? g_object_ref (self) : NULL;
}


static gpointer
_g_error_copy0 (gpointer self)
{
	return self ? g_error_copy (self) : NULL;
}


static Block4Data*
block4_data_ref (Block4Data* _data4_)
{
	g_atomic_int_inc (&_data4_->_ref_count_);
	return _data4_;
}


static void
block4_data_unref (void * _userdata_)
{
	Block4Data* _data4_;
	_data4_ = (Block4Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data4_->_ref_count_)) {
		ServicesTagManager* self;
		self = _data4_->self;
		_g_object_unref0 (_data4_->info);
		_g_error_free0 (_data4_->err);
		_g_object_unref0 (self);
		g_slice_free (Block4Data, _data4_);
	}
}


static gpointer
_gst_tag_list_ref0 (gpointer self)
{
	return self ? gst_tag_list_ref (self) : NULL;
}


static gchar*
g_date_time_to_string (GDateTime* self)
{
	gchar* result = NULL;
	gchar* _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = g_date_time_format (self, "%FT%H:%M:%S%z");
	result = _tmp0_;
	return result;
}


static gchar*
string_strip (const gchar* self)
{
	gchar* result = NULL;
	gchar* _result_ = NULL;
	gchar* _tmp0_;
	const gchar* _tmp1_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = g_strdup (self);
	_result_ = _tmp0_;
	_tmp1_ = _result_;
	g_strstrip (_tmp1_);
	result = _result_;
	return result;
}


static GDate*
_g_date_dup (GDate* self)
{
	GDate* dup;
	dup = g_new0 (GDate, 1);
	memcpy (dup, self, sizeof (GDate));
	return dup;
}


static gpointer
__g_date_dup0 (gpointer self)
{
	return self ? _g_date_dup (self) : NULL;
}


static void*
__lambda14_ (Block4Data* _data4_)
{
	ServicesTagManager* self;
	void* result = NULL;
	gchar* uri = NULL;
	const gchar* _tmp0_;
	gchar* _tmp1_;
	self = _data4_->self;
	_tmp0_ = gst_discoverer_info_get_uri (_data4_->info);
	_tmp1_ = g_strdup (_tmp0_);
	uri = _tmp1_;
	if (gst_discoverer_info_get_result (_data4_->info) != GST_DISCOVERER_OK) {
		if (_data4_->err != NULL) {
			gint _tmp2_;
			const gchar* _tmp3_;
			GEnumValue* _tmp4_;
			const gchar* _tmp5_;
			_tmp2_ = _data4_->err->code;
			_tmp3_ = _data4_->err->message;
			_tmp4_ = g_enum_get_value (g_type_class_ref (gst_discoverer_result_get_type ()), gst_discoverer_info_get_result (_data4_->info));
			_tmp5_ = uri;
			g_warning ("TagManager.vala:22: DISCOVER ERROR: '%d' %s %s\n(%s)", _tmp2_, _tmp3_, (_tmp4_ != NULL) ? _tmp4_->value_name : NULL, _tmp5_);
		}
	} else {
		GstTagList* tags = NULL;
		GstTagList* _tmp6_;
		GstTagList* _tmp7_;
		GstTagList* _tmp8_;
		_tmp6_ = gst_discoverer_info_get_tags (_data4_->info);
		_tmp7_ = _gst_tag_list_ref0 (_tmp6_);
		tags = _tmp7_;
		_tmp8_ = tags;
		if (_tmp8_ != NULL) {
			guint64 duration = 0ULL;
			gchar* o = NULL;
			GDate* d = NULL;
			GstDateTime* dt = NULL;
			guint u = 0U;
			gdouble dou = 0.0;
			ObjectsTrack* track = NULL;
			GDateTime* _tmp9_;
			GDateTime* _tmp10_;
			gchar* _tmp11_;
			gchar* _tmp12_;
			ObjectsTrack* _tmp13_;
			ObjectsTrack* _tmp14_;
			ObjectsTrack* _tmp15_;
			guint64 _tmp16_;
			ObjectsTrack* _tmp17_;
			const gchar* _tmp18_;
			gchar* _tmp19_;
			GstTagList* _tmp20_;
			gchar* _tmp21_ = NULL;
			gboolean _tmp22_;
			ObjectsTrack* _tmp26_;
			const gchar* _tmp27_;
			gchar* _tmp28_;
			gchar* _tmp29_;
			gboolean _tmp30_;
			GstTagList* _tmp34_;
			guint _tmp35_ = 0U;
			gboolean _tmp36_;
			GstTagList* _tmp39_;
			guint _tmp40_ = 0U;
			gboolean _tmp41_;
			GstTagList* _tmp44_;
			gchar* _tmp45_ = NULL;
			gboolean _tmp46_;
			GstTagList* _tmp50_;
			gchar* _tmp51_ = NULL;
			gboolean _tmp52_;
			GstTagList* _tmp56_;
			gchar* _tmp57_ = NULL;
			gboolean _tmp58_;
			TagLib_File* file = NULL;
			const gchar* _tmp62_;
			GFile* _tmp63_;
			GFile* _tmp64_;
			gchar* _tmp65_;
			gchar* _tmp66_;
			TagLib_File* _tmp67_;
			TagLib_File* _tmp68_;
			ObjectsTrack* _tmp69_;
			TagLib_File* _tmp70_;
			const TagLib_AudioProperties* _tmp71_;
			const TagLib_AudioProperties* _tmp72_;
			gint _tmp73_;
			gint _tmp74_;
			ObjectsTrack* _tmp75_;
			TagLib_File* _tmp76_;
			const TagLib_AudioProperties* _tmp77_;
			const TagLib_AudioProperties* _tmp78_;
			gint _tmp79_;
			gint _tmp80_;
			ObjectsTrack* _tmp81_;
			TagLib_File* _tmp82_;
			const TagLib_AudioProperties* _tmp83_;
			const TagLib_AudioProperties* _tmp84_;
			gint _tmp85_;
			gint _tmp86_;
			GstTagList* _tmp87_;
			guint _tmp88_ = 0U;
			gboolean _tmp89_;
			GstTagList* _tmp97_;
			gdouble _tmp98_ = 0.0;
			gboolean _tmp99_;
			ObjectsAlbum* album = NULL;
			ObjectsAlbum* _tmp103_;
			GstTagList* _tmp104_;
			gchar* _tmp105_ = NULL;
			gboolean _tmp106_;
			ObjectsAlbum* _tmp110_;
			const gchar* _tmp111_;
			gchar* _tmp112_;
			gchar* _tmp113_;
			gboolean _tmp114_;
			GstTagList* _tmp124_;
			GstDateTime* _tmp125_ = NULL;
			gboolean _tmp126_;
			GstTagList* _tmp142_;
			gchar* _tmp143_ = NULL;
			gboolean _tmp144_;
			ObjectsArtist* artist = NULL;
			ObjectsArtist* _tmp151_;
			GstTagList* _tmp152_;
			gchar* _tmp153_ = NULL;
			gboolean _tmp154_;
			ObjectsArtist* _tmp167_;
			const gchar* _tmp168_;
			gchar* _tmp169_;
			gchar* _tmp170_;
			gboolean _tmp171_;
			ObjectsArtist* _tmp184_;
			ObjectsAlbum* _tmp185_;
			ObjectsTrack* _tmp186_;
			duration = (guint64) gst_discoverer_info_get_duration (_data4_->info);
			_tmp9_ = g_date_time_new_now_local ();
			_tmp10_ = _tmp9_;
			_tmp11_ = g_date_time_to_string (_tmp10_);
			_tmp12_ = _tmp11_;
			_tmp13_ = objects_track_new (0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (guint64) 0, "", "", "", "", "", "", "", "", "", "", "", "", _tmp12_);
			_tmp14_ = _tmp13_;
			_g_free0 (_tmp12_);
			_g_date_time_unref0 (_tmp10_);
			track = _tmp14_;
			_tmp15_ = track;
			_tmp16_ = duration;
			_tmp15_->duration = _tmp16_;
			_tmp17_ = track;
			_tmp18_ = uri;
			_tmp19_ = g_strdup (_tmp18_);
			_g_free0 (_tmp17_->path);
			_tmp17_->path = _tmp19_;
			_tmp20_ = tags;
			_tmp22_ = gst_tag_list_get_string (_tmp20_, GST_TAG_TITLE, &_tmp21_);
			_g_free0 (o);
			o = _tmp21_;
			if (_tmp22_) {
				ObjectsTrack* _tmp23_;
				const gchar* _tmp24_;
				gchar* _tmp25_;
				_tmp23_ = track;
				_tmp24_ = o;
				_tmp25_ = g_strdup (_tmp24_);
				_g_free0 (_tmp23_->title);
				_tmp23_->title = _tmp25_;
			}
			_tmp26_ = track;
			_tmp27_ = _tmp26_->title;
			_tmp28_ = string_strip (_tmp27_);
			_tmp29_ = _tmp28_;
			_tmp30_ = g_strcmp0 (_tmp29_, "") == 0;
			_g_free0 (_tmp29_);
			if (_tmp30_) {
				ObjectsTrack* _tmp31_;
				const gchar* _tmp32_;
				gchar* _tmp33_;
				_tmp31_ = track;
				_tmp32_ = uri;
				_tmp33_ = g_path_get_basename (_tmp32_);
				_g_free0 (_tmp31_->title);
				_tmp31_->title = _tmp33_;
			}
			_tmp34_ = tags;
			_tmp36_ = gst_tag_list_get_uint (_tmp34_, GST_TAG_TRACK_NUMBER, &_tmp35_);
			u = _tmp35_;
			if (_tmp36_) {
				ObjectsTrack* _tmp37_;
				guint _tmp38_;
				_tmp37_ = track;
				_tmp38_ = u;
				_tmp37_->track = (gint) _tmp38_;
			}
			_tmp39_ = tags;
			_tmp41_ = gst_tag_list_get_uint (_tmp39_, GST_TAG_ALBUM_VOLUME_NUMBER, &_tmp40_);
			u = _tmp40_;
			if (_tmp41_) {
				ObjectsTrack* _tmp42_;
				guint _tmp43_;
				_tmp42_ = track;
				_tmp43_ = u;
				_tmp42_->disc = (gint) _tmp43_;
			}
			_tmp44_ = tags;
			_tmp46_ = gst_tag_list_get_string (_tmp44_, GST_TAG_COMPOSER, &_tmp45_);
			_g_free0 (o);
			o = _tmp45_;
			if (_tmp46_) {
				ObjectsTrack* _tmp47_;
				const gchar* _tmp48_;
				gchar* _tmp49_;
				_tmp47_ = track;
				_tmp48_ = o;
				_tmp49_ = g_strdup (_tmp48_);
				_g_free0 (_tmp47_->composer);
				_tmp47_->composer = _tmp49_;
			}
			_tmp50_ = tags;
			_tmp52_ = gst_tag_list_get_string (_tmp50_, GST_TAG_GROUPING, &_tmp51_);
			_g_free0 (o);
			o = _tmp51_;
			if (_tmp52_) {
				ObjectsTrack* _tmp53_;
				const gchar* _tmp54_;
				gchar* _tmp55_;
				_tmp53_ = track;
				_tmp54_ = o;
				_tmp55_ = g_strdup (_tmp54_);
				_g_free0 (_tmp53_->grouping);
				_tmp53_->grouping = _tmp55_;
			}
			_tmp56_ = tags;
			_tmp58_ = gst_tag_list_get_string (_tmp56_, GST_TAG_LYRICS, &_tmp57_);
			_g_free0 (o);
			o = _tmp57_;
			if (_tmp58_) {
				ObjectsTrack* _tmp59_;
				const gchar* _tmp60_;
				gchar* _tmp61_;
				_tmp59_ = track;
				_tmp60_ = o;
				_tmp61_ = g_strdup (_tmp60_);
				_g_free0 (_tmp59_->lyrics);
				_tmp59_->lyrics = _tmp61_;
			}
			_tmp62_ = uri;
			_tmp63_ = g_file_new_for_uri (_tmp62_);
			_tmp64_ = _tmp63_;
			_tmp65_ = g_file_get_path (_tmp64_);
			_tmp66_ = _tmp65_;
			_tmp67_ = taglib_file_new (_tmp66_);
			_tmp68_ = _tmp67_;
			_g_free0 (_tmp66_);
			_g_object_unref0 (_tmp64_);
			file = _tmp68_;
			_tmp69_ = track;
			_tmp70_ = file;
			_tmp71_ = taglib_file_audioproperties (_tmp70_);
			_tmp72_ = _tmp71_;
			_tmp73_ = taglib_audioproperties_bitrate (_tmp72_);
			_tmp74_ = _tmp73_;
			_tmp69_->bitrate = _tmp74_;
			_tmp75_ = track;
			_tmp76_ = file;
			_tmp77_ = taglib_file_audioproperties (_tmp76_);
			_tmp78_ = _tmp77_;
			_tmp79_ = taglib_audioproperties_samplerate (_tmp78_);
			_tmp80_ = _tmp79_;
			_tmp75_->samplerate = _tmp80_;
			_tmp81_ = track;
			_tmp82_ = file;
			_tmp83_ = taglib_file_audioproperties (_tmp82_);
			_tmp84_ = _tmp83_;
			_tmp85_ = taglib_audioproperties_channels (_tmp84_);
			_tmp86_ = _tmp85_;
			_tmp81_->channels = _tmp86_;
			_tmp87_ = tags;
			_tmp89_ = gst_tag_list_get_uint (_tmp87_, GST_TAG_USER_RATING, &_tmp88_);
			u = _tmp88_;
			if (_tmp89_) {
				guint _tmp90_;
				gchar* _tmp91_;
				gchar* _tmp92_;
				gchar* _tmp93_;
				gchar* _tmp94_;
				ObjectsTrack* _tmp95_;
				guint _tmp96_;
				_tmp90_ = u;
				_tmp91_ = g_strdup_printf ("%u", _tmp90_);
				_tmp92_ = _tmp91_;
				_tmp93_ = g_strdup_printf ("USER_RATING: %s\n", _tmp92_);
				_tmp94_ = _tmp93_;
				g_print ("%s", _tmp94_);
				_g_free0 (_tmp94_);
				_g_free0 (_tmp92_);
				_tmp95_ = track;
				_tmp96_ = u;
				_tmp95_->rating = (gint) _tmp96_;
			}
			_tmp97_ = tags;
			_tmp99_ = gst_tag_list_get_double (_tmp97_, GST_TAG_BEATS_PER_MINUTE, &_tmp98_);
			dou = _tmp98_;
			if (_tmp99_) {
				ObjectsTrack* _tmp100_;
				gdouble _tmp101_;
				gdouble _tmp102_;
				_tmp100_ = track;
				_tmp101_ = dou;
				_tmp102_ = dou;
				_tmp100_->bpm = (gint) CLAMP (_tmp101_, (gdouble) 0, _tmp102_);
			}
			_tmp103_ = objects_album_new (0, 0, "", 0, "", "");
			album = _tmp103_;
			_tmp104_ = tags;
			_tmp106_ = gst_tag_list_get_string (_tmp104_, GST_TAG_ALBUM, &_tmp105_);
			_g_free0 (o);
			o = _tmp105_;
			if (_tmp106_) {
				ObjectsAlbum* _tmp107_;
				const gchar* _tmp108_;
				gchar* _tmp109_;
				_tmp107_ = album;
				_tmp108_ = o;
				_tmp109_ = g_strdup (_tmp108_);
				_g_free0 (_tmp107_->title);
				_tmp107_->title = _tmp109_;
			}
			_tmp110_ = album;
			_tmp111_ = _tmp110_->title;
			_tmp112_ = string_strip (_tmp111_);
			_tmp113_ = _tmp112_;
			_tmp114_ = g_strcmp0 (_tmp113_, "") == 0;
			_g_free0 (_tmp113_);
			if (_tmp114_) {
				gchar* dir = NULL;
				const gchar* _tmp115_;
				gchar* _tmp116_;
				const gchar* _tmp117_;
				_tmp115_ = uri;
				_tmp116_ = g_path_get_dirname (_tmp115_);
				dir = _tmp116_;
				_tmp117_ = dir;
				if (_tmp117_ != NULL) {
					ObjectsAlbum* _tmp118_;
					const gchar* _tmp119_;
					gchar* _tmp120_;
					_tmp118_ = album;
					_tmp119_ = dir;
					_tmp120_ = g_path_get_basename (_tmp119_);
					_g_free0 (_tmp118_->title);
					_tmp118_->title = _tmp120_;
				} else {
					ObjectsAlbum* _tmp121_;
					const gchar* _tmp122_;
					gchar* _tmp123_;
					_tmp121_ = album;
					_tmp122_ = self->priv->unknown;
					_tmp123_ = g_strdup (_tmp122_);
					_g_free0 (_tmp121_->title);
					_tmp121_->title = _tmp123_;
				}
				_g_free0 (dir);
			}
			_tmp124_ = tags;
			_tmp126_ = gst_tag_list_get_date_time (_tmp124_, GST_TAG_DATE_TIME, &_tmp125_);
			_gst_date_time_unref0 (dt);
			dt = _tmp125_;
			if (_tmp126_) {
				GstDateTime* _tmp127_;
				_tmp127_ = dt;
				if (_tmp127_ != NULL) {
					ObjectsAlbum* _tmp128_;
					GstDateTime* _tmp129_;
					ObjectsTrack* _tmp130_;
					GstDateTime* _tmp131_;
					_tmp128_ = album;
					_tmp129_ = dt;
					_tmp128_->year = gst_date_time_get_year (_tmp129_);
					_tmp130_ = track;
					_tmp131_ = dt;
					_tmp130_->year = gst_date_time_get_year (_tmp131_);
				} else {
					GstTagList* _tmp132_;
					GDate _tmp133_ = {0};
					gboolean _tmp134_;
					GDate _tmp135_;
					GDate* _tmp136_;
					_tmp132_ = tags;
					_tmp134_ = gst_tag_list_get_date (_tmp132_, GST_TAG_DATE, &_tmp133_);
					_g_free0 (d);
					_tmp135_ = _tmp133_;
					_tmp136_ = __g_date_dup0 (&_tmp135_);
					d = _tmp136_;
					if (_tmp134_) {
						GDate* _tmp137_;
						_tmp137_ = d;
						if (_tmp137_ != NULL) {
							ObjectsAlbum* _tmp138_;
							GstDateTime* _tmp139_;
							ObjectsTrack* _tmp140_;
							GstDateTime* _tmp141_;
							_tmp138_ = album;
							_tmp139_ = dt;
							_tmp138_->year = gst_date_time_get_year (_tmp139_);
							_tmp140_ = track;
							_tmp141_ = dt;
							_tmp140_->year = gst_date_time_get_year (_tmp141_);
						}
					}
				}
			}
			_tmp142_ = tags;
			_tmp144_ = gst_tag_list_get_string (_tmp142_, GST_TAG_GENRE, &_tmp143_);
			_g_free0 (o);
			o = _tmp143_;
			if (_tmp144_) {
				ObjectsAlbum* _tmp145_;
				const gchar* _tmp146_;
				gchar* _tmp147_;
				ObjectsTrack* _tmp148_;
				const gchar* _tmp149_;
				gchar* _tmp150_;
				_tmp145_ = album;
				_tmp146_ = o;
				_tmp147_ = g_strdup (_tmp146_);
				_g_free0 (_tmp145_->genre);
				_tmp145_->genre = _tmp147_;
				_tmp148_ = track;
				_tmp149_ = o;
				_tmp150_ = g_strdup (_tmp149_);
				_g_free0 (_tmp148_->genre);
				_tmp148_->genre = _tmp150_;
			}
			_tmp151_ = objects_artist_new (0, "");
			artist = _tmp151_;
			_tmp152_ = tags;
			_tmp154_ = gst_tag_list_get_string (_tmp152_, GST_TAG_ALBUM_ARTIST, &_tmp153_);
			_g_free0 (o);
			o = _tmp153_;
			if (_tmp154_) {
				ObjectsTrack* _tmp155_;
				const gchar* _tmp156_;
				gchar* _tmp157_;
				ObjectsArtist* _tmp158_;
				const gchar* _tmp159_;
				gchar* _tmp160_;
				_tmp155_ = track;
				_tmp156_ = o;
				_tmp157_ = g_strdup (_tmp156_);
				_g_free0 (_tmp155_->album_artist);
				_tmp155_->album_artist = _tmp157_;
				_tmp158_ = artist;
				_tmp159_ = o;
				_tmp160_ = g_strdup (_tmp159_);
				_g_free0 (_tmp158_->name);
				_tmp158_->name = _tmp160_;
			} else {
				GstTagList* _tmp161_;
				gchar* _tmp162_ = NULL;
				gboolean _tmp163_;
				_tmp161_ = tags;
				_tmp163_ = gst_tag_list_get_string (_tmp161_, GST_TAG_ARTIST, &_tmp162_);
				_g_free0 (o);
				o = _tmp162_;
				if (_tmp163_) {
					ObjectsArtist* _tmp164_;
					const gchar* _tmp165_;
					gchar* _tmp166_;
					_tmp164_ = artist;
					_tmp165_ = o;
					_tmp166_ = g_strdup (_tmp165_);
					_g_free0 (_tmp164_->name);
					_tmp164_->name = _tmp166_;
				}
			}
			_tmp167_ = artist;
			_tmp168_ = _tmp167_->name;
			_tmp169_ = string_strip (_tmp168_);
			_tmp170_ = _tmp169_;
			_tmp171_ = g_strcmp0 (_tmp170_, "") == 0;
			_g_free0 (_tmp170_);
			if (_tmp171_) {
				gchar* dir = NULL;
				const gchar* _tmp172_;
				gchar* _tmp173_;
				gchar* _tmp174_;
				gchar* _tmp175_;
				gchar* _tmp176_;
				const gchar* _tmp177_;
				_tmp172_ = uri;
				_tmp173_ = g_path_get_dirname (_tmp172_);
				_tmp174_ = _tmp173_;
				_tmp175_ = g_path_get_dirname (_tmp174_);
				_tmp176_ = _tmp175_;
				_g_free0 (_tmp174_);
				dir = _tmp176_;
				_tmp177_ = dir;
				if (_tmp177_ != NULL) {
					ObjectsArtist* _tmp178_;
					const gchar* _tmp179_;
					gchar* _tmp180_;
					_tmp178_ = artist;
					_tmp179_ = dir;
					_tmp180_ = g_path_get_basename (_tmp179_);
					_g_free0 (_tmp178_->name);
					_tmp178_->name = _tmp180_;
				} else {
					ObjectsArtist* _tmp181_;
					const gchar* _tmp182_;
					gchar* _tmp183_;
					_tmp181_ = artist;
					_tmp182_ = self->priv->unknown;
					_tmp183_ = g_strdup (_tmp182_);
					_g_free0 (_tmp181_->name);
					_tmp181_->name = _tmp183_;
				}
				_g_free0 (dir);
			}
			_tmp184_ = artist;
			_tmp185_ = album;
			_tmp186_ = track;
			g_signal_emit (self, services_tag_manager_signals[SERVICES_TAG_MANAGER_DISCOVERED_NEW_ITEM_SIGNAL], 0, _tmp184_, _tmp185_, _tmp186_);
			_g_object_unref0 (artist);
			_g_object_unref0 (album);
			_taglib_file_free0 (file);
			_g_object_unref0 (track);
			_gst_date_time_unref0 (dt);
			_g_free0 (d);
			_g_free0 (o);
		}
		_gst_tag_list_unref0 (tags);
	}
	g_object_run_dispose ((GObject*) _data4_->info);
	result = NULL;
	_g_free0 (uri);
	return result;
}


static gpointer
___lambda14__gthread_func (gpointer self)
{
	gpointer result;
	result = __lambda14_ (self);
	block4_data_unref (self);
	return result;
}


static void
services_tag_manager_discovered (ServicesTagManager* self,
                                 GstDiscovererInfo* info,
                                 GError* err)
{
	Block4Data* _data4_;
	GstDiscovererInfo* _tmp0_;
	GError* _tmp1_;
	GThread* _tmp2_;
	GThread* _tmp3_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (info != NULL);
	_data4_ = g_slice_new0 (Block4Data);
	_data4_->_ref_count_ = 1;
	_data4_->self = g_object_ref (self);
	_tmp0_ = _g_object_ref0 (info);
	_g_object_unref0 (_data4_->info);
	_data4_->info = _tmp0_;
	_tmp1_ = _g_error_copy0 (err);
	_g_error_free0 (_data4_->err);
	_data4_->err = _tmp1_;
	_tmp2_ = g_thread_new (NULL, ___lambda14__gthread_func, block4_data_ref (_data4_));
	_tmp3_ = _tmp2_;
	_g_thread_unref0 (_tmp3_);
	block4_data_unref (_data4_);
	_data4_ = NULL;
}


void
services_tag_manager_add_discover_uri (ServicesTagManager* self,
                                       const gchar* uri)
{
	GstDiscoverer* _tmp0_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (uri != NULL);
	_tmp0_ = self->priv->discoverer;
	gst_discoverer_discover_uri_async (_tmp0_, uri);
}


ServicesTagManager*
services_tag_manager_construct (GType object_type)
{
	ServicesTagManager * self = NULL;
	self = (ServicesTagManager*) g_object_new (object_type, NULL);
	return self;
}


ServicesTagManager*
services_tag_manager_new (void)
{
	return services_tag_manager_construct (SERVICES_TYPE_TAG_MANAGER);
}


static void
g_cclosure_user_marshal_VOID__OBJECT_OBJECT_OBJECT (GClosure * closure,
                                                    GValue * return_value,
                                                    guint n_param_values,
                                                    const GValue * param_values,
                                                    gpointer invocation_hint,
                                                    gpointer marshal_data)
{
	typedef void (*GMarshalFunc_VOID__OBJECT_OBJECT_OBJECT) (gpointer data1, gpointer arg_1, gpointer arg_2, gpointer arg_3, gpointer data2);
	register GMarshalFunc_VOID__OBJECT_OBJECT_OBJECT callback;
	register GCClosure * cc;
	register gpointer data1;
	register gpointer data2;
	cc = (GCClosure *) closure;
	g_return_if_fail (n_param_values == 4);
	if (G_CCLOSURE_SWAP_DATA (closure)) {
		data1 = closure->data;
		data2 = param_values->data[0].v_pointer;
	} else {
		data1 = param_values->data[0].v_pointer;
		data2 = closure->data;
	}
	callback = (GMarshalFunc_VOID__OBJECT_OBJECT_OBJECT) (marshal_data ? marshal_data : cc->callback);
	callback (data1, g_value_get_object (param_values + 1), g_value_get_object (param_values + 2), g_value_get_object (param_values + 3), data2);
}


static void
_services_tag_manager_discovered_gst_discoverer_discovered (GstDiscoverer* _sender,
                                                            GstDiscovererInfo* info,
                                                            GError* err,
                                                            gpointer self)
{
	services_tag_manager_discovered ((ServicesTagManager*) self, info, err);
}


static GObject *
services_tag_manager_constructor (GType type,
                                  guint n_construct_properties,
                                  GObjectConstructParam * construct_properties)
{
	GObject * obj;
	GObjectClass * parent_class;
	ServicesTagManager * self;
	GError * _inner_error_ = NULL;
	parent_class = G_OBJECT_CLASS (services_tag_manager_parent_class);
	obj = parent_class->constructor (type, n_construct_properties, construct_properties);
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, SERVICES_TYPE_TAG_MANAGER, ServicesTagManager);
	{
		GstDiscoverer* _tmp0_ = NULL;
		GstDiscoverer* _tmp1_;
		GstDiscoverer* _tmp2_;
		GstDiscoverer* _tmp3_;
		GstDiscoverer* _tmp4_;
		_tmp1_ = gst_discoverer_new ((GstClockTime) (5 * GST_SECOND), &_inner_error_);
		_tmp0_ = _tmp1_;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			goto __catch8_g_error;
		}
		_tmp2_ = _tmp0_;
		_tmp0_ = NULL;
		_g_object_unref0 (self->priv->discoverer);
		self->priv->discoverer = _tmp2_;
		_tmp3_ = self->priv->discoverer;
		gst_discoverer_start (_tmp3_);
		_tmp4_ = self->priv->discoverer;
		g_signal_connect_object (_tmp4_, "discovered", (GCallback) _services_tag_manager_discovered_gst_discoverer_discovered, self, 0);
		_g_object_unref0 (_tmp0_);
	}
	goto __finally8;
	__catch8_g_error:
	{
		GError* err = NULL;
		GError* _tmp5_;
		const gchar* _tmp6_;
		err = _inner_error_;
		_inner_error_ = NULL;
		_tmp5_ = err;
		_tmp6_ = _tmp5_->message;
		g_warning ("TagManager.vala:12: %s", _tmp6_);
		_g_error_free0 (err);
	}
	__finally8:
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
	}
	return obj;
}


static void
services_tag_manager_class_init (ServicesTagManagerClass * klass)
{
	services_tag_manager_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (ServicesTagManagerPrivate));
	G_OBJECT_CLASS (klass)->constructor = services_tag_manager_constructor;
	G_OBJECT_CLASS (klass)->finalize = services_tag_manager_finalize;
	services_tag_manager_signals[SERVICES_TAG_MANAGER_DISCOVERED_NEW_ITEM_SIGNAL] = g_signal_new ("discovered-new-item", SERVICES_TYPE_TAG_MANAGER, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_user_marshal_VOID__OBJECT_OBJECT_OBJECT, G_TYPE_NONE, 3, OBJECTS_TYPE_ARTIST, OBJECTS_TYPE_ALBUM, OBJECTS_TYPE_TRACK);
}


static void
services_tag_manager_instance_init (ServicesTagManager * self)
{
	gchar* _tmp0_;
	self->priv = SERVICES_TAG_MANAGER_GET_PRIVATE (self);
	_tmp0_ = g_strdup (_ ("Unknown"));
	self->priv->unknown = _tmp0_;
}


static void
services_tag_manager_finalize (GObject * obj)
{
	ServicesTagManager * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, SERVICES_TYPE_TAG_MANAGER, ServicesTagManager);
	_g_object_unref0 (self->priv->discoverer);
	_g_free0 (self->priv->unknown);
	G_OBJECT_CLASS (services_tag_manager_parent_class)->finalize (obj);
}


GType
services_tag_manager_get_type (void)
{
	static volatile gsize services_tag_manager_type_id__volatile = 0;
	if (g_once_init_enter (&services_tag_manager_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (ServicesTagManagerClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) services_tag_manager_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (ServicesTagManager), 0, (GInstanceInitFunc) services_tag_manager_instance_init, NULL };
		GType services_tag_manager_type_id;
		services_tag_manager_type_id = g_type_register_static (G_TYPE_OBJECT, "ServicesTagManager", &g_define_type_info, 0);
		g_once_init_leave (&services_tag_manager_type_id__volatile, services_tag_manager_type_id);
	}
	return services_tag_manager_type_id__volatile;
}



