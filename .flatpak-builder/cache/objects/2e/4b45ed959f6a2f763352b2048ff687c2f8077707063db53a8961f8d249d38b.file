/* Player.c generated by valac 0.40.11, the Vala compiler
 * generated from Player.vala, do not modify */



#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <gst/gst.h>
#include <float.h>
#include <math.h>
#include <gio/gio.h>


#define SERVICES_TYPE_PLAYER (services_player_get_type ())
#define SERVICES_PLAYER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SERVICES_TYPE_PLAYER, ServicesPlayer))
#define SERVICES_PLAYER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SERVICES_TYPE_PLAYER, ServicesPlayerClass))
#define SERVICES_IS_PLAYER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SERVICES_TYPE_PLAYER))
#define SERVICES_IS_PLAYER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SERVICES_TYPE_PLAYER))
#define SERVICES_PLAYER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SERVICES_TYPE_PLAYER, ServicesPlayerClass))

typedef struct _ServicesPlayer ServicesPlayer;
typedef struct _ServicesPlayerClass ServicesPlayerClass;
typedef struct _ServicesPlayerPrivate ServicesPlayerPrivate;

#define OBJECTS_TYPE_TRACK (objects_track_get_type ())
#define OBJECTS_TRACK(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), OBJECTS_TYPE_TRACK, ObjectsTrack))
#define OBJECTS_TRACK_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), OBJECTS_TYPE_TRACK, ObjectsTrackClass))
#define OBJECTS_IS_TRACK(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), OBJECTS_TYPE_TRACK))
#define OBJECTS_IS_TRACK_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), OBJECTS_TYPE_TRACK))
#define OBJECTS_TRACK_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), OBJECTS_TYPE_TRACK, ObjectsTrackClass))

typedef struct _ObjectsTrack ObjectsTrack;
typedef struct _ObjectsTrackClass ObjectsTrackClass;

#define OBJECTS_TYPE_RADIO (objects_radio_get_type ())
#define OBJECTS_RADIO(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), OBJECTS_TYPE_RADIO, ObjectsRadio))
#define OBJECTS_RADIO_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), OBJECTS_TYPE_RADIO, ObjectsRadioClass))
#define OBJECTS_IS_RADIO(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), OBJECTS_TYPE_RADIO))
#define OBJECTS_IS_RADIO_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), OBJECTS_TYPE_RADIO))
#define OBJECTS_RADIO_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), OBJECTS_TYPE_RADIO, ObjectsRadioClass))

typedef struct _ObjectsRadio ObjectsRadio;
typedef struct _ObjectsRadioClass ObjectsRadioClass;
enum  {
	SERVICES_PLAYER_0_PROPERTY,
	SERVICES_PLAYER_CURRENT_TRACK_PROPERTY,
	SERVICES_PLAYER_CURRENT_RADIO_PROPERTY,
	SERVICES_PLAYER_CURRENT_RADIO_TITLE_PROPERTY,
	SERVICES_PLAYER_MODE_PROPERTY,
	SERVICES_PLAYER_PLAYER_STATE_PROPERTY,
	SERVICES_PLAYER_DURATION_PROPERTY,
	SERVICES_PLAYER_POSITION_PROPERTY,
	SERVICES_PLAYER_TARGET_PROGRESS_PROPERTY,
	SERVICES_PLAYER_NUM_PROPERTIES
};
static GParamSpec* services_player_properties[SERVICES_PLAYER_NUM_PROPERTIES];
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))

#define SERVICES_TYPE_SCAN (services_scan_get_type ())
#define SERVICES_SCAN(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SERVICES_TYPE_SCAN, ServicesScan))
#define SERVICES_SCAN_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SERVICES_TYPE_SCAN, ServicesScanClass))
#define SERVICES_IS_SCAN(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SERVICES_TYPE_SCAN))
#define SERVICES_IS_SCAN_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SERVICES_TYPE_SCAN))
#define SERVICES_SCAN_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SERVICES_TYPE_SCAN, ServicesScanClass))

typedef struct _ServicesScan ServicesScan;
typedef struct _ServicesScanClass ServicesScanClass;
typedef struct _ServicesScanPrivate ServicesScanPrivate;

#define SERVICES_TYPE_DATABASE (services_database_get_type ())
#define SERVICES_DATABASE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SERVICES_TYPE_DATABASE, ServicesDatabase))
#define SERVICES_DATABASE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SERVICES_TYPE_DATABASE, ServicesDatabaseClass))
#define SERVICES_IS_DATABASE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SERVICES_TYPE_DATABASE))
#define SERVICES_IS_DATABASE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SERVICES_TYPE_DATABASE))
#define SERVICES_DATABASE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SERVICES_TYPE_DATABASE, ServicesDatabaseClass))

typedef struct _ServicesDatabase ServicesDatabase;
typedef struct _ServicesDatabaseClass ServicesDatabaseClass;
typedef struct _ObjectsTrackPrivate ObjectsTrackPrivate;

#define TYPE_UTILS (utils_get_type ())
#define UTILS(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_UTILS, Utils))
#define UTILS_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_UTILS, UtilsClass))
#define IS_UTILS(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_UTILS))
#define IS_UTILS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_UTILS))
#define UTILS_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_UTILS, UtilsClass))

typedef struct _Utils Utils;
typedef struct _UtilsClass UtilsClass;
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
#define _gst_tag_list_unref0(var) ((var == NULL) ? NULL : (var = (gst_tag_list_unref (var), NULL)))
enum  {
	SERVICES_PLAYER_STATE_CHANGED_SIGNAL,
	SERVICES_PLAYER_MODE_CHANGED_SIGNAL,
	SERVICES_PLAYER_CURRENT_PROGRESS_CHANGED_SIGNAL,
	SERVICES_PLAYER_CURRENT_DURATION_CHANGED_SIGNAL,
	SERVICES_PLAYER_CURRENT_TRACK_CHANGED_SIGNAL,
	SERVICES_PLAYER_CURRENT_RADIO_CHANGED_SIGNAL,
	SERVICES_PLAYER_TOGGLE_PLAYING_SIGNAL,
	SERVICES_PLAYER_CURRENT_RADIO_TITLE_CHANGED_SIGNAL,
	SERVICES_PLAYER_NUM_SIGNALS
};
static guint services_player_signals[SERVICES_PLAYER_NUM_SIGNALS] = {0};

struct _ServicesPlayer {
	GObject parent_instance;
	ServicesPlayerPrivate * priv;
};

struct _ServicesPlayerClass {
	GObjectClass parent_class;
};

struct _ServicesPlayerPrivate {
	guint progress_timer;
	ObjectsTrack* _current_track;
	ObjectsRadio* _current_radio;
	gchar* _current_radio_title;
	gchar* _mode;
	GstState* _player_state;
	GstFormat fmt;
	GstElement* playbin;
	GstBus* bus;
	gdouble _target_progress;
};

struct _ServicesScan {
	GObject parent_instance;
	ServicesScanPrivate * priv;
	gint counter;
	gint counter_max;
	gboolean is_sync;
};

struct _ServicesScanClass {
	GObjectClass parent_class;
};

struct _ObjectsTrack {
	GObject parent_instance;
	ObjectsTrackPrivate * priv;
	gint track_order;
	gint id;
	gint album_id;
	gint track;
	gint disc;
	gint play_count;
	gint is_favorite;
	gint bitrate;
	gint bpm;
	gint rating;
	gint samplerate;
	gint channels;
	gint year;
	gint playlist;
	guint64 duration;
	gchar* path;
	gchar* title;
	gchar* favorite_added;
	gchar* last_played;
	gchar* album_title;
	gchar* artist_name;
	gchar* composer;
	gchar* grouping;
	gchar* comment;
	gchar* lyrics;
	gchar* genre;
	gchar* album_artist;
	gchar* date_added;
};

struct _ObjectsTrackClass {
	GObjectClass parent_class;
};


static gpointer services_player_parent_class = NULL;
extern ServicesScan* byte_scan_service;
extern ServicesDatabase* byte_database;
extern GSettings* byte_settings;
extern Utils* byte_utils;

GType services_player_get_type (void) G_GNUC_CONST;
GType objects_track_get_type (void) G_GNUC_CONST;
GType objects_radio_get_type (void) G_GNUC_CONST;
#define SERVICES_PLAYER_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), SERVICES_TYPE_PLAYER, ServicesPlayerPrivate))
ServicesPlayer* services_player_new (void);
ServicesPlayer* services_player_construct (GType object_type);
static gboolean services_player_bus_callback (ServicesPlayer* self,
                                       GstBus* bus,
                                       GstMessage* message);
static gboolean _services_player_bus_callback_gst_bus_func (GstBus* bus,
                                                     GstMessage* message,
                                                     gpointer self);
static void __lambda7_ (ServicesPlayer* self,
                 GstState state);
void services_player_set_player_state (ServicesPlayer* self,
                                       GstState* value);
void services_player_stop_progress_signal (ServicesPlayer* self,
                                           gboolean reset_timer);
void services_player_start_progress_signal (ServicesPlayer* self);
void services_player_pause_progress_signal (ServicesPlayer* self);
static void ___lambda7__services_player_state_changed (ServicesPlayer* _sender,
                                                GstState state,
                                                gpointer self);
static void __lambda9_ (ServicesPlayer* self,
                 ObjectsTrack* track);
static void services_player_set_current_radio (ServicesPlayer* self,
                                        ObjectsRadio* value);
GType services_scan_get_type (void) G_GNUC_CONST;
GType services_database_get_type (void) G_GNUC_CONST;
void services_database_add_track_count (ServicesDatabase* self,
                                        ObjectsTrack* track);
static void ___lambda9__services_player_current_track_changed (ServicesPlayer* _sender,
                                                        ObjectsTrack* track,
                                                        gpointer self);
static void __lambda18_ (ServicesPlayer* self,
                  ObjectsRadio* radio);
void services_player_set_current_track (ServicesPlayer* self,
                                        ObjectsTrack* value);
static void ___lambda18__services_player_current_radio_changed (ServicesPlayer* _sender,
                                                         ObjectsRadio* radio,
                                                         gpointer self);
void services_player_set_radio (ServicesPlayer* self,
                                ObjectsRadio* radio);
ObjectsRadio* services_player_get_current_radio (ServicesPlayer* self);
const gchar* objects_radio_get_file (ObjectsRadio* self);
void services_player_set_mode (ServicesPlayer* self,
                               const gchar* value);
void services_player_stop (ServicesPlayer* self);
static inline void _dynamic_set_uri0 (GstElement* obj,
                        const gchar* value);
void services_player_play (ServicesPlayer* self);
void services_player_set_track (ServicesPlayer* self,
                                ObjectsTrack* track);
gboolean services_player_load_track (ServicesPlayer* self,
                                     ObjectsTrack* track,
                                     gdouble progress);
ObjectsTrack* services_player_get_current_track (ServicesPlayer* self);
GstState services_player_get_state (ServicesPlayer* self);
static inline void _dynamic_set_uri1 (GstElement* obj,
                        const gchar* value);
gint64 services_player_get_duration (ServicesPlayer* self);
void services_player_pause (ServicesPlayer* self);
void services_player_seek_to_progress (ServicesPlayer* self,
                                       gdouble percent);
void services_player_seek_to_position (ServicesPlayer* self,
                                       gint64 position);
static gint64 services_player_get_position_sec (ServicesPlayer* self);
gint64 services_player_get_position (ServicesPlayer* self);
gdouble services_player_get_position_progress (ServicesPlayer* self);
static gboolean __lambda8_ (ServicesPlayer* self);
static gboolean ___lambda8__gsource_func (gpointer self);
void services_player_next (ServicesPlayer* self);
GType utils_get_type (void) G_GNUC_CONST;
ObjectsTrack* utils_get_next_track (Utils* self,
                                    ObjectsTrack* current_track);
void services_player_prev (ServicesPlayer* self);
ObjectsTrack* utils_get_prev_track (Utils* self,
                                    ObjectsTrack* current_track);
const gchar* services_player_get_mode (ServicesPlayer* self);
void services_player_set_current_radio_title (ServicesPlayer* self,
                                              const gchar* value);
const gchar* services_player_get_current_radio_title (ServicesPlayer* self);
GstState* services_player_get_player_state (ServicesPlayer* self);
static GstState* _gst_state_dup (GstState* self);
gdouble services_player_get_target_progress (ServicesPlayer* self);
void services_player_set_target_progress (ServicesPlayer* self,
                                          gdouble value);
static void g_cclosure_user_marshal_VOID__INT64 (GClosure * closure,
                                          GValue * return_value,
                                          guint n_param_values,
                                          const GValue * param_values,
                                          gpointer invocation_hint,
                                          gpointer marshal_data);
static void services_player_finalize (GObject * obj);
static void _vala_services_player_get_property (GObject * object,
                                         guint property_id,
                                         GValue * value,
                                         GParamSpec * pspec);
static void _vala_services_player_set_property (GObject * object,
                                         guint property_id,
                                         const GValue * value,
                                         GParamSpec * pspec);


static gboolean
_services_player_bus_callback_gst_bus_func (GstBus* bus,
                                            GstMessage* message,
                                            gpointer self)
{
	gboolean result;
	result = services_player_bus_callback ((ServicesPlayer*) self, bus, message);
	return result;
}


static void
__lambda7_ (ServicesPlayer* self,
            GstState state)
{
	services_player_set_player_state (self, &state);
	services_player_stop_progress_signal (self, FALSE);
	if (state != GST_STATE_NULL) {
		GstElement* _tmp0_;
		_tmp0_ = self->priv->playbin;
		gst_element_set_state (_tmp0_, state);
	}
	switch (state) {
		case GST_STATE_PLAYING:
		{
			services_player_start_progress_signal (self);
			break;
		}
		case GST_STATE_READY:
		{
			services_player_stop_progress_signal (self, TRUE);
			break;
		}
		case GST_STATE_PAUSED:
		{
			services_player_pause_progress_signal (self);
			break;
		}
		default:
		break;
	}
}


static void
___lambda7__services_player_state_changed (ServicesPlayer* _sender,
                                           GstState state,
                                           gpointer self)
{
	__lambda7_ ((ServicesPlayer*) self, state);
}


static void
__lambda9_ (ServicesPlayer* self,
            ObjectsTrack* track)
{
	gboolean _tmp0_ = FALSE;
	services_player_set_current_radio (self, NULL);
	if (track != NULL) {
		ServicesScan* _tmp1_;
		gboolean _tmp2_;
		_tmp1_ = byte_scan_service;
		_tmp2_ = _tmp1_->is_sync;
		_tmp0_ = _tmp2_ == FALSE;
	} else {
		_tmp0_ = FALSE;
	}
	if (_tmp0_) {
		ServicesDatabase* _tmp3_;
		_tmp3_ = byte_database;
		services_database_add_track_count (_tmp3_, track);
	}
}


static void
___lambda9__services_player_current_track_changed (ServicesPlayer* _sender,
                                                   ObjectsTrack* track,
                                                   gpointer self)
{
	__lambda9_ ((ServicesPlayer*) self, track);
}


static void
__lambda18_ (ServicesPlayer* self,
             ObjectsRadio* radio)
{
	services_player_set_current_track (self, NULL);
}


static void
___lambda18__services_player_current_radio_changed (ServicesPlayer* _sender,
                                                    ObjectsRadio* radio,
                                                    gpointer self)
{
	__lambda18_ ((ServicesPlayer*) self, radio);
}


ServicesPlayer*
services_player_construct (GType object_type)
{
	ServicesPlayer * self = NULL;
	GstElement* _tmp0_;
	GstElement* _tmp1_;
	GstBus* _tmp2_;
	GstBus* _tmp3_;
	GstBus* _tmp4_;
	self = (ServicesPlayer*) g_object_new (object_type, NULL);
	_tmp0_ = gst_element_factory_make ("playbin", "play");
	if (_tmp0_ != NULL) {
		g_object_ref_sink (_tmp0_);
	}
	_g_object_unref0 (self->priv->playbin);
	self->priv->playbin = _tmp0_;
	_tmp1_ = self->priv->playbin;
	_tmp2_ = gst_element_get_bus (_tmp1_);
	_g_object_unref0 (self->priv->bus);
	self->priv->bus = _tmp2_;
	_tmp3_ = self->priv->bus;
	gst_bus_add_watch_full (_tmp3_, 0, _services_player_bus_callback_gst_bus_func, g_object_ref (self), g_object_unref);
	_tmp4_ = self->priv->bus;
	gst_bus_enable_sync_message_emission (_tmp4_);
	g_signal_connect_object (self, "state-changed", (GCallback) ___lambda7__services_player_state_changed, self, 0);
	g_signal_connect_object (self, "current-track-changed", (GCallback) ___lambda9__services_player_current_track_changed, self, 0);
	g_signal_connect_object (self, "current-radio-changed", (GCallback) ___lambda18__services_player_current_radio_changed, self, 0);
	return self;
}


ServicesPlayer*
services_player_new (void)
{
	return services_player_construct (SERVICES_TYPE_PLAYER);
}


static inline void
_dynamic_set_uri0 (GstElement* obj,
                   const gchar* value)
{
	g_object_set (obj, "uri", value, NULL);
}


void
services_player_set_radio (ServicesPlayer* self,
                           ObjectsRadio* radio)
{
	gboolean _tmp0_ = FALSE;
	gboolean _tmp1_ = FALSE;
	ObjectsRadio* _tmp2_;
	GstElement* _tmp5_;
	const gchar* _tmp6_;
	const gchar* _tmp7_;
	GstElement* _tmp8_;
	GstState _tmp9_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (radio != NULL);
	_tmp2_ = self->priv->_current_radio;
	if (radio == _tmp2_) {
		_tmp1_ = TRUE;
	} else {
		_tmp1_ = radio == NULL;
	}
	if (_tmp1_) {
		_tmp0_ = TRUE;
	} else {
		const gchar* _tmp3_;
		const gchar* _tmp4_;
		_tmp3_ = objects_radio_get_file (radio);
		_tmp4_ = _tmp3_;
		_tmp0_ = _tmp4_ == NULL;
	}
	if (_tmp0_) {
		return;
	}
	g_signal_emit (self, services_player_signals[SERVICES_PLAYER_MODE_CHANGED_SIGNAL], 0, "radio");
	services_player_set_mode (self, "radio");
	g_signal_emit (self, services_player_signals[SERVICES_PLAYER_CURRENT_RADIO_CHANGED_SIGNAL], 0, radio);
	services_player_set_current_radio (self, radio);
	services_player_stop (self);
	_tmp5_ = self->priv->playbin;
	_tmp6_ = objects_radio_get_file (radio);
	_tmp7_ = _tmp6_;
	_dynamic_set_uri0 (_tmp5_, _tmp7_);
	_tmp8_ = self->priv->playbin;
	gst_element_set_state (_tmp8_, GST_STATE_PLAYING);
	g_signal_emit (self, services_player_signals[SERVICES_PLAYER_STATE_CHANGED_SIGNAL], 0, GST_STATE_PLAYING);
	_tmp9_ = GST_STATE_PLAYING;
	services_player_set_player_state (self, &_tmp9_);
	services_player_play (self);
}


void
services_player_set_track (ServicesPlayer* self,
                           ObjectsTrack* track)
{
	g_return_if_fail (self != NULL);
	if (track == NULL) {
		g_signal_emit (self, services_player_signals[SERVICES_PLAYER_CURRENT_DURATION_CHANGED_SIGNAL], 0, (gint64) 0);
	}
	if (services_player_load_track (self, track, (gdouble) 0)) {
		g_signal_emit (self, services_player_signals[SERVICES_PLAYER_CURRENT_TRACK_CHANGED_SIGNAL], 0, track);
		g_signal_emit (self, services_player_signals[SERVICES_PLAYER_MODE_CHANGED_SIGNAL], 0, "track");
		services_player_set_mode (self, "track");
		services_player_play (self);
	}
}


static inline void
_dynamic_set_uri1 (GstElement* obj,
                   const gchar* value)
{
	g_object_set (obj, "uri", value, NULL);
}


gboolean
services_player_load_track (ServicesPlayer* self,
                            ObjectsTrack* track,
                            gdouble progress)
{
	gboolean result = FALSE;
	gboolean _tmp0_ = FALSE;
	ObjectsTrack* _tmp1_;
	GstState last_state = 0;
	GstElement* _tmp2_;
	ObjectsTrack* _tmp3_;
	const gchar* _tmp4_;
	GstElement* _tmp5_;
	GstState _tmp6_;
	GstState _tmp9_;
	gint64 _tmp10_;
	gint64 _tmp11_;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp1_ = self->priv->_current_track;
	if (track == _tmp1_) {
		_tmp0_ = TRUE;
	} else {
		_tmp0_ = track == NULL;
	}
	if (_tmp0_) {
		result = FALSE;
		return result;
	}
	services_player_set_current_track (self, track);
	last_state = services_player_get_state (self);
	services_player_stop (self);
	_tmp2_ = self->priv->playbin;
	_tmp3_ = self->priv->_current_track;
	_tmp4_ = _tmp3_->path;
	_dynamic_set_uri1 (_tmp2_, _tmp4_);
	_tmp5_ = self->priv->playbin;
	gst_element_set_state (_tmp5_, GST_STATE_PLAYING);
	g_signal_emit (self, services_player_signals[SERVICES_PLAYER_STATE_CHANGED_SIGNAL], 0, GST_STATE_PLAYING);
	_tmp6_ = GST_STATE_PLAYING;
	services_player_set_player_state (self, &_tmp6_);
	while (TRUE) {
		gint64 _tmp7_;
		gint64 _tmp8_;
		_tmp7_ = services_player_get_duration (self);
		_tmp8_ = _tmp7_;
		if (!(_tmp8_ == ((gint64) 0))) {
			break;
		}
	}
	_tmp9_ = last_state;
	if (_tmp9_ != GST_STATE_PLAYING) {
		services_player_pause (self);
	}
	_tmp10_ = services_player_get_duration (self);
	_tmp11_ = _tmp10_;
	g_signal_emit (self, services_player_signals[SERVICES_PLAYER_CURRENT_DURATION_CHANGED_SIGNAL], 0, _tmp11_);
	if (progress > ((gdouble) 0)) {
		services_player_seek_to_progress (self, progress);
		g_signal_emit (self, services_player_signals[SERVICES_PLAYER_CURRENT_PROGRESS_CHANGED_SIGNAL], 0, progress);
	}
	result = TRUE;
	return result;
}


void
services_player_seek_to_position (ServicesPlayer* self,
                                  gint64 position)
{
	GstElement* _tmp0_;
	GstFormat _tmp1_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->playbin;
	_tmp1_ = self->priv->fmt;
	gst_element_seek_simple (_tmp0_, _tmp1_, GST_SEEK_FLAG_FLUSH, position);
}


void
services_player_seek_to_progress (ServicesPlayer* self,
                                  gdouble percent)
{
	gint64 _tmp0_;
	gint64 _tmp1_;
	g_return_if_fail (self != NULL);
	_tmp0_ = services_player_get_duration (self);
	_tmp1_ = _tmp0_;
	services_player_seek_to_position (self, (gint64) (percent * _tmp1_));
}


static gint64
services_player_get_position_sec (ServicesPlayer* self)
{
	gint64 result = 0LL;
	gint64 current = 0LL;
	gint64 _tmp0_;
	gint64 _tmp1_;
	gint64 _tmp2_ = 0LL;
	gint64 _tmp3_;
	g_return_val_if_fail (self != NULL, 0LL);
	_tmp0_ = services_player_get_position (self);
	_tmp1_ = _tmp0_;
	current = _tmp1_;
	_tmp3_ = current;
	if (_tmp3_ > ((gint64) 0)) {
		gint64 _tmp4_;
		_tmp4_ = current;
		_tmp2_ = _tmp4_ / GST_SECOND;
	} else {
		_tmp2_ = (gint64) -1;
	}
	result = _tmp2_;
	return result;
}


gdouble
services_player_get_position_progress (ServicesPlayer* self)
{
	gdouble result = 0.0;
	gint64 _tmp0_;
	gint64 _tmp1_;
	gint64 _tmp2_;
	gint64 _tmp3_;
	g_return_val_if_fail (self != NULL, 0.0);
	_tmp0_ = services_player_get_duration (self);
	_tmp1_ = _tmp0_;
	_tmp2_ = services_player_get_position (self);
	_tmp3_ = _tmp2_;
	result = (((gdouble) 1) / _tmp1_) * _tmp3_;
	return result;
}


GstState
services_player_get_state (ServicesPlayer* self)
{
	GstState result = 0;
	GstState state = 0;
	GstState pending = 0;
	GstElement* _tmp0_;
	GstState _tmp1_ = 0;
	GstState _tmp2_ = 0;
	g_return_val_if_fail (self != NULL, 0);
	state = GST_STATE_NULL;
	_tmp0_ = self->priv->playbin;
	gst_element_get_state (_tmp0_, &_tmp1_, &_tmp2_, (GstClockTime) GST_SECOND);
	state = _tmp1_;
	pending = _tmp2_;
	result = state;
	return result;
}


void
services_player_pause_progress_signal (ServicesPlayer* self)
{
	guint _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->progress_timer;
	if (_tmp0_ != ((guint) 0)) {
		guint _tmp1_;
		_tmp1_ = self->priv->progress_timer;
		g_source_remove (_tmp1_);
		self->priv->progress_timer = (guint) 0;
	}
}


void
services_player_stop_progress_signal (ServicesPlayer* self,
                                      gboolean reset_timer)
{
	g_return_if_fail (self != NULL);
	services_player_pause_progress_signal (self);
	if (reset_timer) {
		g_signal_emit (self, services_player_signals[SERVICES_PLAYER_CURRENT_PROGRESS_CHANGED_SIGNAL], 0, (gdouble) 0);
	}
}


static gboolean
__lambda8_ (ServicesPlayer* self)
{
	gboolean result = FALSE;
	g_signal_emit (self, services_player_signals[SERVICES_PLAYER_CURRENT_PROGRESS_CHANGED_SIGNAL], 0, services_player_get_position_progress (self));
	result = TRUE;
	return result;
}


static gboolean
___lambda8__gsource_func (gpointer self)
{
	gboolean result;
	result = __lambda8_ ((ServicesPlayer*) self);
	return result;
}


void
services_player_start_progress_signal (ServicesPlayer* self)
{
	g_return_if_fail (self != NULL);
	services_player_pause_progress_signal (self);
	self->priv->progress_timer = g_timeout_add_full (G_PRIORITY_DEFAULT, (guint) 250, ___lambda8__gsource_func, g_object_ref (self), g_object_unref);
}


void
services_player_play (ServicesPlayer* self)
{
	ObjectsTrack* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->_current_track;
	if (_tmp0_ != NULL) {
		GstState _tmp1_;
		g_signal_emit (self, services_player_signals[SERVICES_PLAYER_STATE_CHANGED_SIGNAL], 0, GST_STATE_PLAYING);
		_tmp1_ = GST_STATE_PLAYING;
		services_player_set_player_state (self, &_tmp1_);
	}
}


void
services_player_pause (ServicesPlayer* self)
{
	GstState _tmp0_;
	g_return_if_fail (self != NULL);
	g_signal_emit (self, services_player_signals[SERVICES_PLAYER_STATE_CHANGED_SIGNAL], 0, GST_STATE_PAUSED);
	_tmp0_ = GST_STATE_PAUSED;
	services_player_set_player_state (self, &_tmp0_);
}


void
services_player_stop (ServicesPlayer* self)
{
	GstState _tmp0_;
	g_return_if_fail (self != NULL);
	g_signal_emit (self, services_player_signals[SERVICES_PLAYER_STATE_CHANGED_SIGNAL], 0, GST_STATE_READY);
	_tmp0_ = GST_STATE_READY;
	services_player_set_player_state (self, &_tmp0_);
}


static gpointer
_g_object_ref0 (gpointer self)
{
	return self ? g_object_ref (self) : NULL;
}


void
services_player_next (ServicesPlayer* self)
{
	ObjectsTrack* _tmp0_;
	ObjectsTrack* next_track = NULL;
	gint repeat_mode = 0;
	GSettings* _tmp1_;
	gint _tmp2_;
	ObjectsTrack* _tmp8_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->_current_track;
	if (_tmp0_ == NULL) {
		return;
	}
	next_track = NULL;
	_tmp1_ = byte_settings;
	repeat_mode = g_settings_get_enum (_tmp1_, "repeat-mode");
	_tmp2_ = repeat_mode;
	if (_tmp2_ == 2) {
		ObjectsTrack* _tmp3_;
		ObjectsTrack* _tmp4_;
		_tmp3_ = self->priv->_current_track;
		_tmp4_ = _g_object_ref0 (_tmp3_);
		_g_object_unref0 (next_track);
		next_track = _tmp4_;
		services_player_set_current_track (self, NULL);
	} else {
		Utils* _tmp5_;
		ObjectsTrack* _tmp6_;
		ObjectsTrack* _tmp7_;
		_tmp5_ = byte_utils;
		_tmp6_ = self->priv->_current_track;
		_tmp7_ = utils_get_next_track (_tmp5_, _tmp6_);
		_g_object_unref0 (next_track);
		next_track = _tmp7_;
	}
	_tmp8_ = next_track;
	if (_tmp8_ != NULL) {
		ObjectsTrack* _tmp9_;
		_tmp9_ = next_track;
		services_player_set_track (self, _tmp9_);
	} else {
		GstState _tmp10_;
		g_signal_emit (self, services_player_signals[SERVICES_PLAYER_STATE_CHANGED_SIGNAL], 0, GST_STATE_NULL);
		_tmp10_ = GST_STATE_NULL;
		services_player_set_player_state (self, &_tmp10_);
	}
	_g_object_unref0 (next_track);
}


void
services_player_prev (ServicesPlayer* self)
{
	ObjectsTrack* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->_current_track;
	if (_tmp0_ == NULL) {
		return;
	}
	if (services_player_get_position_sec (self) < ((gint64) 1)) {
		ObjectsTrack* prev_track = NULL;
		Utils* _tmp1_;
		ObjectsTrack* _tmp2_;
		ObjectsTrack* _tmp3_;
		ObjectsTrack* _tmp4_;
		prev_track = NULL;
		_tmp1_ = byte_utils;
		_tmp2_ = self->priv->_current_track;
		_tmp3_ = utils_get_prev_track (_tmp1_, _tmp2_);
		_g_object_unref0 (prev_track);
		prev_track = _tmp3_;
		_tmp4_ = prev_track;
		if (_tmp4_ != NULL) {
			ObjectsTrack* _tmp5_;
			_tmp5_ = prev_track;
			services_player_set_track (self, _tmp5_);
		}
		_g_object_unref0 (prev_track);
	} else {
		ObjectsTrack* _tmp6_;
		services_player_stop (self);
		services_player_play (self);
		_tmp6_ = self->priv->_current_track;
		g_signal_emit (self, services_player_signals[SERVICES_PLAYER_CURRENT_TRACK_CHANGED_SIGNAL], 0, _tmp6_);
	}
}


static gboolean
services_player_bus_callback (ServicesPlayer* self,
                              GstBus* bus,
                              GstMessage* message)
{
	gboolean result = FALSE;
	GstMessageType _tmp0_;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (bus != NULL, FALSE);
	g_return_val_if_fail (message != NULL, FALSE);
	_tmp0_ = message->type;
	switch (_tmp0_) {
		case GST_MESSAGE_ERROR:
		{
			GError* err = NULL;
			gchar* debug = NULL;
			GError* _tmp1_ = NULL;
			gchar* _tmp2_ = NULL;
			GError* _tmp3_;
			const gchar* _tmp4_;
			const gchar* _tmp5_;
			const gchar* _tmp6_;
			gst_message_parse_error (message, &_tmp1_, &_tmp2_);
			_g_error_free0 (err);
			err = _tmp1_;
			_g_free0 (debug);
			debug = _tmp2_;
			_tmp3_ = err;
			_tmp4_ = _tmp3_->message;
			_tmp5_ = debug;
			g_warning ("Player.vala:281: Error: %s\n%s\n", _tmp4_, _tmp5_);
			_tmp6_ = self->priv->_mode;
			if (g_strcmp0 (_tmp6_, "radio") == 0) {
			} else {
				services_player_next (self);
			}
			_g_free0 (debug);
			_g_error_free0 (err);
			break;
		}
		case GST_MESSAGE_EOS:
		{
			services_player_next (self);
			break;
		}
		case GST_MESSAGE_TAG:
		{
			GstTagList* tag_list = NULL;
			gchar* title = NULL;
			GstTagList* _tmp7_ = NULL;
			GstTagList* _tmp8_;
			gchar* _tmp9_ = NULL;
			const gchar* _tmp10_;
			gboolean _tmp11_ = FALSE;
			const gchar* _tmp12_;
			gst_message_parse_tag (message, &_tmp7_);
			_gst_tag_list_unref0 (tag_list);
			tag_list = _tmp7_;
			_tmp8_ = tag_list;
			gst_tag_list_get_string (_tmp8_, GST_TAG_TITLE, &_tmp9_);
			_g_free0 (title);
			title = _tmp9_;
			_gst_tag_list_unref0 (tag_list);
			tag_list = NULL;
			_tmp10_ = title;
			services_player_set_current_radio_title (self, _tmp10_);
			_tmp12_ = self->priv->_current_radio_title;
			if (_tmp12_ != NULL) {
				const gchar* _tmp13_;
				_tmp13_ = self->priv->_mode;
				_tmp11_ = g_strcmp0 (_tmp13_, "radio") == 0;
			} else {
				_tmp11_ = FALSE;
			}
			if (_tmp11_) {
				const gchar* _tmp14_;
				gchar* _tmp15_;
				gchar* _tmp16_;
				const gchar* _tmp17_;
				_tmp14_ = self->priv->_current_radio_title;
				_tmp15_ = g_strdup_printf ("Radio current title: %s\n", _tmp14_);
				_tmp16_ = _tmp15_;
				g_print ("%s", _tmp16_);
				_g_free0 (_tmp16_);
				_tmp17_ = self->priv->_current_radio_title;
				g_signal_emit (self, services_player_signals[SERVICES_PLAYER_CURRENT_RADIO_TITLE_CHANGED_SIGNAL], 0, _tmp17_);
			}
			_g_free0 (title);
			_gst_tag_list_unref0 (tag_list);
			break;
		}
		default:
		{
			break;
		}
	}
	result = TRUE;
	return result;
}


ObjectsTrack*
services_player_get_current_track (ServicesPlayer* self)
{
	ObjectsTrack* result;
	ObjectsTrack* _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_current_track;
	result = _tmp0_;
	return result;
}


void
services_player_set_current_track (ServicesPlayer* self,
                                   ObjectsTrack* value)
{
	g_return_if_fail (self != NULL);
	if (services_player_get_current_track (self) != value) {
		ObjectsTrack* _tmp0_;
		_tmp0_ = _g_object_ref0 (value);
		_g_object_unref0 (self->priv->_current_track);
		self->priv->_current_track = _tmp0_;
		g_object_notify_by_pspec ((GObject *) self, services_player_properties[SERVICES_PLAYER_CURRENT_TRACK_PROPERTY]);
	}
}


ObjectsRadio*
services_player_get_current_radio (ServicesPlayer* self)
{
	ObjectsRadio* result;
	ObjectsRadio* _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_current_radio;
	result = _tmp0_;
	return result;
}


static void
services_player_set_current_radio (ServicesPlayer* self,
                                   ObjectsRadio* value)
{
	g_return_if_fail (self != NULL);
	if (services_player_get_current_radio (self) != value) {
		ObjectsRadio* _tmp0_;
		_tmp0_ = _g_object_ref0 (value);
		_g_object_unref0 (self->priv->_current_radio);
		self->priv->_current_radio = _tmp0_;
		g_object_notify_by_pspec ((GObject *) self, services_player_properties[SERVICES_PLAYER_CURRENT_RADIO_PROPERTY]);
	}
}


const gchar*
services_player_get_current_radio_title (ServicesPlayer* self)
{
	const gchar* result;
	const gchar* _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_current_radio_title;
	result = _tmp0_;
	return result;
}


void
services_player_set_current_radio_title (ServicesPlayer* self,
                                         const gchar* value)
{
	g_return_if_fail (self != NULL);
	if (g_strcmp0 (value, services_player_get_current_radio_title (self)) != 0) {
		gchar* _tmp0_;
		_tmp0_ = g_strdup (value);
		_g_free0 (self->priv->_current_radio_title);
		self->priv->_current_radio_title = _tmp0_;
		g_object_notify_by_pspec ((GObject *) self, services_player_properties[SERVICES_PLAYER_CURRENT_RADIO_TITLE_PROPERTY]);
	}
}


const gchar*
services_player_get_mode (ServicesPlayer* self)
{
	const gchar* result;
	const gchar* _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_mode;
	result = _tmp0_;
	return result;
}


void
services_player_set_mode (ServicesPlayer* self,
                          const gchar* value)
{
	g_return_if_fail (self != NULL);
	if (g_strcmp0 (value, services_player_get_mode (self)) != 0) {
		gchar* _tmp0_;
		_tmp0_ = g_strdup (value);
		_g_free0 (self->priv->_mode);
		self->priv->_mode = _tmp0_;
		g_object_notify_by_pspec ((GObject *) self, services_player_properties[SERVICES_PLAYER_MODE_PROPERTY]);
	}
}


GstState*
services_player_get_player_state (ServicesPlayer* self)
{
	GstState* result;
	GstState* _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_player_state;
	result = _tmp0_;
	return result;
}


static GstState*
_gst_state_dup (GstState* self)
{
	GstState* dup;
	dup = g_new0 (GstState, 1);
	memcpy (dup, self, sizeof (GstState));
	return dup;
}


static gpointer
__gst_state_dup0 (gpointer self)
{
	return self ? _gst_state_dup (self) : NULL;
}


void
services_player_set_player_state (ServicesPlayer* self,
                                  GstState* value)
{
	g_return_if_fail (self != NULL);
	if (services_player_get_player_state (self) != value) {
		GstState* _tmp0_;
		_tmp0_ = __gst_state_dup0 (value);
		_g_free0 (self->priv->_player_state);
		self->priv->_player_state = _tmp0_;
		g_object_notify_by_pspec ((GObject *) self, services_player_properties[SERVICES_PLAYER_PLAYER_STATE_PROPERTY]);
	}
}


gint64
services_player_get_duration (ServicesPlayer* self)
{
	gint64 result;
	gint64 d = 0LL;
	GstElement* _tmp0_;
	GstFormat _tmp1_;
	gint64 _tmp2_ = 0LL;
	gint64 _tmp3_;
	g_return_val_if_fail (self != NULL, 0LL);
	d = (gint64) 0;
	_tmp0_ = self->priv->playbin;
	_tmp1_ = self->priv->fmt;
	gst_element_query_duration (_tmp0_, _tmp1_, &_tmp2_);
	d = _tmp2_;
	_tmp3_ = d;
	result = _tmp3_;
	return result;
}


gint64
services_player_get_position (ServicesPlayer* self)
{
	gint64 result;
	gint64 d = 0LL;
	GstElement* _tmp0_;
	GstFormat _tmp1_;
	gint64 _tmp2_ = 0LL;
	gint64 _tmp3_;
	g_return_val_if_fail (self != NULL, 0LL);
	d = (gint64) 0;
	_tmp0_ = self->priv->playbin;
	_tmp1_ = self->priv->fmt;
	gst_element_query_position (_tmp0_, _tmp1_, &_tmp2_);
	d = _tmp2_;
	_tmp3_ = d;
	result = _tmp3_;
	return result;
}


gdouble
services_player_get_target_progress (ServicesPlayer* self)
{
	gdouble result;
	gdouble _tmp0_;
	g_return_val_if_fail (self != NULL, 0.0);
	_tmp0_ = self->priv->_target_progress;
	result = _tmp0_;
	return result;
}


void
services_player_set_target_progress (ServicesPlayer* self,
                                     gdouble value)
{
	g_return_if_fail (self != NULL);
	if (services_player_get_target_progress (self) != value) {
		self->priv->_target_progress = value;
		g_object_notify_by_pspec ((GObject *) self, services_player_properties[SERVICES_PLAYER_TARGET_PROGRESS_PROPERTY]);
	}
}


static void
g_cclosure_user_marshal_VOID__INT64 (GClosure * closure,
                                     GValue * return_value,
                                     guint n_param_values,
                                     const GValue * param_values,
                                     gpointer invocation_hint,
                                     gpointer marshal_data)
{
	typedef void (*GMarshalFunc_VOID__INT64) (gpointer data1, gint64 arg_1, gpointer data2);
	register GMarshalFunc_VOID__INT64 callback;
	register GCClosure * cc;
	register gpointer data1;
	register gpointer data2;
	cc = (GCClosure *) closure;
	g_return_if_fail (n_param_values == 2);
	if (G_CCLOSURE_SWAP_DATA (closure)) {
		data1 = closure->data;
		data2 = param_values->data[0].v_pointer;
	} else {
		data1 = param_values->data[0].v_pointer;
		data2 = closure->data;
	}
	callback = (GMarshalFunc_VOID__INT64) (marshal_data ? marshal_data : cc->callback);
	callback (data1, g_value_get_int64 (param_values + 1), data2);
}


static void
services_player_class_init (ServicesPlayerClass * klass)
{
	services_player_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (ServicesPlayerPrivate));
	G_OBJECT_CLASS (klass)->get_property = _vala_services_player_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_services_player_set_property;
	G_OBJECT_CLASS (klass)->finalize = services_player_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), SERVICES_PLAYER_CURRENT_TRACK_PROPERTY, services_player_properties[SERVICES_PLAYER_CURRENT_TRACK_PROPERTY] = g_param_spec_object ("current-track", "current-track", "current-track", OBJECTS_TYPE_TRACK, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), SERVICES_PLAYER_CURRENT_RADIO_PROPERTY, services_player_properties[SERVICES_PLAYER_CURRENT_RADIO_PROPERTY] = g_param_spec_object ("current-radio", "current-radio", "current-radio", OBJECTS_TYPE_RADIO, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), SERVICES_PLAYER_CURRENT_RADIO_TITLE_PROPERTY, services_player_properties[SERVICES_PLAYER_CURRENT_RADIO_TITLE_PROPERTY] = g_param_spec_string ("current-radio-title", "current-radio-title", "current-radio-title", NULL, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), SERVICES_PLAYER_MODE_PROPERTY, services_player_properties[SERVICES_PLAYER_MODE_PROPERTY] = g_param_spec_string ("mode", "mode", "mode", NULL, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), SERVICES_PLAYER_PLAYER_STATE_PROPERTY, services_player_properties[SERVICES_PLAYER_PLAYER_STATE_PROPERTY] = g_param_spec_enum ("player-state", "player-state", "player-state", gst_state_get_type (), 0, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), SERVICES_PLAYER_DURATION_PROPERTY, services_player_properties[SERVICES_PLAYER_DURATION_PROPERTY] = g_param_spec_int64 ("duration", "duration", "duration", G_MININT64, G_MAXINT64, 0, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), SERVICES_PLAYER_POSITION_PROPERTY, services_player_properties[SERVICES_PLAYER_POSITION_PROPERTY] = g_param_spec_int64 ("position", "position", "position", G_MININT64, G_MAXINT64, 0, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), SERVICES_PLAYER_TARGET_PROGRESS_PROPERTY, services_player_properties[SERVICES_PLAYER_TARGET_PROGRESS_PROPERTY] = g_param_spec_double ("target-progress", "target-progress", "target-progress", -G_MAXDOUBLE, G_MAXDOUBLE, (gdouble) 0, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE | G_PARAM_WRITABLE));
	services_player_signals[SERVICES_PLAYER_STATE_CHANGED_SIGNAL] = g_signal_new ("state-changed", SERVICES_TYPE_PLAYER, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__ENUM, G_TYPE_NONE, 1, gst_state_get_type ());
	services_player_signals[SERVICES_PLAYER_MODE_CHANGED_SIGNAL] = g_signal_new ("mode-changed", SERVICES_TYPE_PLAYER, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__STRING, G_TYPE_NONE, 1, G_TYPE_STRING);
	services_player_signals[SERVICES_PLAYER_CURRENT_PROGRESS_CHANGED_SIGNAL] = g_signal_new ("current-progress-changed", SERVICES_TYPE_PLAYER, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__DOUBLE, G_TYPE_NONE, 1, G_TYPE_DOUBLE);
	services_player_signals[SERVICES_PLAYER_CURRENT_DURATION_CHANGED_SIGNAL] = g_signal_new ("current-duration-changed", SERVICES_TYPE_PLAYER, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_user_marshal_VOID__INT64, G_TYPE_NONE, 1, G_TYPE_INT64);
	services_player_signals[SERVICES_PLAYER_CURRENT_TRACK_CHANGED_SIGNAL] = g_signal_new ("current-track-changed", SERVICES_TYPE_PLAYER, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__OBJECT, G_TYPE_NONE, 1, OBJECTS_TYPE_TRACK);
	services_player_signals[SERVICES_PLAYER_CURRENT_RADIO_CHANGED_SIGNAL] = g_signal_new ("current-radio-changed", SERVICES_TYPE_PLAYER, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__OBJECT, G_TYPE_NONE, 1, OBJECTS_TYPE_RADIO);
	services_player_signals[SERVICES_PLAYER_TOGGLE_PLAYING_SIGNAL] = g_signal_new ("toggle-playing", SERVICES_TYPE_PLAYER, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0);
	services_player_signals[SERVICES_PLAYER_CURRENT_RADIO_TITLE_CHANGED_SIGNAL] = g_signal_new ("current-radio-title-changed", SERVICES_TYPE_PLAYER, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__STRING, G_TYPE_NONE, 1, G_TYPE_STRING);
}


static void
services_player_instance_init (ServicesPlayer * self)
{
	self->priv = SERVICES_PLAYER_GET_PRIVATE (self);
	self->priv->progress_timer = (guint) 0;
	self->priv->fmt = GST_FORMAT_TIME;
	self->priv->_target_progress = (gdouble) 0;
}


static void
services_player_finalize (GObject * obj)
{
	ServicesPlayer * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, SERVICES_TYPE_PLAYER, ServicesPlayer);
	_g_object_unref0 (self->priv->_current_track);
	_g_object_unref0 (self->priv->_current_radio);
	_g_free0 (self->priv->_current_radio_title);
	_g_free0 (self->priv->_mode);
	_g_free0 (self->priv->_player_state);
	_g_object_unref0 (self->priv->playbin);
	_g_object_unref0 (self->priv->bus);
	G_OBJECT_CLASS (services_player_parent_class)->finalize (obj);
}


GType
services_player_get_type (void)
{
	static volatile gsize services_player_type_id__volatile = 0;
	if (g_once_init_enter (&services_player_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (ServicesPlayerClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) services_player_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (ServicesPlayer), 0, (GInstanceInitFunc) services_player_instance_init, NULL };
		GType services_player_type_id;
		services_player_type_id = g_type_register_static (G_TYPE_OBJECT, "ServicesPlayer", &g_define_type_info, 0);
		g_once_init_leave (&services_player_type_id__volatile, services_player_type_id);
	}
	return services_player_type_id__volatile;
}


static void
_vala_services_player_get_property (GObject * object,
                                    guint property_id,
                                    GValue * value,
                                    GParamSpec * pspec)
{
	ServicesPlayer * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, SERVICES_TYPE_PLAYER, ServicesPlayer);
	switch (property_id) {
		case SERVICES_PLAYER_CURRENT_TRACK_PROPERTY:
		g_value_set_object (value, services_player_get_current_track (self));
		break;
		case SERVICES_PLAYER_CURRENT_RADIO_PROPERTY:
		g_value_set_object (value, services_player_get_current_radio (self));
		break;
		case SERVICES_PLAYER_CURRENT_RADIO_TITLE_PROPERTY:
		g_value_set_string (value, services_player_get_current_radio_title (self));
		break;
		case SERVICES_PLAYER_MODE_PROPERTY:
		g_value_set_string (value, services_player_get_mode (self));
		break;
		case SERVICES_PLAYER_PLAYER_STATE_PROPERTY:
		g_value_set_enum (value, services_player_get_player_state (self));
		break;
		case SERVICES_PLAYER_DURATION_PROPERTY:
		g_value_set_int64 (value, services_player_get_duration (self));
		break;
		case SERVICES_PLAYER_POSITION_PROPERTY:
		g_value_set_int64 (value, services_player_get_position (self));
		break;
		case SERVICES_PLAYER_TARGET_PROGRESS_PROPERTY:
		g_value_set_double (value, services_player_get_target_progress (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void
_vala_services_player_set_property (GObject * object,
                                    guint property_id,
                                    const GValue * value,
                                    GParamSpec * pspec)
{
	ServicesPlayer * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, SERVICES_TYPE_PLAYER, ServicesPlayer);
	switch (property_id) {
		case SERVICES_PLAYER_CURRENT_TRACK_PROPERTY:
		services_player_set_current_track (self, g_value_get_object (value));
		break;
		case SERVICES_PLAYER_CURRENT_RADIO_PROPERTY:
		services_player_set_current_radio (self, g_value_get_object (value));
		break;
		case SERVICES_PLAYER_CURRENT_RADIO_TITLE_PROPERTY:
		services_player_set_current_radio_title (self, g_value_get_string (value));
		break;
		case SERVICES_PLAYER_MODE_PROPERTY:
		services_player_set_mode (self, g_value_get_string (value));
		break;
		case SERVICES_PLAYER_PLAYER_STATE_PROPERTY:
		services_player_set_player_state (self, g_value_get_enum (value));
		break;
		case SERVICES_PLAYER_TARGET_PROGRESS_PROPERTY:
		services_player_set_target_progress (self, g_value_get_double (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}



