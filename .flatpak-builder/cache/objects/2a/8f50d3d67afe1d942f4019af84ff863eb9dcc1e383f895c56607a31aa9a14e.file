/* Indicator.c generated by valac 0.40.11, the Vala compiler
 * generated from Indicator.vala, do not modify */



#include <glib.h>
#include <glib-object.h>
#include <gio/gio.h>
#include <stdlib.h>
#include <string.h>
#include <gtk/gtk.h>
#include <gst/gst.h>


#define SERVICES_TYPE_INDICATOR (services_indicator_get_type ())
#define SERVICES_INDICATOR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SERVICES_TYPE_INDICATOR, ServicesIndicator))
#define SERVICES_INDICATOR_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SERVICES_TYPE_INDICATOR, ServicesIndicatorClass))
#define SERVICES_IS_INDICATOR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SERVICES_TYPE_INDICATOR))
#define SERVICES_IS_INDICATOR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SERVICES_TYPE_INDICATOR))
#define SERVICES_INDICATOR_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SERVICES_TYPE_INDICATOR, ServicesIndicatorClass))

typedef struct _ServicesIndicator ServicesIndicator;
typedef struct _ServicesIndicatorClass ServicesIndicatorClass;
typedef struct _ServicesIndicatorPrivate ServicesIndicatorPrivate;

#define TYPE_SOUND_INDICATOR_PLAYER (sound_indicator_player_get_type ())
#define SOUND_INDICATOR_PLAYER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_SOUND_INDICATOR_PLAYER, SoundIndicatorPlayer))
#define SOUND_INDICATOR_PLAYER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_SOUND_INDICATOR_PLAYER, SoundIndicatorPlayerClass))
#define IS_SOUND_INDICATOR_PLAYER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_SOUND_INDICATOR_PLAYER))
#define IS_SOUND_INDICATOR_PLAYER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_SOUND_INDICATOR_PLAYER))
#define SOUND_INDICATOR_PLAYER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_SOUND_INDICATOR_PLAYER, SoundIndicatorPlayerClass))

typedef struct _SoundIndicatorPlayer SoundIndicatorPlayer;
typedef struct _SoundIndicatorPlayerClass SoundIndicatorPlayerClass;

#define TYPE_SOUND_INDICATOR_ROOT (sound_indicator_root_get_type ())
#define SOUND_INDICATOR_ROOT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_SOUND_INDICATOR_ROOT, SoundIndicatorRoot))
#define SOUND_INDICATOR_ROOT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_SOUND_INDICATOR_ROOT, SoundIndicatorRootClass))
#define IS_SOUND_INDICATOR_ROOT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_SOUND_INDICATOR_ROOT))
#define IS_SOUND_INDICATOR_ROOT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_SOUND_INDICATOR_ROOT))
#define SOUND_INDICATOR_ROOT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_SOUND_INDICATOR_ROOT, SoundIndicatorRootClass))

typedef struct _SoundIndicatorRoot SoundIndicatorRoot;
typedef struct _SoundIndicatorRootClass SoundIndicatorRootClass;
enum  {
	SERVICES_INDICATOR_0_PROPERTY,
	SERVICES_INDICATOR_NUM_PROPERTIES
};
static GParamSpec* services_indicator_properties[SERVICES_INDICATOR_NUM_PROPERTIES];
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))

#define TYPE_BYTE (byte_get_type ())
#define BYTE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_BYTE, Byte))
#define BYTE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_BYTE, ByteClass))
#define IS_BYTE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_BYTE))
#define IS_BYTE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_BYTE))
#define BYTE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_BYTE, ByteClass))

typedef struct _Byte Byte;
typedef struct _ByteClass ByteClass;
typedef struct _BytePrivate BytePrivate;

#define TYPE_MAIN_WINDOW (main_window_get_type ())
#define MAIN_WINDOW(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_MAIN_WINDOW, MainWindow))
#define MAIN_WINDOW_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_MAIN_WINDOW, MainWindowClass))
#define IS_MAIN_WINDOW(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_MAIN_WINDOW))
#define IS_MAIN_WINDOW_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_MAIN_WINDOW))
#define MAIN_WINDOW_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_MAIN_WINDOW, MainWindowClass))

typedef struct _MainWindow MainWindow;
typedef struct _MainWindowClass MainWindowClass;
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
typedef struct _SoundIndicatorRootPrivate SoundIndicatorRootPrivate;
enum  {
	SOUND_INDICATOR_ROOT_0_PROPERTY,
	SOUND_INDICATOR_ROOT_DESKTOP_ENTRY_PROPERTY,
	SOUND_INDICATOR_ROOT_NUM_PROPERTIES
};
static GParamSpec* sound_indicator_root_properties[SOUND_INDICATOR_ROOT_NUM_PROPERTIES];
#define _g_free0(var) (var = (g_free (var), NULL))
typedef struct _SoundIndicatorPlayerPrivate SoundIndicatorPlayerPrivate;
enum  {
	SOUND_INDICATOR_PLAYER_0_PROPERTY,
	SOUND_INDICATOR_PLAYER_CAN_GO_NEXT_PROPERTY,
	SOUND_INDICATOR_PLAYER_CAN_GO_PREVIOUS_PROPERTY,
	SOUND_INDICATOR_PLAYER_CAN_PLAY_PROPERTY,
	SOUND_INDICATOR_PLAYER_CAN_PAUSE_PROPERTY,
	SOUND_INDICATOR_PLAYER_NUM_PROPERTIES
};
static GParamSpec* sound_indicator_player_properties[SOUND_INDICATOR_PLAYER_NUM_PROPERTIES];

#define SERVICES_TYPE_PLAYER (services_player_get_type ())
#define SERVICES_PLAYER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SERVICES_TYPE_PLAYER, ServicesPlayer))
#define SERVICES_PLAYER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SERVICES_TYPE_PLAYER, ServicesPlayerClass))
#define SERVICES_IS_PLAYER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SERVICES_TYPE_PLAYER))
#define SERVICES_IS_PLAYER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SERVICES_TYPE_PLAYER))
#define SERVICES_PLAYER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SERVICES_TYPE_PLAYER, ServicesPlayerClass))

typedef struct _ServicesPlayer ServicesPlayer;
typedef struct _ServicesPlayerClass ServicesPlayerClass;

#define OBJECTS_TYPE_TRACK (objects_track_get_type ())
#define OBJECTS_TRACK(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), OBJECTS_TYPE_TRACK, ObjectsTrack))
#define OBJECTS_TRACK_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), OBJECTS_TYPE_TRACK, ObjectsTrackClass))
#define OBJECTS_IS_TRACK(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), OBJECTS_TYPE_TRACK))
#define OBJECTS_IS_TRACK_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), OBJECTS_TYPE_TRACK))
#define OBJECTS_TRACK_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), OBJECTS_TYPE_TRACK, ObjectsTrackClass))

typedef struct _ObjectsTrack ObjectsTrack;
typedef struct _ObjectsTrackClass ObjectsTrackClass;
#define _g_variant_unref0(var) ((var == NULL) ? NULL : (var = (g_variant_unref (var), NULL)))

#define TYPE_UTILS (utils_get_type ())
#define UTILS(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_UTILS, Utils))
#define UTILS_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_UTILS, UtilsClass))
#define IS_UTILS(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_UTILS))
#define IS_UTILS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_UTILS))
#define UTILS_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_UTILS, UtilsClass))

typedef struct _Utils Utils;
typedef struct _UtilsClass UtilsClass;
typedef struct _ObjectsTrackPrivate ObjectsTrackPrivate;
#define _g_hash_table_unref0(var) ((var == NULL) ? NULL : (var = (g_hash_table_unref (var), NULL)))

#define OBJECTS_TYPE_RADIO (objects_radio_get_type ())
#define OBJECTS_RADIO(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), OBJECTS_TYPE_RADIO, ObjectsRadio))
#define OBJECTS_RADIO_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), OBJECTS_TYPE_RADIO, ObjectsRadioClass))
#define OBJECTS_IS_RADIO(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), OBJECTS_TYPE_RADIO))
#define OBJECTS_IS_RADIO_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), OBJECTS_TYPE_RADIO))
#define OBJECTS_RADIO_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), OBJECTS_TYPE_RADIO, ObjectsRadioClass))

typedef struct _ObjectsRadio ObjectsRadio;
typedef struct _ObjectsRadioClass ObjectsRadioClass;
#define _g_variant_type_free0(var) ((var == NULL) ? NULL : (var = (g_variant_type_free (var), NULL)))
#define _g_variant_builder_unref0(var) ((var == NULL) ? NULL : (var = (g_variant_builder_unref (var), NULL)))

struct _ServicesIndicator {
	GObject parent_instance;
	ServicesIndicatorPrivate * priv;
};

struct _ServicesIndicatorClass {
	GObjectClass parent_class;
};

struct _ServicesIndicatorPrivate {
	SoundIndicatorPlayer* player;
	SoundIndicatorRoot* root;
	GDBusConnection* conn;
	guint owner_id;
	guint root_id;
	guint player_id;
};

struct _Byte {
	GtkApplication parent_instance;
	BytePrivate * priv;
	MainWindow* main_window;
	gchar** argsv;
	gint argsv_length1;
	gboolean has_entry_focus;
	GSimpleAction* toggle_playing_action;
};

struct _ByteClass {
	GtkApplicationClass parent_class;
};

struct _SoundIndicatorRoot {
	GObject parent_instance;
	SoundIndicatorRootPrivate * priv;
};

struct _SoundIndicatorRootClass {
	GObjectClass parent_class;
};

struct _SoundIndicatorRootPrivate {
	Byte* app;
};

struct _SoundIndicatorPlayer {
	GObject parent_instance;
	SoundIndicatorPlayerPrivate * priv;
};

struct _SoundIndicatorPlayerClass {
	GObjectClass parent_class;
};

struct _SoundIndicatorPlayerPrivate {
	GDBusConnection* connection;
	Byte* app;
};

struct _ObjectsTrack {
	GObject parent_instance;
	ObjectsTrackPrivate * priv;
	gint track_order;
	gint id;
	gint album_id;
	gint track;
	gint disc;
	gint play_count;
	gint is_favorite;
	gint bitrate;
	gint bpm;
	gint rating;
	gint samplerate;
	gint channels;
	gint year;
	gint playlist;
	guint64 duration;
	gchar* path;
	gchar* title;
	gchar* favorite_added;
	gchar* last_played;
	gchar* album_title;
	gchar* artist_name;
	gchar* composer;
	gchar* grouping;
	gchar* comment;
	gchar* lyrics;
	gchar* genre;
	gchar* album_artist;
	gchar* date_added;
};

struct _ObjectsTrackClass {
	GObjectClass parent_class;
};


static gpointer services_indicator_parent_class = NULL;
static gpointer sound_indicator_root_parent_class = NULL;
static gpointer sound_indicator_player_parent_class = NULL;
extern ServicesPlayer* byte_player;
extern Utils* byte_utils;

GType services_indicator_get_type (void) G_GNUC_CONST;
GType sound_indicator_player_get_type (void) G_GNUC_CONST;
guint sound_indicator_player_register_object (void* object,
                                              GDBusConnection* connection,
                                              const gchar* path,
                                              GError** error);
GType sound_indicator_root_get_type (void) G_GNUC_CONST;
guint sound_indicator_root_register_object (void* object,
                                            GDBusConnection* connection,
                                            const gchar* path,
                                            GError** error);
#define SERVICES_INDICATOR_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), SERVICES_TYPE_INDICATOR, ServicesIndicatorPrivate))
void services_indicator_initialize (ServicesIndicator* self);
static void services_indicator_on_bus_acquired (ServicesIndicator* self,
                                         GDBusConnection* connection,
                                         const gchar* name);
static void _services_indicator_on_bus_acquired_gbus_acquired_callback (GDBusConnection* connection,
                                                                 const gchar* name,
                                                                 gpointer self);
static void services_indicator_on_name_acquired (ServicesIndicator* self,
                                          GDBusConnection* connection,
                                          const gchar* name);
static void _services_indicator_on_name_acquired_gbus_name_acquired_callback (GDBusConnection* connection,
                                                                       const gchar* name,
                                                                       gpointer self);
static void services_indicator_on_name_lost (ServicesIndicator* self,
                                      GDBusConnection* connection,
                                      const gchar* name);
static void _services_indicator_on_name_lost_gbus_name_lost_callback (GDBusConnection* connection,
                                                               const gchar* name,
                                                               gpointer self);
GType byte_get_type (void) G_GNUC_CONST;
Byte* byte_get_instance (void);
GType main_window_get_type (void) G_GNUC_CONST;
static void __lambda368_ (ServicesIndicator* self);
static void ___lambda368__gtk_widget_destroy (GtkWidget* _sender,
                                       gpointer self);
SoundIndicatorRoot* sound_indicator_root_new (void);
SoundIndicatorRoot* sound_indicator_root_construct (GType object_type);
SoundIndicatorPlayer* sound_indicator_player_new (GDBusConnection* conn);
SoundIndicatorPlayer* sound_indicator_player_construct (GType object_type,
                                                        GDBusConnection* conn);
ServicesIndicator* services_indicator_new (void);
ServicesIndicator* services_indicator_construct (GType object_type);
static void services_indicator_finalize (GObject * obj);
#define SOUND_INDICATOR_ROOT_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_SOUND_INDICATOR_ROOT, SoundIndicatorRootPrivate))
gchar* sound_indicator_root_get_DesktopEntry (SoundIndicatorRoot* self);
static GObject * sound_indicator_root_constructor (GType type,
                                            guint n_construct_properties,
                                            GObjectConstructParam * construct_properties);
static void sound_indicator_root_finalize (GObject * obj);
static void _vala_sound_indicator_root_get_property (GObject * object,
                                              guint property_id,
                                              GValue * value,
                                              GParamSpec * pspec);
static void sound_indicator_root_dbus_interface_method_call (GDBusConnection* connection,
                                                      const gchar* sender,
                                                      const gchar* object_path,
                                                      const gchar* interface_name,
                                                      const gchar* method_name,
                                                      GVariant* parameters,
                                                      GDBusMethodInvocation* invocation,
                                                      gpointer user_data);
static GVariant* sound_indicator_root_dbus_interface_get_property (GDBusConnection* connection,
                                                            const gchar* sender,
                                                            const gchar* object_path,
                                                            const gchar* interface_name,
                                                            const gchar* property_name,
                                                            GError** error,
                                                            gpointer user_data);
static GVariant* _dbus_sound_indicator_root_get_DesktopEntry (SoundIndicatorRoot* self);
static gboolean sound_indicator_root_dbus_interface_set_property (GDBusConnection* connection,
                                                           const gchar* sender,
                                                           const gchar* object_path,
                                                           const gchar* interface_name,
                                                           const gchar* property_name,
                                                           GVariant* value,
                                                           GError** error,
                                                           gpointer user_data);
static void _sound_indicator_root_unregister_object (gpointer user_data);
#define SOUND_INDICATOR_PLAYER_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_SOUND_INDICATOR_PLAYER, SoundIndicatorPlayerPrivate))
GType services_player_get_type (void) G_GNUC_CONST;
GType objects_track_get_type (void) G_GNUC_CONST;
static void __lambda366_ (SoundIndicatorPlayer* self,
                   ObjectsTrack* track);
GstState* services_player_get_player_state (ServicesPlayer* self);
static gboolean _gst_state_equal (const GstState * s1,
                           const GstState * s2);
static GVariant* _variant_new7 (const gchar* value);
static void _g_free0_ (gpointer var);
static void _g_variant_unref0_ (gpointer var);
GType utils_get_type (void) G_GNUC_CONST;
gchar* utils_get_cover_file (Utils* self,
                             gint track_id);
static GVariant* _variant_new8 (gchar* value);
static GVariant* _variant_new9 (const gchar* value);
static gchar** sound_indicator_player_get_simple_string_array (const gchar* text,
                                                        int* result_length1);
static GVariant* _variant_new10 (gchar** value,
                          gint value_length1);
static void sound_indicator_player_send_properties (SoundIndicatorPlayer* self,
                                             const gchar* property,
                                             GVariant* val);
static GVariant* _variant_new11 (GHashTable* value);
static GVariant* _variant_new12 (const gchar* value);
static GVariant* _variant_new13 (const gchar* value);
static GVariant* _variant_new14 (const gchar* value);
static GVariant* _variant_new15 (const gchar* value);
static GVariant* _variant_new16 (gchar** value,
                          gint value_length1);
static GVariant* _variant_new17 (GHashTable* value);
static void ___lambda366__services_player_current_track_changed (ServicesPlayer* _sender,
                                                          ObjectsTrack* track,
                                                          gpointer self);
static void __lambda367_ (SoundIndicatorPlayer* self,
                   const gchar* title);
const gchar* services_player_get_mode (ServicesPlayer* self);
static GVariant* _variant_new18 (const gchar* value);
GType objects_radio_get_type (void) G_GNUC_CONST;
ObjectsRadio* services_player_get_current_radio (ServicesPlayer* self);
gchar* utils_get_cover_radio_file (Utils* self,
                                   gint radio_id);
gint objects_radio_get_id (ObjectsRadio* self);
static GVariant* _variant_new19 (gchar* value);
const gchar* objects_radio_get_name (ObjectsRadio* self);
static GVariant* _variant_new20 (const gchar* value);
static GVariant* _variant_new21 (gchar** value,
                          gint value_length1);
static GVariant* _variant_new22 (GHashTable* value);
static GVariant* _variant_new23 (const gchar* value);
static GVariant* _variant_new24 (const gchar* value);
static GVariant* _variant_new25 (const gchar* value);
static GVariant* _variant_new26 (const gchar* value);
static GVariant* _variant_new27 (gchar** value,
                          gint value_length1);
static GVariant* _variant_new28 (GHashTable* value);
static void ___lambda367__services_player_current_radio_title_changed (ServicesPlayer* _sender,
                                                                const gchar* title,
                                                                gpointer self);
static void _vala_array_add1 (gchar** * array,
                       int* length,
                       int* size,
                       gchar* value);
void sound_indicator_player_PlayPause (SoundIndicatorPlayer* self,
                                       GError** error);
void sound_indicator_player_Next (SoundIndicatorPlayer* self,
                                  GError** error);
void services_player_next (ServicesPlayer* self);
void sound_indicator_player_Previous (SoundIndicatorPlayer* self,
                                      GError** error);
void services_player_prev (ServicesPlayer* self);
gboolean sound_indicator_player_get_CanGoNext (SoundIndicatorPlayer* self);
gboolean sound_indicator_player_get_CanGoPrevious (SoundIndicatorPlayer* self);
gboolean sound_indicator_player_get_CanPlay (SoundIndicatorPlayer* self);
gboolean sound_indicator_player_get_CanPause (SoundIndicatorPlayer* self);
static void sound_indicator_player_finalize (GObject * obj);
static void _vala_sound_indicator_player_get_property (GObject * object,
                                                guint property_id,
                                                GValue * value,
                                                GParamSpec * pspec);
static void _dbus_sound_indicator_player_PlayPause (SoundIndicatorPlayer* self,
                                             GVariant* _parameters_,
                                             GDBusMethodInvocation* invocation);
static void _dbus_sound_indicator_player_Next (SoundIndicatorPlayer* self,
                                        GVariant* _parameters_,
                                        GDBusMethodInvocation* invocation);
static void _dbus_sound_indicator_player_Previous (SoundIndicatorPlayer* self,
                                            GVariant* _parameters_,
                                            GDBusMethodInvocation* invocation);
static void sound_indicator_player_dbus_interface_method_call (GDBusConnection* connection,
                                                        const gchar* sender,
                                                        const gchar* object_path,
                                                        const gchar* interface_name,
                                                        const gchar* method_name,
                                                        GVariant* parameters,
                                                        GDBusMethodInvocation* invocation,
                                                        gpointer user_data);
static GVariant* sound_indicator_player_dbus_interface_get_property (GDBusConnection* connection,
                                                              const gchar* sender,
                                                              const gchar* object_path,
                                                              const gchar* interface_name,
                                                              const gchar* property_name,
                                                              GError** error,
                                                              gpointer user_data);
static GVariant* _dbus_sound_indicator_player_get_CanGoNext (SoundIndicatorPlayer* self);
static GVariant* _dbus_sound_indicator_player_get_CanGoPrevious (SoundIndicatorPlayer* self);
static GVariant* _dbus_sound_indicator_player_get_CanPlay (SoundIndicatorPlayer* self);
static GVariant* _dbus_sound_indicator_player_get_CanPause (SoundIndicatorPlayer* self);
static gboolean sound_indicator_player_dbus_interface_set_property (GDBusConnection* connection,
                                                             const gchar* sender,
                                                             const gchar* object_path,
                                                             const gchar* interface_name,
                                                             const gchar* property_name,
                                                             GVariant* value,
                                                             GError** error,
                                                             gpointer user_data);
static void _sound_indicator_player_unregister_object (gpointer user_data);
static void _vala_array_destroy (gpointer array,
                          gint array_length,
                          GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array,
                       gint array_length,
                       GDestroyNotify destroy_func);

static const GDBusMethodInfo * const _sound_indicator_root_dbus_method_info[] = {NULL};
static const GDBusSignalInfo * const _sound_indicator_root_dbus_signal_info[] = {NULL};
static const GDBusPropertyInfo _sound_indicator_root_dbus_property_info_DesktopEntry = {-1, "DesktopEntry", "s", G_DBUS_PROPERTY_INFO_FLAGS_READABLE};
static const GDBusPropertyInfo * const _sound_indicator_root_dbus_property_info[] = {&_sound_indicator_root_dbus_property_info_DesktopEntry, NULL};
static const GDBusInterfaceInfo _sound_indicator_root_dbus_interface_info = {-1, "org.mpris.MediaPlayer2", (GDBusMethodInfo **) (&_sound_indicator_root_dbus_method_info), (GDBusSignalInfo **) (&_sound_indicator_root_dbus_signal_info), (GDBusPropertyInfo **) (&_sound_indicator_root_dbus_property_info)};
static const GDBusInterfaceVTable _sound_indicator_root_dbus_interface_vtable = {sound_indicator_root_dbus_interface_method_call, sound_indicator_root_dbus_interface_get_property, sound_indicator_root_dbus_interface_set_property};
static const GDBusArgInfo * const _sound_indicator_player_dbus_arg_info_PlayPause_in[] = {NULL};
static const GDBusArgInfo * const _sound_indicator_player_dbus_arg_info_PlayPause_out[] = {NULL};
static const GDBusMethodInfo _sound_indicator_player_dbus_method_info_PlayPause = {-1, "PlayPause", (GDBusArgInfo **) (&_sound_indicator_player_dbus_arg_info_PlayPause_in), (GDBusArgInfo **) (&_sound_indicator_player_dbus_arg_info_PlayPause_out)};
static const GDBusArgInfo * const _sound_indicator_player_dbus_arg_info_Next_in[] = {NULL};
static const GDBusArgInfo * const _sound_indicator_player_dbus_arg_info_Next_out[] = {NULL};
static const GDBusMethodInfo _sound_indicator_player_dbus_method_info_Next = {-1, "Next", (GDBusArgInfo **) (&_sound_indicator_player_dbus_arg_info_Next_in), (GDBusArgInfo **) (&_sound_indicator_player_dbus_arg_info_Next_out)};
static const GDBusArgInfo * const _sound_indicator_player_dbus_arg_info_Previous_in[] = {NULL};
static const GDBusArgInfo * const _sound_indicator_player_dbus_arg_info_Previous_out[] = {NULL};
static const GDBusMethodInfo _sound_indicator_player_dbus_method_info_Previous = {-1, "Previous", (GDBusArgInfo **) (&_sound_indicator_player_dbus_arg_info_Previous_in), (GDBusArgInfo **) (&_sound_indicator_player_dbus_arg_info_Previous_out)};
static const GDBusMethodInfo * const _sound_indicator_player_dbus_method_info[] = {&_sound_indicator_player_dbus_method_info_PlayPause, &_sound_indicator_player_dbus_method_info_Next, &_sound_indicator_player_dbus_method_info_Previous, NULL};
static const GDBusSignalInfo * const _sound_indicator_player_dbus_signal_info[] = {NULL};
static const GDBusPropertyInfo _sound_indicator_player_dbus_property_info_CanGoNext = {-1, "CanGoNext", "b", G_DBUS_PROPERTY_INFO_FLAGS_READABLE};
static const GDBusPropertyInfo _sound_indicator_player_dbus_property_info_CanGoPrevious = {-1, "CanGoPrevious", "b", G_DBUS_PROPERTY_INFO_FLAGS_READABLE};
static const GDBusPropertyInfo _sound_indicator_player_dbus_property_info_CanPlay = {-1, "CanPlay", "b", G_DBUS_PROPERTY_INFO_FLAGS_READABLE};
static const GDBusPropertyInfo _sound_indicator_player_dbus_property_info_CanPause = {-1, "CanPause", "b", G_DBUS_PROPERTY_INFO_FLAGS_READABLE};
static const GDBusPropertyInfo * const _sound_indicator_player_dbus_property_info[] = {&_sound_indicator_player_dbus_property_info_CanGoNext, &_sound_indicator_player_dbus_property_info_CanGoPrevious, &_sound_indicator_player_dbus_property_info_CanPlay, &_sound_indicator_player_dbus_property_info_CanPause, NULL};
static const GDBusInterfaceInfo _sound_indicator_player_dbus_interface_info = {-1, "org.mpris.MediaPlayer2.Player", (GDBusMethodInfo **) (&_sound_indicator_player_dbus_method_info), (GDBusSignalInfo **) (&_sound_indicator_player_dbus_signal_info), (GDBusPropertyInfo **) (&_sound_indicator_player_dbus_property_info)};
static const GDBusInterfaceVTable _sound_indicator_player_dbus_interface_vtable = {sound_indicator_player_dbus_interface_method_call, sound_indicator_player_dbus_interface_get_property, sound_indicator_player_dbus_interface_set_property};

static void
_services_indicator_on_bus_acquired_gbus_acquired_callback (GDBusConnection* connection,
                                                            const gchar* name,
                                                            gpointer self)
{
	services_indicator_on_bus_acquired ((ServicesIndicator*) self, connection, name);
}


static void
_services_indicator_on_name_acquired_gbus_name_acquired_callback (GDBusConnection* connection,
                                                                  const gchar* name,
                                                                  gpointer self)
{
	services_indicator_on_name_acquired ((ServicesIndicator*) self, connection, name);
}


static void
_services_indicator_on_name_lost_gbus_name_lost_callback (GDBusConnection* connection,
                                                          const gchar* name,
                                                          gpointer self)
{
	services_indicator_on_name_lost ((ServicesIndicator*) self, connection, name);
}


static void
__lambda368_ (ServicesIndicator* self)
{
	GDBusConnection* _tmp0_;
	guint _tmp1_;
	GDBusConnection* _tmp2_;
	guint _tmp3_;
	guint _tmp4_;
	_tmp0_ = self->priv->conn;
	_tmp1_ = self->priv->root_id;
	g_dbus_connection_unregister_object (_tmp0_, _tmp1_);
	_tmp2_ = self->priv->conn;
	_tmp3_ = self->priv->player_id;
	g_dbus_connection_unregister_object (_tmp2_, _tmp3_);
	_tmp4_ = self->priv->owner_id;
	g_bus_unown_name (_tmp4_);
}


static void
___lambda368__gtk_widget_destroy (GtkWidget* _sender,
                                  gpointer self)
{
	__lambda368_ ((ServicesIndicator*) self);
}


void
services_indicator_initialize (ServicesIndicator* self)
{
	guint _tmp0_;
	Byte* _tmp1_;
	Byte* _tmp2_;
	MainWindow* _tmp3_;
	g_return_if_fail (self != NULL);
	self->priv->owner_id = g_bus_own_name_with_closures (G_BUS_TYPE_SESSION, "org.mpris.MediaPlayer2.Byte", G_BUS_NAME_OWNER_FLAGS_NONE, (GClosure*) ((_services_indicator_on_bus_acquired_gbus_acquired_callback == NULL) ? NULL : g_cclosure_new ((GCallback) _services_indicator_on_bus_acquired_gbus_acquired_callback, g_object_ref (self), (GClosureNotify) g_object_unref)), (GClosure*) ((_services_indicator_on_name_acquired_gbus_name_acquired_callback == NULL) ? NULL : g_cclosure_new ((GCallback) _services_indicator_on_name_acquired_gbus_name_acquired_callback, g_object_ref (self), (GClosureNotify) g_object_unref)), (GClosure*) ((_services_indicator_on_name_lost_gbus_name_lost_callback == NULL) ? NULL : g_cclosure_new ((GCallback) _services_indicator_on_name_lost_gbus_name_lost_callback, g_object_ref (self), (GClosureNotify) g_object_unref)));
	_tmp0_ = self->priv->owner_id;
	if (_tmp0_ == ((guint) 0)) {
		g_warning ("Indicator.vala:13: Could not initialize MPRIS session.\n");
	}
	_tmp1_ = byte_get_instance ();
	_tmp2_ = _tmp1_;
	_tmp3_ = _tmp2_->main_window;
	g_signal_connect_object ((GtkWidget*) _tmp3_, "destroy", (GCallback) ___lambda368__gtk_widget_destroy, self, 0);
}


static void
services_indicator_on_bus_acquired (ServicesIndicator* self,
                                    GDBusConnection* connection,
                                    const gchar* name)
{
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (connection != NULL);
	g_return_if_fail (name != NULL);
	self->priv->conn = connection;
	{
		SoundIndicatorRoot* _tmp0_;
		guint _tmp1_ = 0U;
		SoundIndicatorRoot* _tmp2_;
		guint _tmp3_;
		SoundIndicatorPlayer* _tmp4_;
		guint _tmp5_ = 0U;
		SoundIndicatorPlayer* _tmp6_;
		guint _tmp7_;
		_tmp0_ = sound_indicator_root_new ();
		_g_object_unref0 (self->priv->root);
		self->priv->root = _tmp0_;
		_tmp2_ = self->priv->root;
		_tmp3_ = sound_indicator_root_register_object (_tmp2_, connection, "/org/mpris/MediaPlayer2", &_inner_error_);
		_tmp1_ = _tmp3_;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			goto __catch13_g_error;
		}
		self->priv->root_id = _tmp1_;
		_tmp4_ = sound_indicator_player_new (connection);
		_g_object_unref0 (self->priv->player);
		self->priv->player = _tmp4_;
		_tmp6_ = self->priv->player;
		_tmp7_ = sound_indicator_player_register_object (_tmp6_, connection, "/org/mpris/MediaPlayer2", &_inner_error_);
		_tmp5_ = _tmp7_;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			goto __catch13_g_error;
		}
		self->priv->player_id = _tmp5_;
	}
	goto __finally13;
	__catch13_g_error:
	{
		GError* e = NULL;
		GError* _tmp8_;
		const gchar* _tmp9_;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp8_ = e;
		_tmp9_ = _tmp8_->message;
		g_warning ("Indicator.vala:33: could not create MPRIS player: %s\n", _tmp9_);
		_g_error_free0 (e);
	}
	__finally13:
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
}


static void
services_indicator_on_name_acquired (ServicesIndicator* self,
                                     GDBusConnection* connection,
                                     const gchar* name)
{
	g_return_if_fail (self != NULL);
	g_return_if_fail (connection != NULL);
	g_return_if_fail (name != NULL);
}


static void
services_indicator_on_name_lost (ServicesIndicator* self,
                                 GDBusConnection* connection,
                                 const gchar* name)
{
	g_return_if_fail (self != NULL);
	g_return_if_fail (connection != NULL);
	g_return_if_fail (name != NULL);
}


ServicesIndicator*
services_indicator_construct (GType object_type)
{
	ServicesIndicator * self = NULL;
	self = (ServicesIndicator*) g_object_new (object_type, NULL);
	return self;
}


ServicesIndicator*
services_indicator_new (void)
{
	return services_indicator_construct (SERVICES_TYPE_INDICATOR);
}


static void
services_indicator_class_init (ServicesIndicatorClass * klass)
{
	services_indicator_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (ServicesIndicatorPrivate));
	G_OBJECT_CLASS (klass)->finalize = services_indicator_finalize;
}


static void
services_indicator_instance_init (ServicesIndicator * self)
{
	self->priv = SERVICES_INDICATOR_GET_PRIVATE (self);
}


static void
services_indicator_finalize (GObject * obj)
{
	ServicesIndicator * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, SERVICES_TYPE_INDICATOR, ServicesIndicator);
	_g_object_unref0 (self->priv->player);
	_g_object_unref0 (self->priv->root);
	G_OBJECT_CLASS (services_indicator_parent_class)->finalize (obj);
}


GType
services_indicator_get_type (void)
{
	static volatile gsize services_indicator_type_id__volatile = 0;
	if (g_once_init_enter (&services_indicator_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (ServicesIndicatorClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) services_indicator_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (ServicesIndicator), 0, (GInstanceInitFunc) services_indicator_instance_init, NULL };
		GType services_indicator_type_id;
		services_indicator_type_id = g_type_register_static (G_TYPE_OBJECT, "ServicesIndicator", &g_define_type_info, 0);
		g_once_init_leave (&services_indicator_type_id__volatile, services_indicator_type_id);
	}
	return services_indicator_type_id__volatile;
}


SoundIndicatorRoot*
sound_indicator_root_construct (GType object_type)
{
	SoundIndicatorRoot * self = NULL;
	self = (SoundIndicatorRoot*) g_object_new (object_type, NULL);
	return self;
}


SoundIndicatorRoot*
sound_indicator_root_new (void)
{
	return sound_indicator_root_construct (TYPE_SOUND_INDICATOR_ROOT);
}


gchar*
sound_indicator_root_get_DesktopEntry (SoundIndicatorRoot* self)
{
	gchar* result;
	Byte* _tmp0_;
	const gchar* _tmp1_;
	const gchar* _tmp2_;
	gchar* _tmp3_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->app;
	_tmp1_ = g_application_get_application_id ((GApplication*) _tmp0_);
	_tmp2_ = _tmp1_;
	_tmp3_ = g_strdup (_tmp2_);
	result = _tmp3_;
	return result;
}


static gpointer
_g_object_ref0 (gpointer self)
{
	return self ? g_object_ref (self) : NULL;
}


static GObject *
sound_indicator_root_constructor (GType type,
                                  guint n_construct_properties,
                                  GObjectConstructParam * construct_properties)
{
	GObject * obj;
	GObjectClass * parent_class;
	SoundIndicatorRoot * self;
	Byte* _tmp0_;
	Byte* _tmp1_;
	Byte* _tmp2_;
	parent_class = G_OBJECT_CLASS (sound_indicator_root_parent_class);
	obj = parent_class->constructor (type, n_construct_properties, construct_properties);
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_SOUND_INDICATOR_ROOT, SoundIndicatorRoot);
	_tmp0_ = byte_get_instance ();
	_tmp1_ = _tmp0_;
	_tmp2_ = _g_object_ref0 (_tmp1_);
	_g_object_unref0 (self->priv->app);
	self->priv->app = _tmp2_;
	return obj;
}


static void
sound_indicator_root_class_init (SoundIndicatorRootClass * klass)
{
	sound_indicator_root_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (SoundIndicatorRootPrivate));
	G_OBJECT_CLASS (klass)->get_property = _vala_sound_indicator_root_get_property;
	G_OBJECT_CLASS (klass)->constructor = sound_indicator_root_constructor;
	G_OBJECT_CLASS (klass)->finalize = sound_indicator_root_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), SOUND_INDICATOR_ROOT_DESKTOP_ENTRY_PROPERTY, sound_indicator_root_properties[SOUND_INDICATOR_ROOT_DESKTOP_ENTRY_PROPERTY] = g_param_spec_string ("DesktopEntry", "DesktopEntry", "DesktopEntry", NULL, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE));
}


static void
sound_indicator_root_instance_init (SoundIndicatorRoot * self)
{
	self->priv = SOUND_INDICATOR_ROOT_GET_PRIVATE (self);
}


static void
sound_indicator_root_finalize (GObject * obj)
{
	SoundIndicatorRoot * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_SOUND_INDICATOR_ROOT, SoundIndicatorRoot);
	_g_object_unref0 (self->priv->app);
	G_OBJECT_CLASS (sound_indicator_root_parent_class)->finalize (obj);
}


GType
sound_indicator_root_get_type (void)
{
	static volatile gsize sound_indicator_root_type_id__volatile = 0;
	if (g_once_init_enter (&sound_indicator_root_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (SoundIndicatorRootClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) sound_indicator_root_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (SoundIndicatorRoot), 0, (GInstanceInitFunc) sound_indicator_root_instance_init, NULL };
		GType sound_indicator_root_type_id;
		sound_indicator_root_type_id = g_type_register_static (G_TYPE_OBJECT, "SoundIndicatorRoot", &g_define_type_info, 0);
		g_type_set_qdata (sound_indicator_root_type_id, g_quark_from_static_string ("vala-dbus-register-object"), (void*) sound_indicator_root_register_object);
		g_once_init_leave (&sound_indicator_root_type_id__volatile, sound_indicator_root_type_id);
	}
	return sound_indicator_root_type_id__volatile;
}


static void
_vala_sound_indicator_root_get_property (GObject * object,
                                         guint property_id,
                                         GValue * value,
                                         GParamSpec * pspec)
{
	SoundIndicatorRoot * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, TYPE_SOUND_INDICATOR_ROOT, SoundIndicatorRoot);
	switch (property_id) {
		case SOUND_INDICATOR_ROOT_DESKTOP_ENTRY_PROPERTY:
		g_value_take_string (value, sound_indicator_root_get_DesktopEntry (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void
sound_indicator_root_dbus_interface_method_call (GDBusConnection* connection,
                                                 const gchar* sender,
                                                 const gchar* object_path,
                                                 const gchar* interface_name,
                                                 const gchar* method_name,
                                                 GVariant* parameters,
                                                 GDBusMethodInvocation* invocation,
                                                 gpointer user_data)
{
	gpointer* data;
	gpointer object;
	data = user_data;
	object = data[0];
	g_object_unref (invocation);
}


static GVariant*
_dbus_sound_indicator_root_get_DesktopEntry (SoundIndicatorRoot* self)
{
	gchar* result;
	GVariant* _reply;
	result = sound_indicator_root_get_DesktopEntry (self);
	_reply = g_variant_new_string (result);
	_g_free0 (result);
	return _reply;
}


static GVariant*
sound_indicator_root_dbus_interface_get_property (GDBusConnection* connection,
                                                  const gchar* sender,
                                                  const gchar* object_path,
                                                  const gchar* interface_name,
                                                  const gchar* property_name,
                                                  GError** error,
                                                  gpointer user_data)
{
	gpointer* data;
	gpointer object;
	data = user_data;
	object = data[0];
	if (strcmp (property_name, "DesktopEntry") == 0) {
		return _dbus_sound_indicator_root_get_DesktopEntry (object);
	}
	return NULL;
}


static gboolean
sound_indicator_root_dbus_interface_set_property (GDBusConnection* connection,
                                                  const gchar* sender,
                                                  const gchar* object_path,
                                                  const gchar* interface_name,
                                                  const gchar* property_name,
                                                  GVariant* value,
                                                  GError** error,
                                                  gpointer user_data)
{
	gpointer* data;
	gpointer object;
	data = user_data;
	object = data[0];
	return FALSE;
}


guint
sound_indicator_root_register_object (gpointer object,
                                      GDBusConnection* connection,
                                      const gchar* path,
                                      GError** error)
{
	guint result;
	gpointer *data;
	data = g_new (gpointer, 3);
	data[0] = g_object_ref (object);
	data[1] = g_object_ref (connection);
	data[2] = g_strdup (path);
	result = g_dbus_connection_register_object (connection, path, (GDBusInterfaceInfo *) (&_sound_indicator_root_dbus_interface_info), &_sound_indicator_root_dbus_interface_vtable, data, _sound_indicator_root_unregister_object, error);
	if (!result) {
		return 0;
	}
	return result;
}


static void
_sound_indicator_root_unregister_object (gpointer user_data)
{
	gpointer* data;
	data = user_data;
	g_object_unref (data[0]);
	g_object_unref (data[1]);
	g_free (data[2]);
	g_free (data);
}


static gboolean
_gst_state_equal (const GstState * s1,
                  const GstState * s2)
{
	if (s1 == s2) {
		return TRUE;
	}
	if (s1 == NULL) {
		return FALSE;
	}
	if (s2 == NULL) {
		return FALSE;
	}
	return (*s1) == (*s2);
}


static GVariant*
_variant_new7 (const gchar* value)
{
	return g_variant_ref_sink (g_variant_new_string (value));
}


static void
_g_free0_ (gpointer var)
{
	var = (g_free (var), NULL);
}


static void
_g_variant_unref0_ (gpointer var)
{
	(var == NULL) ? NULL : (var = (g_variant_unref (var), NULL));
}


static GVariant*
_variant_new8 (gchar* value)
{
	return g_variant_ref_sink (g_variant_new_string (value));
}


static GVariant*
_variant_new9 (const gchar* value)
{
	return g_variant_ref_sink (g_variant_new_string (value));
}


static GVariant*
_variant_new10 (gchar** value,
                gint value_length1)
{
	gchar** _tmp23_;
	GVariantBuilder _tmp24_;
	int _tmp25_;
	_tmp23_ = value;
	g_variant_builder_init (&_tmp24_, G_VARIANT_TYPE ("as"));
	for (_tmp25_ = 0; _tmp25_ < value_length1; _tmp25_++) {
		g_variant_builder_add_value (&_tmp24_, g_variant_new_string (*_tmp23_));
		_tmp23_++;
	}
	return g_variant_ref_sink (g_variant_builder_end (&_tmp24_));
}


static GVariant*
_variant_new11 (GHashTable* value)
{
	GVariantBuilder _tmp28_;
	GHashTableIter _tmp29_;
	gpointer _tmp30_;
	gpointer _tmp31_;
	g_hash_table_iter_init (&_tmp29_, value);
	g_variant_builder_init (&_tmp28_, G_VARIANT_TYPE ("a{sv}"));
	while (g_hash_table_iter_next (&_tmp29_, &_tmp30_, &_tmp31_)) {
		gchar* _key;
		GVariant* _value;
		_key = (gchar*) _tmp30_;
		_value = (GVariant*) _tmp31_;
		g_variant_builder_add (&_tmp28_, "{?*}", g_variant_new_string (_key), g_variant_new_variant (_value));
	}
	return g_variant_ref_sink (g_variant_builder_end (&_tmp28_));
}


static GVariant*
_variant_new12 (const gchar* value)
{
	return g_variant_ref_sink (g_variant_new_string (value));
}


static GVariant*
_variant_new13 (const gchar* value)
{
	return g_variant_ref_sink (g_variant_new_string (value));
}


static GVariant*
_variant_new14 (const gchar* value)
{
	return g_variant_ref_sink (g_variant_new_string (value));
}


static GVariant*
_variant_new15 (const gchar* value)
{
	return g_variant_ref_sink (g_variant_new_string (value));
}


static GVariant*
_variant_new16 (gchar** value,
                gint value_length1)
{
	gchar** _tmp50_;
	GVariantBuilder _tmp51_;
	int _tmp52_;
	_tmp50_ = value;
	g_variant_builder_init (&_tmp51_, G_VARIANT_TYPE ("as"));
	for (_tmp52_ = 0; _tmp52_ < value_length1; _tmp52_++) {
		g_variant_builder_add_value (&_tmp51_, g_variant_new_string (*_tmp50_));
		_tmp50_++;
	}
	return g_variant_ref_sink (g_variant_builder_end (&_tmp51_));
}


static GVariant*
_variant_new17 (GHashTable* value)
{
	GVariantBuilder _tmp55_;
	GHashTableIter _tmp56_;
	gpointer _tmp57_;
	gpointer _tmp58_;
	g_hash_table_iter_init (&_tmp56_, value);
	g_variant_builder_init (&_tmp55_, G_VARIANT_TYPE ("a{sv}"));
	while (g_hash_table_iter_next (&_tmp56_, &_tmp57_, &_tmp58_)) {
		gchar* _key;
		GVariant* _value;
		_key = (gchar*) _tmp57_;
		_value = (GVariant*) _tmp58_;
		g_variant_builder_add (&_tmp55_, "{?*}", g_variant_new_string (_key), g_variant_new_variant (_value));
	}
	return g_variant_ref_sink (g_variant_builder_end (&_tmp55_));
}


static void
__lambda366_ (SoundIndicatorPlayer* self,
              ObjectsTrack* track)
{
	GVariant* property = NULL;
	ServicesPlayer* _tmp0_;
	GstState* _tmp1_;
	GstState* _tmp2_;
	GstState _tmp3_;
	GVariant* _tmp60_;
	_tmp0_ = byte_player;
	_tmp1_ = services_player_get_player_state (_tmp0_);
	_tmp2_ = _tmp1_;
	_tmp3_ = GST_STATE_PLAYING;
	if (_gst_state_equal (_tmp2_, &_tmp3_) == TRUE) {
		GVariant* _tmp4_;
		GHashTable* metadata = NULL;
		GHashTable* _tmp5_;
		GHashTable* _tmp27_;
		GVariant* _tmp32_;
		_tmp4_ = _variant_new7 ("Playing");
		_g_variant_unref0 (property);
		property = _tmp4_;
		_tmp5_ = g_hash_table_new_full (NULL, NULL, _g_free0_, _g_variant_unref0_);
		metadata = _tmp5_;
		if (track != NULL) {
			GHashTable* _tmp6_;
			gchar* _tmp7_;
			Utils* _tmp8_;
			gint _tmp9_;
			gchar* _tmp10_;
			gchar* _tmp11_;
			GVariant* _tmp12_;
			GHashTable* _tmp13_;
			gchar* _tmp14_;
			const gchar* _tmp15_;
			GVariant* _tmp16_;
			GHashTable* _tmp17_;
			gchar* _tmp18_;
			const gchar* _tmp19_;
			gint _tmp20_ = 0;
			gchar** _tmp21_;
			gchar** _tmp22_;
			gint _tmp22__length1;
			GVariant* _tmp26_;
			_tmp6_ = metadata;
			_tmp7_ = g_strdup ("mpris:artUrl");
			_tmp8_ = byte_utils;
			_tmp9_ = track->id;
			_tmp10_ = utils_get_cover_file (_tmp8_, _tmp9_);
			_tmp11_ = _tmp10_;
			_tmp12_ = _variant_new8 (_tmp11_);
			g_hash_table_insert (_tmp6_, _tmp7_, _tmp12_);
			_g_free0 (_tmp11_);
			_tmp13_ = metadata;
			_tmp14_ = g_strdup ("xesam:title");
			_tmp15_ = track->title;
			_tmp16_ = _variant_new9 (_tmp15_);
			g_hash_table_insert (_tmp13_, _tmp14_, _tmp16_);
			_tmp17_ = metadata;
			_tmp18_ = g_strdup ("xesam:artist");
			_tmp19_ = track->artist_name;
			_tmp21_ = sound_indicator_player_get_simple_string_array (_tmp19_, &_tmp20_);
			_tmp22_ = _tmp21_;
			_tmp22__length1 = _tmp20_;
			_tmp26_ = _variant_new10 (_tmp22_, _tmp20_);
			g_hash_table_insert (_tmp17_, _tmp18_, _tmp26_);
			_tmp22_ = (_vala_array_free (_tmp22_, _tmp22__length1, (GDestroyNotify) g_free), NULL);
		}
		_tmp27_ = metadata;
		_tmp32_ = _variant_new11 (_tmp27_);
		sound_indicator_player_send_properties (self, "Metadata", _tmp32_);
		_g_variant_unref0 (_tmp32_);
		_g_hash_table_unref0 (metadata);
	} else {
		ServicesPlayer* _tmp33_;
		GstState* _tmp34_;
		GstState* _tmp35_;
		GstState _tmp36_;
		_tmp33_ = byte_player;
		_tmp34_ = services_player_get_player_state (_tmp33_);
		_tmp35_ = _tmp34_;
		_tmp36_ = GST_STATE_PAUSED;
		if (_gst_state_equal (_tmp35_, &_tmp36_) == TRUE) {
			GVariant* _tmp37_;
			_tmp37_ = _variant_new12 ("Paused");
			_g_variant_unref0 (property);
			property = _tmp37_;
		} else {
			GVariant* _tmp38_;
			GHashTable* metadata = NULL;
			GHashTable* _tmp39_;
			GHashTable* _tmp40_;
			gchar* _tmp41_;
			GVariant* _tmp42_;
			GHashTable* _tmp43_;
			gchar* _tmp44_;
			GVariant* _tmp45_;
			GHashTable* _tmp46_;
			gchar* _tmp47_;
			gchar** _tmp48_;
			gchar** _tmp49_;
			gint _tmp49__length1;
			GVariant* _tmp53_;
			GHashTable* _tmp54_;
			GVariant* _tmp59_;
			_tmp38_ = _variant_new13 ("Stopped");
			_g_variant_unref0 (property);
			property = _tmp38_;
			_tmp39_ = g_hash_table_new_full (NULL, NULL, _g_free0_, _g_variant_unref0_);
			metadata = _tmp39_;
			_tmp40_ = metadata;
			_tmp41_ = g_strdup ("mpris:artUrl");
			_tmp42_ = _variant_new14 ("");
			g_hash_table_insert (_tmp40_, _tmp41_, _tmp42_);
			_tmp43_ = metadata;
			_tmp44_ = g_strdup ("xesam:title");
			_tmp45_ = _variant_new15 ("");
			g_hash_table_insert (_tmp43_, _tmp44_, _tmp45_);
			_tmp46_ = metadata;
			_tmp47_ = g_strdup ("xesam:artist");
			_tmp48_ = g_new0 (gchar*, 0 + 1);
			_tmp49_ = _tmp48_;
			_tmp49__length1 = 0;
			_tmp53_ = _variant_new16 (_tmp49_, 0);
			g_hash_table_insert (_tmp46_, _tmp47_, _tmp53_);
			_tmp49_ = (_vala_array_free (_tmp49_, _tmp49__length1, (GDestroyNotify) g_free), NULL);
			_tmp54_ = metadata;
			_tmp59_ = _variant_new17 (_tmp54_);
			sound_indicator_player_send_properties (self, "Metadata", _tmp59_);
			_g_variant_unref0 (_tmp59_);
			_g_hash_table_unref0 (metadata);
		}
	}
	_tmp60_ = property;
	sound_indicator_player_send_properties (self, "PlaybackStatus", _tmp60_);
	_g_variant_unref0 (property);
}


static void
___lambda366__services_player_current_track_changed (ServicesPlayer* _sender,
                                                     ObjectsTrack* track,
                                                     gpointer self)
{
	__lambda366_ ((SoundIndicatorPlayer*) self, track);
}


static GVariant*
_variant_new18 (const gchar* value)
{
	return g_variant_ref_sink (g_variant_new_string (value));
}


static GVariant*
_variant_new19 (gchar* value)
{
	return g_variant_ref_sink (g_variant_new_string (value));
}


static GVariant*
_variant_new20 (const gchar* value)
{
	return g_variant_ref_sink (g_variant_new_string (value));
}


static GVariant*
_variant_new21 (gchar** value,
                gint value_length1)
{
	gchar** _tmp36_;
	GVariantBuilder _tmp37_;
	int _tmp38_;
	_tmp36_ = value;
	g_variant_builder_init (&_tmp37_, G_VARIANT_TYPE ("as"));
	for (_tmp38_ = 0; _tmp38_ < value_length1; _tmp38_++) {
		g_variant_builder_add_value (&_tmp37_, g_variant_new_string (*_tmp36_));
		_tmp36_++;
	}
	return g_variant_ref_sink (g_variant_builder_end (&_tmp37_));
}


static GVariant*
_variant_new22 (GHashTable* value)
{
	GVariantBuilder _tmp41_;
	GHashTableIter _tmp42_;
	gpointer _tmp43_;
	gpointer _tmp44_;
	g_hash_table_iter_init (&_tmp42_, value);
	g_variant_builder_init (&_tmp41_, G_VARIANT_TYPE ("a{sv}"));
	while (g_hash_table_iter_next (&_tmp42_, &_tmp43_, &_tmp44_)) {
		gchar* _key;
		GVariant* _value;
		_key = (gchar*) _tmp43_;
		_value = (GVariant*) _tmp44_;
		g_variant_builder_add (&_tmp41_, "{?*}", g_variant_new_string (_key), g_variant_new_variant (_value));
	}
	return g_variant_ref_sink (g_variant_builder_end (&_tmp41_));
}


static GVariant*
_variant_new23 (const gchar* value)
{
	return g_variant_ref_sink (g_variant_new_string (value));
}


static GVariant*
_variant_new24 (const gchar* value)
{
	return g_variant_ref_sink (g_variant_new_string (value));
}


static GVariant*
_variant_new25 (const gchar* value)
{
	return g_variant_ref_sink (g_variant_new_string (value));
}


static GVariant*
_variant_new26 (const gchar* value)
{
	return g_variant_ref_sink (g_variant_new_string (value));
}


static GVariant*
_variant_new27 (gchar** value,
                gint value_length1)
{
	gchar** _tmp63_;
	GVariantBuilder _tmp64_;
	int _tmp65_;
	_tmp63_ = value;
	g_variant_builder_init (&_tmp64_, G_VARIANT_TYPE ("as"));
	for (_tmp65_ = 0; _tmp65_ < value_length1; _tmp65_++) {
		g_variant_builder_add_value (&_tmp64_, g_variant_new_string (*_tmp63_));
		_tmp63_++;
	}
	return g_variant_ref_sink (g_variant_builder_end (&_tmp64_));
}


static GVariant*
_variant_new28 (GHashTable* value)
{
	GVariantBuilder _tmp68_;
	GHashTableIter _tmp69_;
	gpointer _tmp70_;
	gpointer _tmp71_;
	g_hash_table_iter_init (&_tmp69_, value);
	g_variant_builder_init (&_tmp68_, G_VARIANT_TYPE ("a{sv}"));
	while (g_hash_table_iter_next (&_tmp69_, &_tmp70_, &_tmp71_)) {
		gchar* _key;
		GVariant* _value;
		_key = (gchar*) _tmp70_;
		_value = (GVariant*) _tmp71_;
		g_variant_builder_add (&_tmp68_, "{?*}", g_variant_new_string (_key), g_variant_new_variant (_value));
	}
	return g_variant_ref_sink (g_variant_builder_end (&_tmp68_));
}


static void
__lambda367_ (SoundIndicatorPlayer* self,
              const gchar* title)
{
	ServicesPlayer* _tmp0_;
	const gchar* _tmp1_;
	const gchar* _tmp2_;
	_tmp0_ = byte_player;
	_tmp1_ = services_player_get_mode (_tmp0_);
	_tmp2_ = _tmp1_;
	if (g_strcmp0 (_tmp2_, "radio") == 0) {
		GVariant* property = NULL;
		ServicesPlayer* _tmp3_;
		GstState* _tmp4_;
		GstState* _tmp5_;
		GstState _tmp6_;
		GVariant* _tmp73_;
		_tmp3_ = byte_player;
		_tmp4_ = services_player_get_player_state (_tmp3_);
		_tmp5_ = _tmp4_;
		_tmp6_ = GST_STATE_PLAYING;
		if (_gst_state_equal (_tmp5_, &_tmp6_) == TRUE) {
			GVariant* _tmp7_;
			GHashTable* metadata = NULL;
			GHashTable* _tmp8_;
			ServicesPlayer* _tmp9_;
			ObjectsRadio* _tmp10_;
			ObjectsRadio* _tmp11_;
			GHashTable* _tmp40_;
			GVariant* _tmp45_;
			_tmp7_ = _variant_new18 ("Playing");
			_g_variant_unref0 (property);
			property = _tmp7_;
			_tmp8_ = g_hash_table_new_full (NULL, NULL, _g_free0_, _g_variant_unref0_);
			metadata = _tmp8_;
			_tmp9_ = byte_player;
			_tmp10_ = services_player_get_current_radio (_tmp9_);
			_tmp11_ = _tmp10_;
			if (_tmp11_ != NULL) {
				GHashTable* _tmp12_;
				gchar* _tmp13_;
				Utils* _tmp14_;
				ServicesPlayer* _tmp15_;
				ObjectsRadio* _tmp16_;
				ObjectsRadio* _tmp17_;
				gint _tmp18_;
				gint _tmp19_;
				gchar* _tmp20_;
				gchar* _tmp21_;
				GVariant* _tmp22_;
				GHashTable* _tmp23_;
				gchar* _tmp24_;
				ServicesPlayer* _tmp25_;
				ObjectsRadio* _tmp26_;
				ObjectsRadio* _tmp27_;
				const gchar* _tmp28_;
				const gchar* _tmp29_;
				GVariant* _tmp30_;
				GHashTable* _tmp31_;
				gchar* _tmp32_;
				gint _tmp33_ = 0;
				gchar** _tmp34_;
				gchar** _tmp35_;
				gint _tmp35__length1;
				GVariant* _tmp39_;
				_tmp12_ = metadata;
				_tmp13_ = g_strdup ("mpris:artUrl");
				_tmp14_ = byte_utils;
				_tmp15_ = byte_player;
				_tmp16_ = services_player_get_current_radio (_tmp15_);
				_tmp17_ = _tmp16_;
				_tmp18_ = objects_radio_get_id (_tmp17_);
				_tmp19_ = _tmp18_;
				_tmp20_ = utils_get_cover_radio_file (_tmp14_, _tmp19_);
				_tmp21_ = _tmp20_;
				_tmp22_ = _variant_new19 (_tmp21_);
				g_hash_table_insert (_tmp12_, _tmp13_, _tmp22_);
				_g_free0 (_tmp21_);
				_tmp23_ = metadata;
				_tmp24_ = g_strdup ("xesam:title");
				_tmp25_ = byte_player;
				_tmp26_ = services_player_get_current_radio (_tmp25_);
				_tmp27_ = _tmp26_;
				_tmp28_ = objects_radio_get_name (_tmp27_);
				_tmp29_ = _tmp28_;
				_tmp30_ = _variant_new20 (_tmp29_);
				g_hash_table_insert (_tmp23_, _tmp24_, _tmp30_);
				_tmp31_ = metadata;
				_tmp32_ = g_strdup ("xesam:artist");
				_tmp34_ = sound_indicator_player_get_simple_string_array (title, &_tmp33_);
				_tmp35_ = _tmp34_;
				_tmp35__length1 = _tmp33_;
				_tmp39_ = _variant_new21 (_tmp35_, _tmp33_);
				g_hash_table_insert (_tmp31_, _tmp32_, _tmp39_);
				_tmp35_ = (_vala_array_free (_tmp35_, _tmp35__length1, (GDestroyNotify) g_free), NULL);
			}
			_tmp40_ = metadata;
			_tmp45_ = _variant_new22 (_tmp40_);
			sound_indicator_player_send_properties (self, "Metadata", _tmp45_);
			_g_variant_unref0 (_tmp45_);
			_g_hash_table_unref0 (metadata);
		} else {
			ServicesPlayer* _tmp46_;
			GstState* _tmp47_;
			GstState* _tmp48_;
			GstState _tmp49_;
			_tmp46_ = byte_player;
			_tmp47_ = services_player_get_player_state (_tmp46_);
			_tmp48_ = _tmp47_;
			_tmp49_ = GST_STATE_PAUSED;
			if (_gst_state_equal (_tmp48_, &_tmp49_) == TRUE) {
				GVariant* _tmp50_;
				_tmp50_ = _variant_new23 ("Paused");
				_g_variant_unref0 (property);
				property = _tmp50_;
			} else {
				GVariant* _tmp51_;
				GHashTable* metadata = NULL;
				GHashTable* _tmp52_;
				GHashTable* _tmp53_;
				gchar* _tmp54_;
				GVariant* _tmp55_;
				GHashTable* _tmp56_;
				gchar* _tmp57_;
				GVariant* _tmp58_;
				GHashTable* _tmp59_;
				gchar* _tmp60_;
				gchar** _tmp61_;
				gchar** _tmp62_;
				gint _tmp62__length1;
				GVariant* _tmp66_;
				GHashTable* _tmp67_;
				GVariant* _tmp72_;
				_tmp51_ = _variant_new24 ("Stopped");
				_g_variant_unref0 (property);
				property = _tmp51_;
				_tmp52_ = g_hash_table_new_full (NULL, NULL, _g_free0_, _g_variant_unref0_);
				metadata = _tmp52_;
				_tmp53_ = metadata;
				_tmp54_ = g_strdup ("mpris:artUrl");
				_tmp55_ = _variant_new25 ("");
				g_hash_table_insert (_tmp53_, _tmp54_, _tmp55_);
				_tmp56_ = metadata;
				_tmp57_ = g_strdup ("xesam:title");
				_tmp58_ = _variant_new26 ("");
				g_hash_table_insert (_tmp56_, _tmp57_, _tmp58_);
				_tmp59_ = metadata;
				_tmp60_ = g_strdup ("xesam:artist");
				_tmp61_ = g_new0 (gchar*, 0 + 1);
				_tmp62_ = _tmp61_;
				_tmp62__length1 = 0;
				_tmp66_ = _variant_new27 (_tmp62_, 0);
				g_hash_table_insert (_tmp59_, _tmp60_, _tmp66_);
				_tmp62_ = (_vala_array_free (_tmp62_, _tmp62__length1, (GDestroyNotify) g_free), NULL);
				_tmp67_ = metadata;
				_tmp72_ = _variant_new28 (_tmp67_);
				sound_indicator_player_send_properties (self, "Metadata", _tmp72_);
				_g_variant_unref0 (_tmp72_);
				_g_hash_table_unref0 (metadata);
			}
		}
		_tmp73_ = property;
		sound_indicator_player_send_properties (self, "PlaybackStatus", _tmp73_);
		_g_variant_unref0 (property);
	}
}


static void
___lambda367__services_player_current_radio_title_changed (ServicesPlayer* _sender,
                                                           const gchar* title,
                                                           gpointer self)
{
	__lambda367_ ((SoundIndicatorPlayer*) self, title);
}


SoundIndicatorPlayer*
sound_indicator_player_construct (GType object_type,
                                  GDBusConnection* conn)
{
	SoundIndicatorPlayer * self = NULL;
	Byte* _tmp0_;
	Byte* _tmp1_;
	Byte* _tmp2_;
	GDBusConnection* _tmp3_;
	ServicesPlayer* _tmp4_;
	ServicesPlayer* _tmp5_;
	g_return_val_if_fail (conn != NULL, NULL);
	self = (SoundIndicatorPlayer*) g_object_new (object_type, NULL);
	_tmp0_ = byte_get_instance ();
	_tmp1_ = _tmp0_;
	_tmp2_ = _g_object_ref0 (_tmp1_);
	_g_object_unref0 (self->priv->app);
	self->priv->app = _tmp2_;
	_tmp3_ = _g_object_ref0 (conn);
	_g_object_unref0 (self->priv->connection);
	self->priv->connection = _tmp3_;
	_tmp4_ = byte_player;
	g_signal_connect_object (_tmp4_, "current-track-changed", (GCallback) ___lambda366__services_player_current_track_changed, self, G_CONNECT_AFTER);
	_tmp5_ = byte_player;
	g_signal_connect_object (_tmp5_, "current-radio-title-changed", (GCallback) ___lambda367__services_player_current_radio_title_changed, self, 0);
	return self;
}


SoundIndicatorPlayer*
sound_indicator_player_new (GDBusConnection* conn)
{
	return sound_indicator_player_construct (TYPE_SOUND_INDICATOR_PLAYER, conn);
}


static void
_vala_array_add1 (gchar** * array,
                  int* length,
                  int* size,
                  gchar* value)
{
	if ((*length) == (*size)) {
		*size = (*size) ? (2 * (*size)) : 4;
		*array = g_renew (gchar*, *array, (*size) + 1);
	}
	(*array)[(*length)++] = value;
	(*array)[*length] = NULL;
}


static gchar**
sound_indicator_player_get_simple_string_array (const gchar* text,
                                                int* result_length1)
{
	gchar** result = NULL;
	gchar** array = NULL;
	gchar** _tmp0_;
	gint array_length1;
	gint _array_size_;
	gchar** _tmp1_;
	gint _tmp1__length1;
	gchar* _tmp2_;
	gchar** _tmp3_;
	gint _tmp3__length1;
	g_return_val_if_fail (text != NULL, NULL);
	_tmp0_ = g_new0 (gchar*, 0 + 1);
	array = _tmp0_;
	array_length1 = 0;
	_array_size_ = array_length1;
	_tmp1_ = array;
	_tmp1__length1 = array_length1;
	_tmp2_ = g_strdup (text);
	_vala_array_add1 (&array, &array_length1, &_array_size_, _tmp2_);
	_tmp3_ = array;
	_tmp3__length1 = array_length1;
	if (result_length1) {
		*result_length1 = _tmp3__length1;
	}
	result = _tmp3_;
	return result;
}


static gpointer
_g_variant_ref0 (gpointer self)
{
	return self ? g_variant_ref (self) : NULL;
}


static void
sound_indicator_player_send_properties (SoundIndicatorPlayer* self,
                                        const gchar* property,
                                        GVariant* val)
{
	GHashTable* property_list = NULL;
	GHashFunc _tmp0_;
	GEqualFunc _tmp1_;
	GHashTable* _tmp2_;
	GHashTable* _tmp3_;
	gchar* _tmp4_;
	GVariant* _tmp5_;
	GVariantBuilder* builder = NULL;
	const GVariantType* _tmp6_;
	GVariantBuilder* _tmp7_;
	GVariantBuilder* invalidated_builder = NULL;
	GVariantType* _tmp8_;
	GVariantType* _tmp9_;
	GVariantBuilder* _tmp10_;
	GVariantBuilder* _tmp11_;
	GHashTable* _tmp12_;
	GList* _tmp13_;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (property != NULL);
	g_return_if_fail (val != NULL);
	_tmp0_ = g_str_hash;
	_tmp1_ = g_str_equal;
	_tmp2_ = g_hash_table_new_full (_tmp0_, _tmp1_, _g_free0_, _g_variant_unref0_);
	property_list = _tmp2_;
	_tmp3_ = property_list;
	_tmp4_ = g_strdup (property);
	_tmp5_ = _g_variant_ref0 (val);
	g_hash_table_insert (_tmp3_, _tmp4_, _tmp5_);
	_tmp6_ = G_VARIANT_TYPE_ARRAY;
	_tmp7_ = g_variant_builder_new (_tmp6_);
	builder = _tmp7_;
	_tmp8_ = g_variant_type_new ("as");
	_tmp9_ = _tmp8_;
	_tmp10_ = g_variant_builder_new (_tmp9_);
	_tmp11_ = _tmp10_;
	_g_variant_type_free0 (_tmp9_);
	invalidated_builder = _tmp11_;
	_tmp12_ = property_list;
	_tmp13_ = g_hash_table_get_keys (_tmp12_);
	{
		GList* name_collection = NULL;
		GList* name_it = NULL;
		name_collection = _tmp13_;
		for (name_it = name_collection; name_it != NULL; name_it = name_it->next) {
			gchar* _tmp14_;
			gchar* name = NULL;
			_tmp14_ = g_strdup ((const gchar*) name_it->data);
			name = _tmp14_;
			{
				GVariant* variant = NULL;
				GHashTable* _tmp15_;
				const gchar* _tmp16_;
				gconstpointer _tmp17_;
				GVariant* _tmp18_;
				GVariantBuilder* _tmp19_;
				const gchar* _tmp20_;
				GVariant* _tmp21_;
				_tmp15_ = property_list;
				_tmp16_ = name;
				_tmp17_ = g_hash_table_lookup (_tmp15_, _tmp16_);
				_tmp18_ = _g_variant_ref0 ((GVariant*) _tmp17_);
				variant = _tmp18_;
				_tmp19_ = builder;
				_tmp20_ = name;
				_tmp21_ = variant;
				g_variant_builder_add (_tmp19_, "{sv}", _tmp20_, _tmp21_, NULL);
				_g_variant_unref0 (variant);
				_g_free0 (name);
			}
		}
		(name_collection == NULL) ? NULL : (name_collection = (g_list_free (name_collection), NULL));
	}
	{
		GDBusConnection* _tmp22_;
		GVariantBuilder* _tmp23_;
		GVariantBuilder* _tmp24_;
		GVariant* _tmp25_;
		GVariant* _tmp26_;
		_tmp22_ = self->priv->connection;
		_tmp23_ = builder;
		_tmp24_ = invalidated_builder;
		_tmp25_ = g_variant_new ("(sa{sv}as)", "org.mpris.MediaPlayer2.Player", _tmp23_, _tmp24_, NULL);
		g_variant_ref_sink (_tmp25_);
		_tmp26_ = _tmp25_;
		g_dbus_connection_emit_signal (_tmp22_, NULL, "/org/mpris/MediaPlayer2", "org.freedesktop.DBus.Properties", "PropertiesChanged", _tmp26_, &_inner_error_);
		_g_variant_unref0 (_tmp26_);
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			goto __catch14_g_error;
		}
	}
	goto __finally14;
	__catch14_g_error:
	{
		GError* e = NULL;
		GError* _tmp27_;
		const gchar* _tmp28_;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp27_ = e;
		_tmp28_ = _tmp27_->message;
		g_print ("Could not send MPRIS property change: %s\n", _tmp28_);
		_g_error_free0 (e);
	}
	__finally14:
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		_g_variant_builder_unref0 (invalidated_builder);
		_g_variant_builder_unref0 (builder);
		_g_hash_table_unref0 (property_list);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	_g_variant_builder_unref0 (invalidated_builder);
	_g_variant_builder_unref0 (builder);
	_g_hash_table_unref0 (property_list);
}


void
sound_indicator_player_PlayPause (SoundIndicatorPlayer* self,
                                  GError** error)
{
	ServicesPlayer* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = byte_player;
	g_signal_emit_by_name (_tmp0_, "toggle-playing");
}


void
sound_indicator_player_Next (SoundIndicatorPlayer* self,
                             GError** error)
{
	ServicesPlayer* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = byte_player;
	services_player_next (_tmp0_);
}


void
sound_indicator_player_Previous (SoundIndicatorPlayer* self,
                                 GError** error)
{
	ServicesPlayer* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = byte_player;
	services_player_prev (_tmp0_);
}


gboolean
sound_indicator_player_get_CanGoNext (SoundIndicatorPlayer* self)
{
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	result = TRUE;
	return result;
}


gboolean
sound_indicator_player_get_CanGoPrevious (SoundIndicatorPlayer* self)
{
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	result = TRUE;
	return result;
}


gboolean
sound_indicator_player_get_CanPlay (SoundIndicatorPlayer* self)
{
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	result = TRUE;
	return result;
}


gboolean
sound_indicator_player_get_CanPause (SoundIndicatorPlayer* self)
{
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	result = TRUE;
	return result;
}


static void
sound_indicator_player_class_init (SoundIndicatorPlayerClass * klass)
{
	sound_indicator_player_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (SoundIndicatorPlayerPrivate));
	G_OBJECT_CLASS (klass)->get_property = _vala_sound_indicator_player_get_property;
	G_OBJECT_CLASS (klass)->finalize = sound_indicator_player_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), SOUND_INDICATOR_PLAYER_CAN_GO_NEXT_PROPERTY, sound_indicator_player_properties[SOUND_INDICATOR_PLAYER_CAN_GO_NEXT_PROPERTY] = g_param_spec_boolean ("CanGoNext", "CanGoNext", "CanGoNext", FALSE, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), SOUND_INDICATOR_PLAYER_CAN_GO_PREVIOUS_PROPERTY, sound_indicator_player_properties[SOUND_INDICATOR_PLAYER_CAN_GO_PREVIOUS_PROPERTY] = g_param_spec_boolean ("CanGoPrevious", "CanGoPrevious", "CanGoPrevious", FALSE, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), SOUND_INDICATOR_PLAYER_CAN_PLAY_PROPERTY, sound_indicator_player_properties[SOUND_INDICATOR_PLAYER_CAN_PLAY_PROPERTY] = g_param_spec_boolean ("CanPlay", "CanPlay", "CanPlay", FALSE, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), SOUND_INDICATOR_PLAYER_CAN_PAUSE_PROPERTY, sound_indicator_player_properties[SOUND_INDICATOR_PLAYER_CAN_PAUSE_PROPERTY] = g_param_spec_boolean ("CanPause", "CanPause", "CanPause", FALSE, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE));
}


static void
sound_indicator_player_instance_init (SoundIndicatorPlayer * self)
{
	self->priv = SOUND_INDICATOR_PLAYER_GET_PRIVATE (self);
}


static void
sound_indicator_player_finalize (GObject * obj)
{
	SoundIndicatorPlayer * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_SOUND_INDICATOR_PLAYER, SoundIndicatorPlayer);
	_g_object_unref0 (self->priv->connection);
	_g_object_unref0 (self->priv->app);
	G_OBJECT_CLASS (sound_indicator_player_parent_class)->finalize (obj);
}


GType
sound_indicator_player_get_type (void)
{
	static volatile gsize sound_indicator_player_type_id__volatile = 0;
	if (g_once_init_enter (&sound_indicator_player_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (SoundIndicatorPlayerClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) sound_indicator_player_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (SoundIndicatorPlayer), 0, (GInstanceInitFunc) sound_indicator_player_instance_init, NULL };
		GType sound_indicator_player_type_id;
		sound_indicator_player_type_id = g_type_register_static (G_TYPE_OBJECT, "SoundIndicatorPlayer", &g_define_type_info, 0);
		g_type_set_qdata (sound_indicator_player_type_id, g_quark_from_static_string ("vala-dbus-register-object"), (void*) sound_indicator_player_register_object);
		g_once_init_leave (&sound_indicator_player_type_id__volatile, sound_indicator_player_type_id);
	}
	return sound_indicator_player_type_id__volatile;
}


static void
_vala_sound_indicator_player_get_property (GObject * object,
                                           guint property_id,
                                           GValue * value,
                                           GParamSpec * pspec)
{
	SoundIndicatorPlayer * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, TYPE_SOUND_INDICATOR_PLAYER, SoundIndicatorPlayer);
	switch (property_id) {
		case SOUND_INDICATOR_PLAYER_CAN_GO_NEXT_PROPERTY:
		g_value_set_boolean (value, sound_indicator_player_get_CanGoNext (self));
		break;
		case SOUND_INDICATOR_PLAYER_CAN_GO_PREVIOUS_PROPERTY:
		g_value_set_boolean (value, sound_indicator_player_get_CanGoPrevious (self));
		break;
		case SOUND_INDICATOR_PLAYER_CAN_PLAY_PROPERTY:
		g_value_set_boolean (value, sound_indicator_player_get_CanPlay (self));
		break;
		case SOUND_INDICATOR_PLAYER_CAN_PAUSE_PROPERTY:
		g_value_set_boolean (value, sound_indicator_player_get_CanPause (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void
_dbus_sound_indicator_player_PlayPause (SoundIndicatorPlayer* self,
                                        GVariant* _parameters_,
                                        GDBusMethodInvocation* invocation)
{
	GError* error = NULL;
	GVariantIter _arguments_iter;
	GDBusMessage* _reply_message = NULL;
	GVariant* _reply;
	GVariantBuilder _reply_builder;
	g_variant_iter_init (&_arguments_iter, _parameters_);
	sound_indicator_player_PlayPause (self, &error);
	if (error) {
		g_dbus_method_invocation_return_gerror (invocation, error);
		g_error_free (error);
		return;
	}
	_reply_message = g_dbus_message_new_method_reply (g_dbus_method_invocation_get_message (invocation));
	g_variant_builder_init (&_reply_builder, G_VARIANT_TYPE_TUPLE);
	_reply = g_variant_builder_end (&_reply_builder);
	g_dbus_message_set_body (_reply_message, _reply);
	g_dbus_connection_send_message (g_dbus_method_invocation_get_connection (invocation), _reply_message, G_DBUS_SEND_MESSAGE_FLAGS_NONE, NULL, NULL);
	g_object_unref (invocation);
	g_object_unref (_reply_message);
}


static void
_dbus_sound_indicator_player_Next (SoundIndicatorPlayer* self,
                                   GVariant* _parameters_,
                                   GDBusMethodInvocation* invocation)
{
	GError* error = NULL;
	GVariantIter _arguments_iter;
	GDBusMessage* _reply_message = NULL;
	GVariant* _reply;
	GVariantBuilder _reply_builder;
	g_variant_iter_init (&_arguments_iter, _parameters_);
	sound_indicator_player_Next (self, &error);
	if (error) {
		g_dbus_method_invocation_return_gerror (invocation, error);
		g_error_free (error);
		return;
	}
	_reply_message = g_dbus_message_new_method_reply (g_dbus_method_invocation_get_message (invocation));
	g_variant_builder_init (&_reply_builder, G_VARIANT_TYPE_TUPLE);
	_reply = g_variant_builder_end (&_reply_builder);
	g_dbus_message_set_body (_reply_message, _reply);
	g_dbus_connection_send_message (g_dbus_method_invocation_get_connection (invocation), _reply_message, G_DBUS_SEND_MESSAGE_FLAGS_NONE, NULL, NULL);
	g_object_unref (invocation);
	g_object_unref (_reply_message);
}


static void
_dbus_sound_indicator_player_Previous (SoundIndicatorPlayer* self,
                                       GVariant* _parameters_,
                                       GDBusMethodInvocation* invocation)
{
	GError* error = NULL;
	GVariantIter _arguments_iter;
	GDBusMessage* _reply_message = NULL;
	GVariant* _reply;
	GVariantBuilder _reply_builder;
	g_variant_iter_init (&_arguments_iter, _parameters_);
	sound_indicator_player_Previous (self, &error);
	if (error) {
		g_dbus_method_invocation_return_gerror (invocation, error);
		g_error_free (error);
		return;
	}
	_reply_message = g_dbus_message_new_method_reply (g_dbus_method_invocation_get_message (invocation));
	g_variant_builder_init (&_reply_builder, G_VARIANT_TYPE_TUPLE);
	_reply = g_variant_builder_end (&_reply_builder);
	g_dbus_message_set_body (_reply_message, _reply);
	g_dbus_connection_send_message (g_dbus_method_invocation_get_connection (invocation), _reply_message, G_DBUS_SEND_MESSAGE_FLAGS_NONE, NULL, NULL);
	g_object_unref (invocation);
	g_object_unref (_reply_message);
}


static void
sound_indicator_player_dbus_interface_method_call (GDBusConnection* connection,
                                                   const gchar* sender,
                                                   const gchar* object_path,
                                                   const gchar* interface_name,
                                                   const gchar* method_name,
                                                   GVariant* parameters,
                                                   GDBusMethodInvocation* invocation,
                                                   gpointer user_data)
{
	gpointer* data;
	gpointer object;
	data = user_data;
	object = data[0];
	if (strcmp (method_name, "PlayPause") == 0) {
		_dbus_sound_indicator_player_PlayPause (object, parameters, invocation);
	} else if (strcmp (method_name, "Next") == 0) {
		_dbus_sound_indicator_player_Next (object, parameters, invocation);
	} else if (strcmp (method_name, "Previous") == 0) {
		_dbus_sound_indicator_player_Previous (object, parameters, invocation);
	} else {
		g_object_unref (invocation);
	}
}


static GVariant*
_dbus_sound_indicator_player_get_CanGoNext (SoundIndicatorPlayer* self)
{
	gboolean result;
	GVariant* _reply;
	result = sound_indicator_player_get_CanGoNext (self);
	_reply = g_variant_new_boolean (result);
	return _reply;
}


static GVariant*
_dbus_sound_indicator_player_get_CanGoPrevious (SoundIndicatorPlayer* self)
{
	gboolean result;
	GVariant* _reply;
	result = sound_indicator_player_get_CanGoPrevious (self);
	_reply = g_variant_new_boolean (result);
	return _reply;
}


static GVariant*
_dbus_sound_indicator_player_get_CanPlay (SoundIndicatorPlayer* self)
{
	gboolean result;
	GVariant* _reply;
	result = sound_indicator_player_get_CanPlay (self);
	_reply = g_variant_new_boolean (result);
	return _reply;
}


static GVariant*
_dbus_sound_indicator_player_get_CanPause (SoundIndicatorPlayer* self)
{
	gboolean result;
	GVariant* _reply;
	result = sound_indicator_player_get_CanPause (self);
	_reply = g_variant_new_boolean (result);
	return _reply;
}


static GVariant*
sound_indicator_player_dbus_interface_get_property (GDBusConnection* connection,
                                                    const gchar* sender,
                                                    const gchar* object_path,
                                                    const gchar* interface_name,
                                                    const gchar* property_name,
                                                    GError** error,
                                                    gpointer user_data)
{
	gpointer* data;
	gpointer object;
	data = user_data;
	object = data[0];
	if (strcmp (property_name, "CanGoNext") == 0) {
		return _dbus_sound_indicator_player_get_CanGoNext (object);
	} else if (strcmp (property_name, "CanGoPrevious") == 0) {
		return _dbus_sound_indicator_player_get_CanGoPrevious (object);
	} else if (strcmp (property_name, "CanPlay") == 0) {
		return _dbus_sound_indicator_player_get_CanPlay (object);
	} else if (strcmp (property_name, "CanPause") == 0) {
		return _dbus_sound_indicator_player_get_CanPause (object);
	}
	return NULL;
}


static gboolean
sound_indicator_player_dbus_interface_set_property (GDBusConnection* connection,
                                                    const gchar* sender,
                                                    const gchar* object_path,
                                                    const gchar* interface_name,
                                                    const gchar* property_name,
                                                    GVariant* value,
                                                    GError** error,
                                                    gpointer user_data)
{
	gpointer* data;
	gpointer object;
	data = user_data;
	object = data[0];
	return FALSE;
}


guint
sound_indicator_player_register_object (gpointer object,
                                        GDBusConnection* connection,
                                        const gchar* path,
                                        GError** error)
{
	guint result;
	gpointer *data;
	data = g_new (gpointer, 3);
	data[0] = g_object_ref (object);
	data[1] = g_object_ref (connection);
	data[2] = g_strdup (path);
	result = g_dbus_connection_register_object (connection, path, (GDBusInterfaceInfo *) (&_sound_indicator_player_dbus_interface_info), &_sound_indicator_player_dbus_interface_vtable, data, _sound_indicator_player_unregister_object, error);
	if (!result) {
		return 0;
	}
	return result;
}


static void
_sound_indicator_player_unregister_object (gpointer user_data)
{
	gpointer* data;
	data = user_data;
	g_object_unref (data[0]);
	g_object_unref (data[1]);
	g_free (data[2]);
	g_free (data);
}


static void
_vala_array_destroy (gpointer array,
                     gint array_length,
                     GDestroyNotify destroy_func)
{
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void
_vala_array_free (gpointer array,
                  gint array_length,
                  GDestroyNotify destroy_func)
{
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}



