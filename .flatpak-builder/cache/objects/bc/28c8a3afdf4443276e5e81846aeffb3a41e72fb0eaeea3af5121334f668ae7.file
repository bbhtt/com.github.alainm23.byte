/* CoverImport.c generated by valac 0.40.11, the Vala compiler
 * generated from CoverImport.vala, do not modify */



#include <glib.h>
#include <glib-object.h>
#include <gst/pbutils/pbutils.h>
#include <stdlib.h>
#include <string.h>
#include <gdk-pixbuf/gdk-pixbuf.h>
#include <gst/gst.h>
#include <gst/tag/tag.h>


#define SERVICES_TYPE_COVER_IMPORT (services_cover_import_get_type ())
#define SERVICES_COVER_IMPORT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SERVICES_TYPE_COVER_IMPORT, ServicesCoverImport))
#define SERVICES_COVER_IMPORT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SERVICES_TYPE_COVER_IMPORT, ServicesCoverImportClass))
#define SERVICES_IS_COVER_IMPORT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SERVICES_TYPE_COVER_IMPORT))
#define SERVICES_IS_COVER_IMPORT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SERVICES_TYPE_COVER_IMPORT))
#define SERVICES_COVER_IMPORT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SERVICES_TYPE_COVER_IMPORT, ServicesCoverImportClass))

typedef struct _ServicesCoverImport ServicesCoverImport;
typedef struct _ServicesCoverImportClass ServicesCoverImportClass;
typedef struct _ServicesCoverImportPrivate ServicesCoverImportPrivate;
enum  {
	SERVICES_COVER_IMPORT_0_PROPERTY,
	SERVICES_COVER_IMPORT_NUM_PROPERTIES
};
static GParamSpec* services_cover_import_properties[SERVICES_COVER_IMPORT_NUM_PROPERTIES];
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))

#define OBJECTS_TYPE_TRACK (objects_track_get_type ())
#define OBJECTS_TRACK(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), OBJECTS_TYPE_TRACK, ObjectsTrack))
#define OBJECTS_TRACK_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), OBJECTS_TYPE_TRACK, ObjectsTrackClass))
#define OBJECTS_IS_TRACK(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), OBJECTS_TYPE_TRACK))
#define OBJECTS_IS_TRACK_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), OBJECTS_TYPE_TRACK))
#define OBJECTS_TRACK_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), OBJECTS_TYPE_TRACK, ObjectsTrackClass))

typedef struct _ObjectsTrack ObjectsTrack;
typedef struct _ObjectsTrackClass ObjectsTrackClass;
typedef struct _ObjectsTrackPrivate ObjectsTrackPrivate;
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
typedef struct _Block5Data Block5Data;
#define _gst_sample_unref0(var) ((var == NULL) ? NULL : (var = (gst_sample_unref (var), NULL)))
#define _gst_buffer_unref0(var) ((var == NULL) ? NULL : (var = (gst_buffer_unref (var), NULL)))
#define _gst_tag_list_unref0(var) ((var == NULL) ? NULL : (var = (gst_tag_list_unref (var), NULL)))
#define _gst_caps_unref0(var) ((var == NULL) ? NULL : (var = (gst_caps_unref (var), NULL)))

#define TYPE_UTILS (utils_get_type ())
#define UTILS(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_UTILS, Utils))
#define UTILS_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_UTILS, UtilsClass))
#define IS_UTILS(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_UTILS))
#define IS_UTILS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_UTILS))
#define UTILS_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_UTILS, UtilsClass))

typedef struct _Utils Utils;
typedef struct _UtilsClass UtilsClass;
typedef struct _UtilsPrivate UtilsPrivate;

#define SERVICES_TYPE_DATABASE (services_database_get_type ())
#define SERVICES_DATABASE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SERVICES_TYPE_DATABASE, ServicesDatabase))
#define SERVICES_DATABASE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SERVICES_TYPE_DATABASE, ServicesDatabaseClass))
#define SERVICES_IS_DATABASE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SERVICES_TYPE_DATABASE))
#define SERVICES_IS_DATABASE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SERVICES_TYPE_DATABASE))
#define SERVICES_DATABASE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SERVICES_TYPE_DATABASE, ServicesDatabaseClass))

typedef struct _ServicesDatabase ServicesDatabase;
typedef struct _ServicesDatabaseClass ServicesDatabaseClass;

struct _ServicesCoverImport {
	GObject parent_instance;
	ServicesCoverImportPrivate * priv;
};

struct _ServicesCoverImportClass {
	GObjectClass parent_class;
};

struct _ServicesCoverImportPrivate {
	GstDiscoverer* discoverer;
};

struct _ObjectsTrack {
	GObject parent_instance;
	ObjectsTrackPrivate * priv;
	gint track_order;
	gint id;
	gint album_id;
	gint track;
	gint disc;
	gint play_count;
	gint is_favorite;
	gint bitrate;
	gint bpm;
	gint rating;
	gint samplerate;
	gint channels;
	gint year;
	gint playlist;
	guint64 duration;
	gchar* path;
	gchar* title;
	gchar* favorite_added;
	gchar* last_played;
	gchar* album_title;
	gchar* artist_name;
	gchar* composer;
	gchar* grouping;
	gchar* comment;
	gchar* lyrics;
	gchar* genre;
	gchar* album_artist;
	gchar* date_added;
};

struct _ObjectsTrackClass {
	GObjectClass parent_class;
};

struct _Block5Data {
	int _ref_count_;
	ServicesCoverImport* self;
	GstDiscovererInfo* info;
	ObjectsTrack* track;
};

struct _Utils {
	GObject parent_instance;
	UtilsPrivate * priv;
	gchar* MAIN_FOLDER;
	gchar* COVER_FOLDER;
};

struct _UtilsClass {
	GObjectClass parent_class;
};


static gpointer services_cover_import_parent_class = NULL;
extern Utils* byte_utils;
extern ServicesDatabase* byte_database;

GType services_cover_import_get_type (void) G_GNUC_CONST;
#define SERVICES_COVER_IMPORT_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), SERVICES_TYPE_COVER_IMPORT, ServicesCoverImportPrivate))
#define SERVICES_COVER_IMPORT_DISCOVERER_TIMEOUT 5
GType objects_track_get_type (void) G_GNUC_CONST;
void services_cover_import_import (ServicesCoverImport* self,
                                   ObjectsTrack* track);
static void services_cover_import_read_info (ServicesCoverImport* self,
                                      GstDiscovererInfo* info,
                                      ObjectsTrack* track);
static Block5Data* block5_data_ref (Block5Data* _data5_);
static void block5_data_unref (void * _userdata_);
static gboolean ___lambda13_ (Block5Data* _data5_);
static GstSample* services_cover_import_get_cover_sample (ServicesCoverImport* self,
                                                   GstTagList* tag_list);
static GdkPixbuf* services_cover_import_get_pixbuf_from_buffer (ServicesCoverImport* self,
                                                         GstBuffer* buffer);
static void services_cover_import_save_cover_pixbuf (ServicesCoverImport* self,
                                              GdkPixbuf* p,
                                              ObjectsTrack* track);
static gboolean ____lambda13__gsource_func (gpointer self);
GType utils_get_type (void) G_GNUC_CONST;
GdkPixbuf* utils_align_and_scale_pixbuf (Utils* self,
                                         GdkPixbuf* p,
                                         gint size);
GType services_database_get_type (void) G_GNUC_CONST;
ServicesCoverImport* services_cover_import_new (void);
ServicesCoverImport* services_cover_import_construct (GType object_type);
static GObject * services_cover_import_constructor (GType type,
                                             guint n_construct_properties,
                                             GObjectConstructParam * construct_properties);
static void services_cover_import_finalize (GObject * obj);


void
services_cover_import_import (ServicesCoverImport* self,
                              ObjectsTrack* track)
{
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (track != NULL);
	{
		GstDiscovererInfo* info = NULL;
		GstDiscoverer* _tmp0_;
		const gchar* _tmp1_;
		GstDiscovererInfo* _tmp2_;
		_tmp0_ = self->priv->discoverer;
		_tmp1_ = track->path;
		_tmp2_ = gst_discoverer_discover_uri (_tmp0_, _tmp1_, &_inner_error_);
		info = _tmp2_;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			goto __catch9_g_error;
		}
		services_cover_import_read_info (self, info, track);
		_g_object_unref0 (info);
	}
	goto __finally9;
	__catch9_g_error:
	{
		GError* err = NULL;
		const gchar* _tmp3_;
		const gchar* _tmp4_;
		gchar* _tmp5_;
		gchar* _tmp6_;
		err = _inner_error_;
		_inner_error_ = NULL;
		_tmp3_ = track->artist_name;
		_tmp4_ = track->title;
		_tmp5_ = g_strdup_printf ("%s - %s, Error while importing â€¦", _tmp3_, _tmp4_);
		_tmp6_ = _tmp5_;
		g_critical ("CoverImport.vala:18: %s", _tmp6_);
		_g_free0 (_tmp6_);
		_g_error_free0 (err);
	}
	__finally9:
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
}


static gpointer
_g_object_ref0 (gpointer self)
{
	return self ? g_object_ref (self) : NULL;
}


static Block5Data*
block5_data_ref (Block5Data* _data5_)
{
	g_atomic_int_inc (&_data5_->_ref_count_);
	return _data5_;
}


static void
block5_data_unref (void * _userdata_)
{
	Block5Data* _data5_;
	_data5_ = (Block5Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data5_->_ref_count_)) {
		ServicesCoverImport* self;
		self = _data5_->self;
		_g_object_unref0 (_data5_->info);
		_g_object_unref0 (_data5_->track);
		_g_object_unref0 (self);
		g_slice_free (Block5Data, _data5_);
	}
}


static gpointer
_gst_tag_list_ref0 (gpointer self)
{
	return self ? gst_tag_list_ref (self) : NULL;
}


static gpointer
_gst_buffer_ref0 (gpointer self)
{
	return self ? gst_buffer_ref (self) : NULL;
}


static gboolean
___lambda13_ (Block5Data* _data5_)
{
	ServicesCoverImport* self;
	gboolean result = FALSE;
	GdkPixbuf* pixbuf = NULL;
	GstTagList* tag_list = NULL;
	GstTagList* _tmp0_;
	GstTagList* _tmp1_;
	GstSample* sample = NULL;
	GstTagList* _tmp2_;
	GstSample* _tmp3_;
	GstSample* _tmp4_;
	GstSample* _tmp7_;
	self = _data5_->self;
	pixbuf = NULL;
	_tmp0_ = gst_discoverer_info_get_tags (_data5_->info);
	_tmp1_ = _gst_tag_list_ref0 (_tmp0_);
	tag_list = _tmp1_;
	_tmp2_ = tag_list;
	_tmp3_ = services_cover_import_get_cover_sample (self, _tmp2_);
	sample = _tmp3_;
	_tmp4_ = sample;
	if (_tmp4_ == NULL) {
		GstTagList* _tmp5_;
		GstSample* _tmp6_ = NULL;
		_tmp5_ = tag_list;
		gst_tag_list_get_sample_index (_tmp5_, GST_TAG_PREVIEW_IMAGE, (guint) 0, &_tmp6_);
		_gst_sample_unref0 (sample);
		sample = _tmp6_;
	}
	_tmp7_ = sample;
	if (_tmp7_ != NULL) {
		GstBuffer* buffer = NULL;
		GstSample* _tmp8_;
		GstBuffer* _tmp9_;
		GstBuffer* _tmp10_;
		GstBuffer* _tmp11_;
		const gchar* _tmp16_;
		_tmp8_ = sample;
		_tmp9_ = gst_sample_get_buffer (_tmp8_);
		_tmp10_ = _gst_buffer_ref0 (_tmp9_);
		buffer = _tmp10_;
		_tmp11_ = buffer;
		if (_tmp11_ != NULL) {
			GstBuffer* _tmp12_;
			GdkPixbuf* _tmp13_;
			GdkPixbuf* _tmp14_;
			_tmp12_ = buffer;
			_tmp13_ = services_cover_import_get_pixbuf_from_buffer (self, _tmp12_);
			_g_object_unref0 (pixbuf);
			pixbuf = _tmp13_;
			_tmp14_ = pixbuf;
			if (_tmp14_ != NULL) {
				GdkPixbuf* _tmp15_;
				_tmp15_ = pixbuf;
				services_cover_import_save_cover_pixbuf (self, _tmp15_, _data5_->track);
			}
		}
		_tmp16_ = gst_discoverer_info_get_uri (_data5_->info);
		g_debug ("CoverImport.vala:73: Final image buffer is NULL for '%s'", _tmp16_);
		_gst_buffer_unref0 (buffer);
	} else {
		const gchar* _tmp17_;
		_tmp17_ = gst_discoverer_info_get_uri (_data5_->info);
		g_debug ("CoverImport.vala:75: Image sample is NULL for '%s'", _tmp17_);
	}
	result = FALSE;
	_gst_sample_unref0 (sample);
	_gst_tag_list_unref0 (tag_list);
	_g_object_unref0 (pixbuf);
	return result;
}


static gboolean
____lambda13__gsource_func (gpointer self)
{
	gboolean result;
	result = ___lambda13_ (self);
	return result;
}


static void
services_cover_import_read_info (ServicesCoverImport* self,
                                 GstDiscovererInfo* info,
                                 ObjectsTrack* track)
{
	Block5Data* _data5_;
	GstDiscovererInfo* _tmp0_;
	ObjectsTrack* _tmp1_;
	gchar* uri = NULL;
	const gchar* _tmp2_;
	gchar* _tmp3_;
	gboolean gstreamer_discovery_successful = FALSE;
	gboolean _tmp9_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (info != NULL);
	g_return_if_fail (track != NULL);
	_data5_ = g_slice_new0 (Block5Data);
	_data5_->_ref_count_ = 1;
	_data5_->self = g_object_ref (self);
	_tmp0_ = _g_object_ref0 (info);
	_g_object_unref0 (_data5_->info);
	_data5_->info = _tmp0_;
	_tmp1_ = _g_object_ref0 (track);
	_g_object_unref0 (_data5_->track);
	_data5_->track = _tmp1_;
	_tmp2_ = gst_discoverer_info_get_uri (_data5_->info);
	_tmp3_ = g_strdup (_tmp2_);
	uri = _tmp3_;
	gstreamer_discovery_successful = FALSE;
	switch (gst_discoverer_info_get_result (_data5_->info)) {
		case GST_DISCOVERER_OK:
		{
			gstreamer_discovery_successful = TRUE;
			break;
		}
		case GST_DISCOVERER_URI_INVALID:
		{
			const gchar* _tmp4_;
			_tmp4_ = uri;
			g_warning ("CoverImport.vala:33: GStreamer could not import '%s': invalid URI.", _tmp4_);
			break;
		}
		case GST_DISCOVERER_ERROR:
		{
			const gchar* _tmp5_;
			_tmp5_ = uri;
			g_warning ("CoverImport.vala:37: GStreamer could not import '%s'", _tmp5_);
			break;
		}
		case GST_DISCOVERER_TIMEOUT:
		{
			const gchar* _tmp6_;
			_tmp6_ = uri;
			g_warning ("CoverImport.vala:41: GStreamer could not import '%s': Discovery timed " \
"out.", _tmp6_);
			break;
		}
		case GST_DISCOVERER_BUSY:
		{
			const gchar* _tmp7_;
			_tmp7_ = uri;
			g_warning ("CoverImport.vala:45: GStreamer could not import '%s': Already discover" \
"ing a file.", _tmp7_);
			break;
		}
		case GST_DISCOVERER_MISSING_PLUGINS:
		{
			const gchar* _tmp8_;
			_tmp8_ = uri;
			g_warning ("CoverImport.vala:49: GStreamer could not import '%s': Missing plugins.", _tmp8_);
			break;
		}
		default:
		break;
	}
	_tmp9_ = gstreamer_discovery_successful;
	if (_tmp9_) {
		g_idle_add_full (G_PRIORITY_DEFAULT_IDLE, ____lambda13__gsource_func, block5_data_ref (_data5_), block5_data_unref);
	}
	_g_free0 (uri);
	block5_data_unref (_data5_);
	_data5_ = NULL;
}


static gpointer
_gst_caps_ref0 (gpointer self)
{
	return self ? gst_caps_ref (self) : NULL;
}


static gpointer
_gst_sample_ref0 (gpointer self)
{
	return self ? gst_sample_ref (self) : NULL;
}


static GstSample*
services_cover_import_get_cover_sample (ServicesCoverImport* self,
                                        GstTagList* tag_list)
{
	GstSample* result = NULL;
	GstSample* cover_sample = NULL;
	GstSample* sample = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (tag_list != NULL, NULL);
	cover_sample = NULL;
	{
		gint i = 0;
		i = 0;
		{
			gboolean _tmp0_ = FALSE;
			_tmp0_ = TRUE;
			while (TRUE) {
				gint _tmp2_;
				GstSample* _tmp3_ = NULL;
				gboolean _tmp4_;
				GstCaps* caps = NULL;
				GstSample* _tmp5_;
				GstCaps* _tmp6_;
				GstCaps* _tmp7_;
				GstStructure* caps_struct = NULL;
				GstCaps* _tmp8_;
				GstStructure* _tmp9_;
				gint image_type = 0;
				GstStructure* _tmp10_;
				gint _tmp11_ = 0;
				gboolean _tmp12_ = FALSE;
				gint _tmp13_;
				if (!_tmp0_) {
					gint _tmp1_;
					_tmp1_ = i;
					i = _tmp1_ + 1;
				}
				_tmp0_ = FALSE;
				_tmp2_ = i;
				_tmp4_ = gst_tag_list_get_sample_index (tag_list, GST_TAG_IMAGE, (guint) _tmp2_, &_tmp3_);
				_gst_sample_unref0 (sample);
				sample = _tmp3_;
				if (!_tmp4_) {
					break;
				}
				_tmp5_ = sample;
				_tmp6_ = gst_sample_get_caps (_tmp5_);
				_tmp7_ = _gst_caps_ref0 (_tmp6_);
				caps = _tmp7_;
				_tmp8_ = caps;
				_tmp9_ = gst_caps_get_structure (_tmp8_, (guint) 0);
				caps_struct = _tmp9_;
				image_type = (gint) GST_TAG_IMAGE_TYPE_UNDEFINED;
				_tmp10_ = caps_struct;
				gst_structure_get_enum (_tmp10_, "image-type", gst_tag_image_type_get_type (), &_tmp11_);
				image_type = _tmp11_;
				_tmp13_ = image_type;
				if (_tmp13_ == ((gint) GST_TAG_IMAGE_TYPE_UNDEFINED)) {
					GstSample* _tmp14_;
					_tmp14_ = cover_sample;
					_tmp12_ = _tmp14_ == NULL;
				} else {
					_tmp12_ = FALSE;
				}
				if (_tmp12_) {
					GstSample* _tmp15_;
					GstSample* _tmp16_;
					_tmp15_ = sample;
					_tmp16_ = _gst_sample_ref0 (_tmp15_);
					_gst_sample_unref0 (cover_sample);
					cover_sample = _tmp16_;
				} else {
					gint _tmp17_;
					_tmp17_ = image_type;
					if (_tmp17_ == ((gint) GST_TAG_IMAGE_TYPE_FRONT_COVER)) {
						result = sample;
						_gst_caps_unref0 (caps);
						_gst_sample_unref0 (cover_sample);
						return result;
					}
				}
				_gst_caps_unref0 (caps);
			}
		}
	}
	result = cover_sample;
	_gst_sample_unref0 (sample);
	return result;
}


static GdkPixbuf*
services_cover_import_get_pixbuf_from_buffer (ServicesCoverImport* self,
                                              GstBuffer* buffer)
{
	GdkPixbuf* result = NULL;
	GstMapInfo map_info = {0};
	GstMapInfo _tmp0_ = {0};
	gboolean _tmp1_;
	GdkPixbuf* pix = NULL;
	GstMapInfo _tmp15_;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (buffer != NULL, NULL);
	_tmp1_ = gst_buffer_map (buffer, &_tmp0_, GST_MAP_READ);
	map_info = _tmp0_;
	if (!_tmp1_) {
		g_warning ("CoverImport.vala:105: Could not map memory buffer");
		result = NULL;
		return result;
	}
	pix = NULL;
	{
		GdkPixbufLoader* loader = NULL;
		GdkPixbufLoader* _tmp2_;
		gboolean _tmp3_ = FALSE;
		gboolean _tmp4_ = FALSE;
		GdkPixbufLoader* _tmp5_;
		GstMapInfo _tmp6_;
		guint8* _tmp7_;
		gint _tmp7__length1;
		_tmp2_ = gdk_pixbuf_loader_new ();
		loader = _tmp2_;
		_tmp5_ = loader;
		_tmp6_ = map_info;
		_tmp7_ = _tmp6_.data;
		_tmp7__length1 = (gint) _tmp6_.size;
		_tmp4_ = gdk_pixbuf_loader_write (_tmp5_, _tmp7_, (gsize) _tmp7__length1, &_inner_error_);
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			_g_object_unref0 (loader);
			goto __catch10_g_error;
		}
		if (_tmp4_) {
			gboolean _tmp8_ = FALSE;
			GdkPixbufLoader* _tmp9_;
			_tmp9_ = loader;
			_tmp8_ = gdk_pixbuf_loader_close (_tmp9_, &_inner_error_);
			if (G_UNLIKELY (_inner_error_ != NULL)) {
				_g_object_unref0 (loader);
				goto __catch10_g_error;
			}
			_tmp3_ = _tmp8_;
		} else {
			_tmp3_ = FALSE;
		}
		if (_tmp3_) {
			GdkPixbufLoader* _tmp10_;
			GdkPixbuf* _tmp11_;
			GdkPixbuf* _tmp12_;
			_tmp10_ = loader;
			_tmp11_ = gdk_pixbuf_loader_get_pixbuf (_tmp10_);
			_tmp12_ = _g_object_ref0 (_tmp11_);
			_g_object_unref0 (pix);
			pix = _tmp12_;
		}
		_g_object_unref0 (loader);
	}
	goto __finally10;
	__catch10_g_error:
	{
		GError* err = NULL;
		GError* _tmp13_;
		const gchar* _tmp14_;
		err = _inner_error_;
		_inner_error_ = NULL;
		_tmp13_ = err;
		_tmp14_ = _tmp13_->message;
		g_warning ("CoverImport.vala:117: Error processing image data: %s", _tmp14_);
		_g_error_free0 (err);
	}
	__finally10:
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		_g_object_unref0 (pix);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	_tmp15_ = map_info;
	gst_buffer_unmap (buffer, &_tmp15_);
	result = pix;
	return result;
}


static void
services_cover_import_save_cover_pixbuf (ServicesCoverImport* self,
                                         GdkPixbuf* p,
                                         ObjectsTrack* track)
{
	GdkPixbuf* pixbuf = NULL;
	Utils* _tmp0_;
	GdkPixbuf* _tmp1_;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (p != NULL);
	g_return_if_fail (track != NULL);
	_tmp0_ = byte_utils;
	_tmp1_ = utils_align_and_scale_pixbuf (_tmp0_, p, 256);
	pixbuf = _tmp1_;
	{
		gchar* album_path = NULL;
		Utils* _tmp2_;
		const gchar* _tmp3_;
		gint _tmp4_;
		gchar* _tmp5_;
		gchar* _tmp6_;
		gchar* _tmp7_;
		gchar* _tmp8_;
		gchar* track_path = NULL;
		Utils* _tmp9_;
		const gchar* _tmp10_;
		gint _tmp11_;
		gchar* _tmp12_;
		gchar* _tmp13_;
		gchar* _tmp14_;
		gchar* _tmp15_;
		gboolean _tmp16_ = FALSE;
		GdkPixbuf* _tmp17_;
		const gchar* _tmp18_;
		gboolean _tmp21_ = FALSE;
		GdkPixbuf* _tmp22_;
		const gchar* _tmp23_;
		_tmp2_ = byte_utils;
		_tmp3_ = _tmp2_->COVER_FOLDER;
		_tmp4_ = track->album_id;
		_tmp5_ = g_strdup_printf ("album-%i.jpg", _tmp4_);
		_tmp6_ = _tmp5_;
		_tmp7_ = g_build_filename (_tmp3_, _tmp6_, NULL);
		_tmp8_ = _tmp7_;
		_g_free0 (_tmp6_);
		album_path = _tmp8_;
		_tmp9_ = byte_utils;
		_tmp10_ = _tmp9_->COVER_FOLDER;
		_tmp11_ = track->id;
		_tmp12_ = g_strdup_printf ("track-%i.jpg", _tmp11_);
		_tmp13_ = _tmp12_;
		_tmp14_ = g_build_filename (_tmp10_, _tmp13_, NULL);
		_tmp15_ = _tmp14_;
		_g_free0 (_tmp13_);
		track_path = _tmp15_;
		_tmp17_ = pixbuf;
		_tmp18_ = album_path;
		_tmp16_ = gdk_pixbuf_save (_tmp17_, _tmp18_, "jpeg", &_inner_error_, "quality", "100", NULL);
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			_g_free0 (track_path);
			_g_free0 (album_path);
			goto __catch11_g_error;
		}
		if (_tmp16_) {
			ServicesDatabase* _tmp19_;
			gint _tmp20_;
			_tmp19_ = byte_database;
			_tmp20_ = track->album_id;
			g_signal_emit_by_name (_tmp19_, "updated-album-cover", _tmp20_);
		}
		_tmp22_ = pixbuf;
		_tmp23_ = track_path;
		_tmp21_ = gdk_pixbuf_save (_tmp22_, _tmp23_, "jpeg", &_inner_error_, "quality", "100", NULL);
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			_g_free0 (track_path);
			_g_free0 (album_path);
			goto __catch11_g_error;
		}
		if (_tmp21_) {
			ServicesDatabase* _tmp24_;
			gint _tmp25_;
			_tmp24_ = byte_database;
			_tmp25_ = track->id;
			g_signal_emit_by_name (_tmp24_, "updated-track-cover", _tmp25_);
		}
		_g_free0 (track_path);
		_g_free0 (album_path);
	}
	goto __finally11;
	__catch11_g_error:
	{
		GError* err = NULL;
		GError* _tmp26_;
		const gchar* _tmp27_;
		err = _inner_error_;
		_inner_error_ = NULL;
		_tmp26_ = err;
		_tmp27_ = _tmp26_->message;
		g_warning ("CoverImport.vala:143: %s", _tmp27_);
		_g_error_free0 (err);
	}
	__finally11:
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		_g_object_unref0 (pixbuf);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	_g_object_unref0 (pixbuf);
}


ServicesCoverImport*
services_cover_import_construct (GType object_type)
{
	ServicesCoverImport * self = NULL;
	self = (ServicesCoverImport*) g_object_new (object_type, NULL);
	return self;
}


ServicesCoverImport*
services_cover_import_new (void)
{
	return services_cover_import_construct (SERVICES_TYPE_COVER_IMPORT);
}


static GObject *
services_cover_import_constructor (GType type,
                                   guint n_construct_properties,
                                   GObjectConstructParam * construct_properties)
{
	GObject * obj;
	GObjectClass * parent_class;
	ServicesCoverImport * self;
	GError * _inner_error_ = NULL;
	parent_class = G_OBJECT_CLASS (services_cover_import_parent_class);
	obj = parent_class->constructor (type, n_construct_properties, construct_properties);
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, SERVICES_TYPE_COVER_IMPORT, ServicesCoverImport);
	{
		GstDiscoverer* _tmp0_ = NULL;
		GstDiscoverer* _tmp1_;
		GstDiscoverer* _tmp2_;
		_tmp1_ = gst_discoverer_new ((GstClockTime) (SERVICES_COVER_IMPORT_DISCOVERER_TIMEOUT * GST_SECOND), &_inner_error_);
		_tmp0_ = _tmp1_;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			goto __catch12_g_error;
		}
		_tmp2_ = _tmp0_;
		_tmp0_ = NULL;
		_g_object_unref0 (self->priv->discoverer);
		self->priv->discoverer = _tmp2_;
		_g_object_unref0 (_tmp0_);
	}
	goto __finally12;
	__catch12_g_error:
	{
		GError* err = NULL;
		GError* _tmp3_;
		const gchar* _tmp4_;
		err = _inner_error_;
		_inner_error_ = NULL;
		_tmp3_ = err;
		_tmp4_ = _tmp3_->message;
		g_critical ("CoverImport.vala:9: Could not create Gst discoverer object: %s", _tmp4_);
		_g_error_free0 (err);
	}
	__finally12:
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
	}
	return obj;
}


static void
services_cover_import_class_init (ServicesCoverImportClass * klass)
{
	services_cover_import_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (ServicesCoverImportPrivate));
	G_OBJECT_CLASS (klass)->constructor = services_cover_import_constructor;
	G_OBJECT_CLASS (klass)->finalize = services_cover_import_finalize;
}


static void
services_cover_import_instance_init (ServicesCoverImport * self)
{
	self->priv = SERVICES_COVER_IMPORT_GET_PRIVATE (self);
}


static void
services_cover_import_finalize (GObject * obj)
{
	ServicesCoverImport * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, SERVICES_TYPE_COVER_IMPORT, ServicesCoverImport);
	_g_object_unref0 (self->priv->discoverer);
	G_OBJECT_CLASS (services_cover_import_parent_class)->finalize (obj);
}


GType
services_cover_import_get_type (void)
{
	static volatile gsize services_cover_import_type_id__volatile = 0;
	if (g_once_init_enter (&services_cover_import_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (ServicesCoverImportClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) services_cover_import_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (ServicesCoverImport), 0, (GInstanceInitFunc) services_cover_import_instance_init, NULL };
		GType services_cover_import_type_id;
		services_cover_import_type_id = g_type_register_static (G_TYPE_OBJECT, "ServicesCoverImport", &g_define_type_info, 0);
		g_once_init_leave (&services_cover_import_type_id__volatile, services_cover_import_type_id);
	}
	return services_cover_import_type_id__volatile;
}



