/* Scan.c generated by valac 0.40.11, the Vala compiler
 * generated from Scan.vala, do not modify */



#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <gio/gio.h>
#include <gtk/gtk.h>
#include <glib/gi18n-lib.h>
#include <float.h>
#include <math.h>


#define SERVICES_TYPE_SCAN (services_scan_get_type ())
#define SERVICES_SCAN(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SERVICES_TYPE_SCAN, ServicesScan))
#define SERVICES_SCAN_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SERVICES_TYPE_SCAN, ServicesScanClass))
#define SERVICES_IS_SCAN(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SERVICES_TYPE_SCAN))
#define SERVICES_IS_SCAN_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SERVICES_TYPE_SCAN))
#define SERVICES_SCAN_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SERVICES_TYPE_SCAN, ServicesScanClass))

typedef struct _ServicesScan ServicesScan;
typedef struct _ServicesScanClass ServicesScanClass;
typedef struct _ServicesScanPrivate ServicesScanPrivate;
enum  {
	SERVICES_SCAN_0_PROPERTY,
	SERVICES_SCAN_NUM_PROPERTIES
};
static GParamSpec* services_scan_properties[SERVICES_SCAN_NUM_PROPERTIES];
#define _g_free0(var) (var = (g_free (var), NULL))
typedef struct _Block6Data Block6Data;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_regex_unref0(var) ((var == NULL) ? NULL : (var = (g_regex_unref (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
#define _g_thread_unref0(var) ((var == NULL) ? NULL : (var = (g_thread_unref (var), NULL)))
typedef struct _Block7Data Block7Data;

#define SERVICES_TYPE_DATABASE (services_database_get_type ())
#define SERVICES_DATABASE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SERVICES_TYPE_DATABASE, ServicesDatabase))
#define SERVICES_DATABASE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SERVICES_TYPE_DATABASE, ServicesDatabaseClass))
#define SERVICES_IS_DATABASE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SERVICES_TYPE_DATABASE))
#define SERVICES_IS_DATABASE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SERVICES_TYPE_DATABASE))
#define SERVICES_DATABASE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SERVICES_TYPE_DATABASE, ServicesDatabaseClass))

typedef struct _ServicesDatabase ServicesDatabase;
typedef struct _ServicesDatabaseClass ServicesDatabaseClass;

#define SERVICES_TYPE_TAG_MANAGER (services_tag_manager_get_type ())
#define SERVICES_TAG_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SERVICES_TYPE_TAG_MANAGER, ServicesTagManager))
#define SERVICES_TAG_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SERVICES_TYPE_TAG_MANAGER, ServicesTagManagerClass))
#define SERVICES_IS_TAG_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SERVICES_TYPE_TAG_MANAGER))
#define SERVICES_IS_TAG_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SERVICES_TYPE_TAG_MANAGER))
#define SERVICES_TAG_MANAGER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SERVICES_TYPE_TAG_MANAGER, ServicesTagManagerClass))

typedef struct _ServicesTagManager ServicesTagManager;
typedef struct _ServicesTagManagerClass ServicesTagManagerClass;

#define TYPE_MAIN_WINDOW (main_window_get_type ())
#define MAIN_WINDOW(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_MAIN_WINDOW, MainWindow))
#define MAIN_WINDOW_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_MAIN_WINDOW, MainWindowClass))
#define IS_MAIN_WINDOW(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_MAIN_WINDOW))
#define IS_MAIN_WINDOW_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_MAIN_WINDOW))
#define MAIN_WINDOW_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_MAIN_WINDOW, MainWindowClass))

typedef struct _MainWindow MainWindow;
typedef struct _MainWindowClass MainWindowClass;

#define OBJECTS_TYPE_ARTIST (objects_artist_get_type ())
#define OBJECTS_ARTIST(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), OBJECTS_TYPE_ARTIST, ObjectsArtist))
#define OBJECTS_ARTIST_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), OBJECTS_TYPE_ARTIST, ObjectsArtistClass))
#define OBJECTS_IS_ARTIST(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), OBJECTS_TYPE_ARTIST))
#define OBJECTS_IS_ARTIST_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), OBJECTS_TYPE_ARTIST))
#define OBJECTS_ARTIST_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), OBJECTS_TYPE_ARTIST, ObjectsArtistClass))

typedef struct _ObjectsArtist ObjectsArtist;
typedef struct _ObjectsArtistClass ObjectsArtistClass;

#define OBJECTS_TYPE_ALBUM (objects_album_get_type ())
#define OBJECTS_ALBUM(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), OBJECTS_TYPE_ALBUM, ObjectsAlbum))
#define OBJECTS_ALBUM_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), OBJECTS_TYPE_ALBUM, ObjectsAlbumClass))
#define OBJECTS_IS_ALBUM(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), OBJECTS_TYPE_ALBUM))
#define OBJECTS_IS_ALBUM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), OBJECTS_TYPE_ALBUM))
#define OBJECTS_ALBUM_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), OBJECTS_TYPE_ALBUM, ObjectsAlbumClass))

typedef struct _ObjectsAlbum ObjectsAlbum;
typedef struct _ObjectsAlbumClass ObjectsAlbumClass;

#define OBJECTS_TYPE_TRACK (objects_track_get_type ())
#define OBJECTS_TRACK(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), OBJECTS_TYPE_TRACK, ObjectsTrack))
#define OBJECTS_TRACK_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), OBJECTS_TYPE_TRACK, ObjectsTrackClass))
#define OBJECTS_IS_TRACK(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), OBJECTS_TYPE_TRACK))
#define OBJECTS_IS_TRACK_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), OBJECTS_TYPE_TRACK))
#define OBJECTS_TRACK_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), OBJECTS_TYPE_TRACK, ObjectsTrackClass))

typedef struct _ObjectsTrack ObjectsTrack;
typedef struct _ObjectsTrackClass ObjectsTrackClass;
typedef struct _Block8Data Block8Data;
typedef struct _ObjectsAlbumPrivate ObjectsAlbumPrivate;
typedef struct _ObjectsArtistPrivate ObjectsArtistPrivate;
typedef struct _ObjectsTrackPrivate ObjectsTrackPrivate;
enum  {
	SERVICES_SCAN_SYNC_STARTED_SIGNAL,
	SERVICES_SCAN_SYNC_FINISHED_SIGNAL,
	SERVICES_SCAN_SYNC_PROGRESS_SIGNAL,
	SERVICES_SCAN_NUM_SIGNALS
};
static guint services_scan_signals[SERVICES_SCAN_NUM_SIGNALS] = {0};

struct _ServicesScan {
	GObject parent_instance;
	ServicesScanPrivate * priv;
	gint counter;
	gint counter_max;
	gboolean is_sync;
};

struct _ServicesScanClass {
	GObjectClass parent_class;
};

struct _Block6Data {
	int _ref_count_;
	ServicesScan* self;
	gchar* uri;
};

struct _Block7Data {
	int _ref_count_;
	ServicesScan* self;
	gchar* uri;
};

struct _Block8Data {
	int _ref_count_;
	ServicesScan* self;
	ObjectsArtist* artist;
	ObjectsAlbum* album;
	ObjectsTrack* track;
};

struct _ObjectsAlbum {
	GObject parent_instance;
	ObjectsAlbumPrivate * priv;
	gint id;
	gint artist_id;
	gchar* artist_name;
	gint year;
	gchar* title;
	gchar* genre;
};

struct _ObjectsAlbumClass {
	GObjectClass parent_class;
};

struct _ObjectsArtist {
	GObject parent_instance;
	ObjectsArtistPrivate * priv;
	gint id;
	gchar* name;
};

struct _ObjectsArtistClass {
	GObjectClass parent_class;
};

struct _ObjectsTrack {
	GObject parent_instance;
	ObjectsTrackPrivate * priv;
	gint track_order;
	gint id;
	gint album_id;
	gint track;
	gint disc;
	gint play_count;
	gint is_favorite;
	gint bitrate;
	gint bpm;
	gint rating;
	gint samplerate;
	gint channels;
	gint year;
	gint playlist;
	guint64 duration;
	gchar* path;
	gchar* title;
	gchar* favorite_added;
	gchar* last_played;
	gchar* album_title;
	gchar* artist_name;
	gchar* composer;
	gchar* grouping;
	gchar* comment;
	gchar* lyrics;
	gchar* genre;
	gchar* album_artist;
	gchar* date_added;
};

struct _ObjectsTrackClass {
	GObjectClass parent_class;
};


static gpointer services_scan_parent_class = NULL;
extern ServicesDatabase* byte_database;
extern ServicesTagManager* byte_tg_manager;

GType services_scan_get_type (void) G_GNUC_CONST;
void services_scan_scan_local_files (ServicesScan* self,
                                     const gchar* uri);
static Block6Data* block6_data_ref (Block6Data* _data6_);
static void block6_data_unref (void * _userdata_);
static void* __lambda10_ (Block6Data* _data6_);
gboolean services_scan_is_audio_file (const gchar* mime_type);
void services_scan_found_music_file (ServicesScan* self,
                                     const gchar* uri);
static gpointer ___lambda10__gthread_func (gpointer self);
static Block7Data* block7_data_ref (Block7Data* _data7_);
static void block7_data_unref (void * _userdata_);
static void* __lambda11_ (Block7Data* _data7_);
GType services_database_get_type (void) G_GNUC_CONST;
gboolean services_database_music_file_exists (ServicesDatabase* self,
                                              const gchar* uri);
gboolean services_database_music_blacklist_exists (ServicesDatabase* self,
                                                   const gchar* uri);
GType services_tag_manager_get_type (void) G_GNUC_CONST;
void services_tag_manager_add_discover_uri (ServicesTagManager* self,
                                            const gchar* uri);
static gpointer ___lambda11__gthread_func (gpointer self);
GType main_window_get_type (void) G_GNUC_CONST;
gchar* services_scan_choose_folder (ServicesScan* self,
                                    MainWindow* window);
GType objects_artist_get_type (void) G_GNUC_CONST;
GType objects_album_get_type (void) G_GNUC_CONST;
GType objects_track_get_type (void) G_GNUC_CONST;
void services_scan_discovered_new_local_item (ServicesScan* self,
                                              ObjectsArtist* artist,
                                              ObjectsAlbum* album,
                                              ObjectsTrack* track);
static Block8Data* block8_data_ref (Block8Data* _data8_);
static void block8_data_unref (void * _userdata_);
static void* __lambda15_ (Block8Data* _data8_);
gint services_database_insert_artist_if_not_exists (ServicesDatabase* self,
                                                    ObjectsArtist* artist);
gint services_database_insert_album_if_not_exists (ServicesDatabase* self,
                                                   ObjectsAlbum* album);
void services_database_insert_track (ServicesDatabase* self,
                                     ObjectsTrack* track);
static gpointer ___lambda15__gthread_func (gpointer self);
ServicesScan* services_scan_new (void);
ServicesScan* services_scan_construct (GType object_type);
static GObject * services_scan_constructor (GType type,
                                     guint n_construct_properties,
                                     GObjectConstructParam * construct_properties);
static void _services_scan_discovered_new_local_item_services_tag_manager_discovered_new_item (ServicesTagManager* _sender,
                                                                                        ObjectsArtist* artist,
                                                                                        ObjectsAlbum* album,
                                                                                        ObjectsTrack* track,
                                                                                        gpointer self);
static void _services_scan___lambda16_ (ServicesScan* self);
static gboolean __lambda17_ (ServicesScan* self);
static gboolean ___lambda17__gsource_func (gpointer self);
static void __services_scan___lambda16__services_database_adden_new_track (ServicesDatabase* _sender,
                                                                    ObjectsTrack* track,
                                                                    gpointer self);
static void services_scan_finalize (GObject * obj);


static Block6Data*
block6_data_ref (Block6Data* _data6_)
{
	g_atomic_int_inc (&_data6_->_ref_count_);
	return _data6_;
}


static void
block6_data_unref (void * _userdata_)
{
	Block6Data* _data6_;
	_data6_ = (Block6Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data6_->_ref_count_)) {
		ServicesScan* self;
		self = _data6_->self;
		_g_free0 (_data6_->uri);
		_g_object_unref0 (self);
		g_slice_free (Block6Data, _data6_);
	}
}


static gchar*
string_replace (const gchar* self,
                const gchar* old,
                const gchar* replacement)
{
	gchar* result = NULL;
	gboolean _tmp0_ = FALSE;
	gboolean _tmp1_ = FALSE;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (old != NULL, NULL);
	g_return_val_if_fail (replacement != NULL, NULL);
	if ((*((gchar*) self)) == '\0') {
		_tmp1_ = TRUE;
	} else {
		_tmp1_ = (*((gchar*) old)) == '\0';
	}
	if (_tmp1_) {
		_tmp0_ = TRUE;
	} else {
		_tmp0_ = g_strcmp0 (old, replacement) == 0;
	}
	if (_tmp0_) {
		gchar* _tmp2_;
		_tmp2_ = g_strdup (self);
		result = _tmp2_;
		return result;
	}
	{
		GRegex* regex = NULL;
		gchar* _tmp3_;
		gchar* _tmp4_;
		GRegex* _tmp5_;
		GRegex* _tmp6_;
		gchar* _tmp7_ = NULL;
		GRegex* _tmp8_;
		gchar* _tmp9_;
		gchar* _tmp10_;
		_tmp3_ = g_regex_escape_string (old, -1);
		_tmp4_ = _tmp3_;
		_tmp5_ = g_regex_new (_tmp4_, 0, 0, &_inner_error_);
		_tmp6_ = _tmp5_;
		_g_free0 (_tmp4_);
		regex = _tmp6_;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			if (_inner_error_->domain == G_REGEX_ERROR) {
				goto __catch17_g_regex_error;
			}
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
		_tmp8_ = regex;
		_tmp9_ = g_regex_replace_literal (_tmp8_, self, (gssize) -1, 0, replacement, 0, &_inner_error_);
		_tmp7_ = _tmp9_;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			_g_regex_unref0 (regex);
			if (_inner_error_->domain == G_REGEX_ERROR) {
				goto __catch17_g_regex_error;
			}
			_g_regex_unref0 (regex);
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
		_tmp10_ = _tmp7_;
		_tmp7_ = NULL;
		result = _tmp10_;
		_g_free0 (_tmp7_);
		_g_regex_unref0 (regex);
		return result;
	}
	goto __finally17;
	__catch17_g_regex_error:
	{
		GError* e = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		g_assert_not_reached ();
		_g_error_free0 (e);
	}
	__finally17:
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
}


static void*
__lambda10_ (Block6Data* _data6_)
{
	ServicesScan* self;
	void* result = NULL;
	GFile* directory = NULL;
	gchar* _tmp0_;
	gchar* _tmp1_;
	GFile* _tmp2_;
	GFile* _tmp3_;
	GFile* _tmp54_;
	GError * _inner_error_ = NULL;
	self = _data6_->self;
	_tmp0_ = string_replace (_data6_->uri, "#", "%23");
	_tmp1_ = _tmp0_;
	_tmp2_ = g_file_new_for_uri (_tmp1_);
	_tmp3_ = _tmp2_;
	_g_free0 (_tmp1_);
	directory = _tmp3_;
	{
		GFileEnumerator* children = NULL;
		GFile* _tmp4_;
		GFileEnumerator* _tmp5_;
		GFileInfo* file_info = NULL;
		GFileEnumerator* _tmp50_;
		GFileEnumerator* _tmp51_;
		_tmp4_ = directory;
		_tmp5_ = g_file_enumerate_children (_tmp4_, "standard::*," G_FILE_ATTRIBUTE_STANDARD_CONTENT_TYPE "," G_FILE_ATTRIBUTE_STANDARD_IS_HIDDEN "," G_FILE_ATTRIBUTE_STANDARD_IS_SYMLINK "," G_FILE_ATTRIBUTE_STANDARD_SYMLINK_TARGET, G_FILE_QUERY_INFO_NONE, NULL, &_inner_error_);
		children = _tmp5_;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			goto __catch18_g_error;
		}
		file_info = NULL;
		while (TRUE) {
			GFileInfo* _tmp6_ = NULL;
			GFileEnumerator* _tmp7_;
			GFileInfo* _tmp8_;
			GFileInfo* _tmp9_;
			GFileInfo* _tmp10_;
			GFileInfo* _tmp11_;
			GFileInfo* _tmp12_;
			_tmp7_ = children;
			_tmp8_ = g_file_enumerator_next_file (_tmp7_, NULL, &_inner_error_);
			_tmp6_ = _tmp8_;
			if (G_UNLIKELY (_inner_error_ != NULL)) {
				_g_object_unref0 (file_info);
				_g_object_unref0 (children);
				goto __catch18_g_error;
			}
			_tmp9_ = _tmp6_;
			_tmp6_ = NULL;
			_g_object_unref0 (file_info);
			file_info = _tmp9_;
			_tmp10_ = file_info;
			if (!(_tmp10_ != NULL)) {
				_g_object_unref0 (_tmp6_);
				break;
			}
			_tmp11_ = file_info;
			if (g_file_info_get_is_hidden (_tmp11_)) {
				_g_object_unref0 (_tmp6_);
				continue;
			}
			_tmp12_ = file_info;
			if (g_file_info_get_is_symlink (_tmp12_)) {
				gchar* target = NULL;
				GFileInfo* _tmp13_;
				const gchar* _tmp14_;
				gchar* _tmp15_;
				GFile* symlink = NULL;
				const gchar* _tmp16_;
				GFile* _tmp17_;
				GFileType file_type = 0;
				GFile* _tmp18_;
				GFileType _tmp19_;
				_tmp13_ = file_info;
				_tmp14_ = g_file_info_get_symlink_target (_tmp13_);
				_tmp15_ = g_strdup (_tmp14_);
				target = _tmp15_;
				_tmp16_ = target;
				_tmp17_ = g_file_new_for_path (_tmp16_);
				symlink = _tmp17_;
				_tmp18_ = symlink;
				file_type = g_file_query_file_type (_tmp18_, 0, NULL);
				_tmp19_ = file_type;
				if (_tmp19_ == G_FILE_TYPE_DIRECTORY) {
					const gchar* _tmp20_;
					_tmp20_ = target;
					services_scan_scan_local_files (self, _tmp20_);
				}
				_g_object_unref0 (symlink);
				_g_free0 (target);
			} else {
				GFileInfo* _tmp21_;
				_tmp21_ = file_info;
				if (g_file_info_get_file_type (_tmp21_) == G_FILE_TYPE_DIRECTORY) {
					GFile* _tmp22_;
					gchar* _tmp23_;
					gchar* _tmp24_;
					gboolean _tmp25_;
					GFile* _tmp26_;
					gchar* _tmp27_;
					gchar* _tmp28_;
					gchar* _tmp29_;
					gchar* _tmp30_;
					GFileInfo* _tmp31_;
					const gchar* _tmp32_;
					gchar* _tmp33_;
					gchar* _tmp34_;
					_tmp22_ = directory;
					_tmp23_ = g_file_get_uri (_tmp22_);
					_tmp24_ = _tmp23_;
					_tmp25_ = !g_str_has_prefix (_tmp24_, "file://");
					_g_free0 (_tmp24_);
					if (_tmp25_) {
						g_usleep ((gulong) 1000000);
					}
					_tmp26_ = directory;
					_tmp27_ = g_file_get_uri (_tmp26_);
					_tmp28_ = _tmp27_;
					_tmp29_ = g_strconcat (_tmp28_, "/", NULL);
					_tmp30_ = _tmp29_;
					_tmp31_ = file_info;
					_tmp32_ = g_file_info_get_name (_tmp31_);
					_tmp33_ = g_strconcat (_tmp30_, _tmp32_, NULL);
					_tmp34_ = _tmp33_;
					services_scan_scan_local_files (self, _tmp34_);
					_g_free0 (_tmp34_);
					_g_free0 (_tmp30_);
					_g_free0 (_tmp28_);
				} else {
					gchar* mime_type = NULL;
					GFileInfo* _tmp35_;
					const gchar* _tmp36_;
					gchar* _tmp37_;
					const gchar* _tmp38_;
					_tmp35_ = file_info;
					_tmp36_ = g_file_info_get_content_type (_tmp35_);
					_tmp37_ = g_strdup (_tmp36_);
					mime_type = _tmp37_;
					_tmp38_ = mime_type;
					if (services_scan_is_audio_file (_tmp38_)) {
						GFile* _tmp39_;
						gchar* _tmp40_;
						gchar* _tmp41_;
						gchar* _tmp42_;
						gchar* _tmp43_;
						GFileInfo* _tmp44_;
						const gchar* _tmp45_;
						gchar* _tmp46_;
						gchar* _tmp47_;
						gchar* _tmp48_;
						gchar* _tmp49_;
						_tmp39_ = directory;
						_tmp40_ = g_file_get_uri (_tmp39_);
						_tmp41_ = _tmp40_;
						_tmp42_ = g_strconcat (_tmp41_, "/", NULL);
						_tmp43_ = _tmp42_;
						_tmp44_ = file_info;
						_tmp45_ = g_file_info_get_name (_tmp44_);
						_tmp46_ = string_replace (_tmp45_, "#", "%23");
						_tmp47_ = _tmp46_;
						_tmp48_ = g_strconcat (_tmp43_, _tmp47_, NULL);
						_tmp49_ = _tmp48_;
						services_scan_found_music_file (self, _tmp49_);
						_g_free0 (_tmp49_);
						_g_free0 (_tmp47_);
						_g_free0 (_tmp43_);
						_g_free0 (_tmp41_);
					}
					_g_free0 (mime_type);
				}
			}
			_g_object_unref0 (_tmp6_);
		}
		_tmp50_ = children;
		g_file_enumerator_close (_tmp50_, NULL, &_inner_error_);
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			_g_object_unref0 (file_info);
			_g_object_unref0 (children);
			goto __catch18_g_error;
		}
		_tmp51_ = children;
		g_object_run_dispose ((GObject*) _tmp51_);
		_g_object_unref0 (file_info);
		_g_object_unref0 (children);
	}
	goto __finally18;
	__catch18_g_error:
	{
		GError* err = NULL;
		GError* _tmp52_;
		const gchar* _tmp53_;
		err = _inner_error_;
		_inner_error_ = NULL;
		_tmp52_ = err;
		_tmp53_ = _tmp52_->message;
		g_warning ("Scan.vala:65: %s\n%s", _tmp53_, _data6_->uri);
		_g_error_free0 (err);
	}
	__finally18:
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		_g_object_unref0 (directory);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	_tmp54_ = directory;
	g_object_run_dispose ((GObject*) _tmp54_);
	result = NULL;
	_g_object_unref0 (directory);
	return result;
}


static gpointer
___lambda10__gthread_func (gpointer self)
{
	gpointer result;
	result = __lambda10_ (self);
	block6_data_unref (self);
	return result;
}


void
services_scan_scan_local_files (ServicesScan* self,
                                const gchar* uri)
{
	Block6Data* _data6_;
	gchar* _tmp0_;
	GThread* _tmp1_;
	GThread* _tmp2_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (uri != NULL);
	_data6_ = g_slice_new0 (Block6Data);
	_data6_->_ref_count_ = 1;
	_data6_->self = g_object_ref (self);
	_tmp0_ = g_strdup (uri);
	_g_free0 (_data6_->uri);
	_data6_->uri = _tmp0_;
	_tmp1_ = g_thread_new ("scan_local_files", ___lambda10__gthread_func, block6_data_ref (_data6_));
	_tmp2_ = _tmp1_;
	_g_thread_unref0 (_tmp2_);
	block6_data_unref (_data6_);
	_data6_ = NULL;
}


static Block7Data*
block7_data_ref (Block7Data* _data7_)
{
	g_atomic_int_inc (&_data7_->_ref_count_);
	return _data7_;
}


static void
block7_data_unref (void * _userdata_)
{
	Block7Data* _data7_;
	_data7_ = (Block7Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data7_->_ref_count_)) {
		ServicesScan* self;
		self = _data7_->self;
		_g_free0 (_data7_->uri);
		_g_object_unref0 (self);
		g_slice_free (Block7Data, _data7_);
	}
}


static void*
__lambda11_ (Block7Data* _data7_)
{
	ServicesScan* self;
	void* result = NULL;
	gboolean _tmp0_ = FALSE;
	ServicesDatabase* _tmp1_;
	self = _data7_->self;
	_tmp1_ = byte_database;
	if (services_database_music_file_exists (_tmp1_, _data7_->uri) == FALSE) {
		ServicesDatabase* _tmp2_;
		_tmp2_ = byte_database;
		_tmp0_ = services_database_music_blacklist_exists (_tmp2_, _data7_->uri) == FALSE;
	} else {
		_tmp0_ = FALSE;
	}
	if (_tmp0_) {
		ServicesTagManager* _tmp3_;
		_tmp3_ = byte_tg_manager;
		services_tag_manager_add_discover_uri (_tmp3_, _data7_->uri);
	}
	result = NULL;
	return result;
}


static gpointer
___lambda11__gthread_func (gpointer self)
{
	gpointer result;
	result = __lambda11_ (self);
	block7_data_unref (self);
	return result;
}


void
services_scan_found_music_file (ServicesScan* self,
                                const gchar* uri)
{
	Block7Data* _data7_;
	gchar* _tmp0_;
	gchar* _tmp1_;
	gchar* _tmp2_;
	GThread* _tmp3_;
	GThread* _tmp4_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (uri != NULL);
	_data7_ = g_slice_new0 (Block7Data);
	_data7_->_ref_count_ = 1;
	_data7_->self = g_object_ref (self);
	_tmp0_ = g_strdup (uri);
	_g_free0 (_data7_->uri);
	_data7_->uri = _tmp0_;
	_tmp1_ = g_strdup_printf ("URI: %s\n", _data7_->uri);
	_tmp2_ = _tmp1_;
	g_print ("%s", _tmp2_);
	_g_free0 (_tmp2_);
	_tmp3_ = g_thread_new ("found_local_music_file", ___lambda11__gthread_func, block7_data_ref (_data7_));
	_tmp4_ = _tmp3_;
	_g_thread_unref0 (_tmp4_);
	block7_data_unref (_data7_);
	_data7_ = NULL;
}


static gpointer
_g_object_ref0 (gpointer self)
{
	return self ? g_object_ref (self) : NULL;
}


gchar*
services_scan_choose_folder (ServicesScan* self,
                             MainWindow* window)
{
	gchar* result = NULL;
	gchar* return_value = NULL;
	GtkFileChooserDialog* chooser = NULL;
	GtkFileChooserDialog* _tmp0_;
	GtkFileFilter* filter = NULL;
	GtkFileFilter* _tmp1_;
	GtkFileFilter* _tmp2_;
	GtkFileFilter* _tmp3_;
	GtkFileChooserDialog* _tmp4_;
	GtkFileFilter* _tmp5_;
	GtkFileFilter* _tmp6_;
	GtkFileChooserDialog* _tmp7_;
	GtkFileChooserDialog* _tmp12_;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (window != NULL, NULL);
	return_value = NULL;
	_tmp0_ = (GtkFileChooserDialog*) gtk_file_chooser_dialog_new (_ ("Select a folder."), (GtkWindow*) window, GTK_FILE_CHOOSER_ACTION_SELECT_FOLDER, _ ("Cancel"), GTK_RESPONSE_CANCEL, _ ("Open"), GTK_RESPONSE_ACCEPT, NULL);
	g_object_ref_sink (_tmp0_);
	chooser = _tmp0_;
	_tmp1_ = gtk_file_filter_new ();
	g_object_ref_sink (_tmp1_);
	filter = _tmp1_;
	_tmp2_ = filter;
	gtk_file_filter_set_name (_tmp2_, _ ("Folder"));
	_tmp3_ = filter;
	gtk_file_filter_add_mime_type (_tmp3_, "inode/directory");
	_tmp4_ = chooser;
	_tmp5_ = filter;
	_tmp6_ = _g_object_ref0 (_tmp5_);
	gtk_file_chooser_add_filter ((GtkFileChooser*) _tmp4_, _tmp6_);
	_tmp7_ = chooser;
	if (gtk_dialog_run ((GtkDialog*) _tmp7_) == ((gint) GTK_RESPONSE_ACCEPT)) {
		GtkFileChooserDialog* _tmp8_;
		GFile* _tmp9_;
		GFile* _tmp10_;
		gchar* _tmp11_;
		_tmp8_ = chooser;
		_tmp9_ = gtk_file_chooser_get_file ((GtkFileChooser*) _tmp8_);
		_tmp10_ = _tmp9_;
		_tmp11_ = g_file_get_uri (_tmp10_);
		_g_free0 (return_value);
		return_value = _tmp11_;
		_g_object_unref0 (_tmp10_);
	}
	_tmp12_ = chooser;
	gtk_widget_destroy ((GtkWidget*) _tmp12_);
	result = return_value;
	_g_object_unref0 (filter);
	_g_object_unref0 (chooser);
	return result;
}


static Block8Data*
block8_data_ref (Block8Data* _data8_)
{
	g_atomic_int_inc (&_data8_->_ref_count_);
	return _data8_;
}


static void
block8_data_unref (void * _userdata_)
{
	Block8Data* _data8_;
	_data8_ = (Block8Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data8_->_ref_count_)) {
		ServicesScan* self;
		self = _data8_->self;
		_g_object_unref0 (_data8_->artist);
		_g_object_unref0 (_data8_->album);
		_g_object_unref0 (_data8_->track);
		_g_object_unref0 (self);
		g_slice_free (Block8Data, _data8_);
	}
}


static void*
__lambda15_ (Block8Data* _data8_)
{
	ServicesScan* self;
	void* result = NULL;
	ServicesDatabase* _tmp0_;
	const gchar* _tmp1_;
	gchar* _tmp2_;
	ServicesDatabase* _tmp3_;
	const gchar* _tmp4_;
	gchar* _tmp5_;
	const gchar* _tmp6_;
	gchar* _tmp7_;
	ServicesDatabase* _tmp8_;
	self = _data8_->self;
	_tmp0_ = byte_database;
	_data8_->album->artist_id = services_database_insert_artist_if_not_exists (_tmp0_, _data8_->artist);
	_tmp1_ = _data8_->artist->name;
	_tmp2_ = g_strdup (_tmp1_);
	_g_free0 (_data8_->album->artist_name);
	_data8_->album->artist_name = _tmp2_;
	_tmp3_ = byte_database;
	_data8_->track->album_id = services_database_insert_album_if_not_exists (_tmp3_, _data8_->album);
	_tmp4_ = _data8_->artist->name;
	_tmp5_ = g_strdup (_tmp4_);
	_g_free0 (_data8_->track->artist_name);
	_data8_->track->artist_name = _tmp5_;
	_tmp6_ = _data8_->album->title;
	_tmp7_ = g_strdup (_tmp6_);
	_g_free0 (_data8_->track->album_title);
	_data8_->track->album_title = _tmp7_;
	_tmp8_ = byte_database;
	services_database_insert_track (_tmp8_, _data8_->track);
	result = NULL;
	return result;
}


static gpointer
___lambda15__gthread_func (gpointer self)
{
	gpointer result;
	result = __lambda15_ (self);
	block8_data_unref (self);
	return result;
}


void
services_scan_discovered_new_local_item (ServicesScan* self,
                                         ObjectsArtist* artist,
                                         ObjectsAlbum* album,
                                         ObjectsTrack* track)
{
	Block8Data* _data8_;
	ObjectsArtist* _tmp0_;
	ObjectsAlbum* _tmp1_;
	ObjectsTrack* _tmp2_;
	gint _tmp3_;
	gint _tmp4_;
	gint _tmp5_;
	GThread* _tmp6_;
	GThread* _tmp7_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (artist != NULL);
	g_return_if_fail (album != NULL);
	g_return_if_fail (track != NULL);
	_data8_ = g_slice_new0 (Block8Data);
	_data8_->_ref_count_ = 1;
	_data8_->self = g_object_ref (self);
	_tmp0_ = _g_object_ref0 (artist);
	_g_object_unref0 (_data8_->artist);
	_data8_->artist = _tmp0_;
	_tmp1_ = _g_object_ref0 (album);
	_g_object_unref0 (_data8_->album);
	_data8_->album = _tmp1_;
	_tmp2_ = _g_object_ref0 (track);
	_g_object_unref0 (_data8_->track);
	_data8_->track = _tmp2_;
	_tmp3_ = self->counter;
	if (_tmp3_ == 0) {
		g_signal_emit (self, services_scan_signals[SERVICES_SCAN_SYNC_STARTED_SIGNAL], 0);
		self->is_sync = TRUE;
	}
	_tmp4_ = self->counter;
	self->counter = _tmp4_ + 1;
	_tmp5_ = self->counter_max;
	self->counter_max = _tmp5_ + 1;
	_tmp6_ = g_thread_new ("discovered_new_local_item", ___lambda15__gthread_func, block8_data_ref (_data8_));
	_tmp7_ = _tmp6_;
	_g_thread_unref0 (_tmp7_);
	block8_data_unref (_data8_);
	_data8_ = NULL;
}


static gboolean
string_contains (const gchar* self,
                 const gchar* needle)
{
	gboolean result = FALSE;
	gchar* _tmp0_;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (needle != NULL, FALSE);
	_tmp0_ = strstr ((gchar*) self, (gchar*) needle);
	result = _tmp0_ != NULL;
	return result;
}


gboolean
services_scan_is_audio_file (const gchar* mime_type)
{
	gboolean result = FALSE;
	gboolean _tmp0_ = FALSE;
	gboolean _tmp1_ = FALSE;
	g_return_val_if_fail (mime_type != NULL, FALSE);
	if (g_str_has_prefix (mime_type, "audio/")) {
		_tmp1_ = !string_contains (mime_type, "x-mpegurl");
	} else {
		_tmp1_ = FALSE;
	}
	if (_tmp1_) {
		_tmp0_ = !string_contains (mime_type, "x-scpls");
	} else {
		_tmp0_ = FALSE;
	}
	result = _tmp0_;
	return result;
}


ServicesScan*
services_scan_construct (GType object_type)
{
	ServicesScan * self = NULL;
	self = (ServicesScan*) g_object_new (object_type, NULL);
	return self;
}


ServicesScan*
services_scan_new (void)
{
	return services_scan_construct (SERVICES_TYPE_SCAN);
}


static void
_services_scan_discovered_new_local_item_services_tag_manager_discovered_new_item (ServicesTagManager* _sender,
                                                                                   ObjectsArtist* artist,
                                                                                   ObjectsAlbum* album,
                                                                                   ObjectsTrack* track,
                                                                                   gpointer self)
{
	services_scan_discovered_new_local_item ((ServicesScan*) self, artist, album, track);
}


static gboolean
__lambda17_ (ServicesScan* self)
{
	gboolean result = FALSE;
	gint _tmp0_;
	gint _tmp1_;
	gint _tmp2_;
	gchar* _tmp3_;
	gchar* _tmp4_;
	gint _tmp5_;
	gint _tmp6_;
	gint _tmp7_;
	gint _tmp8_;
	_tmp0_ = self->counter;
	self->counter = _tmp0_ - 1;
	_tmp1_ = self->counter;
	_tmp2_ = self->counter_max;
	_tmp3_ = g_strdup_printf ("%i/%i\n", _tmp1_, _tmp2_);
	_tmp4_ = _tmp3_;
	g_print ("%s", _tmp4_);
	_g_free0 (_tmp4_);
	_tmp5_ = self->counter_max;
	_tmp6_ = self->counter;
	_tmp7_ = self->counter_max;
	g_signal_emit (self, services_scan_signals[SERVICES_SCAN_SYNC_PROGRESS_SIGNAL], 0, (((gdouble) _tmp5_) - ((gdouble) _tmp6_)) / ((gdouble) _tmp7_));
	_tmp8_ = self->counter;
	if (_tmp8_ <= 0) {
		g_signal_emit (self, services_scan_signals[SERVICES_SCAN_SYNC_FINISHED_SIGNAL], 0);
		self->is_sync = FALSE;
		self->counter_max = 0;
	}
	result = FALSE;
	return result;
}


static gboolean
___lambda17__gsource_func (gpointer self)
{
	gboolean result;
	result = __lambda17_ ((ServicesScan*) self);
	return result;
}


static void
_services_scan___lambda16_ (ServicesScan* self)
{
	g_idle_add_full (G_PRIORITY_DEFAULT_IDLE, ___lambda17__gsource_func, g_object_ref (self), g_object_unref);
}


static void
__services_scan___lambda16__services_database_adden_new_track (ServicesDatabase* _sender,
                                                               ObjectsTrack* track,
                                                               gpointer self)
{
	_services_scan___lambda16_ ((ServicesScan*) self);
}


static GObject *
services_scan_constructor (GType type,
                           guint n_construct_properties,
                           GObjectConstructParam * construct_properties)
{
	GObject * obj;
	GObjectClass * parent_class;
	ServicesScan * self;
	ServicesTagManager* _tmp0_;
	ServicesDatabase* _tmp1_;
	parent_class = G_OBJECT_CLASS (services_scan_parent_class);
	obj = parent_class->constructor (type, n_construct_properties, construct_properties);
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, SERVICES_TYPE_SCAN, ServicesScan);
	_tmp0_ = byte_tg_manager;
	g_signal_connect_object (_tmp0_, "discovered-new-item", (GCallback) _services_scan_discovered_new_local_item_services_tag_manager_discovered_new_item, self, 0);
	_tmp1_ = byte_database;
	g_signal_connect_object (_tmp1_, "adden-new-track", (GCallback) __services_scan___lambda16__services_database_adden_new_track, self, 0);
	return obj;
}


static void
services_scan_class_init (ServicesScanClass * klass)
{
	services_scan_parent_class = g_type_class_peek_parent (klass);
	G_OBJECT_CLASS (klass)->constructor = services_scan_constructor;
	G_OBJECT_CLASS (klass)->finalize = services_scan_finalize;
	services_scan_signals[SERVICES_SCAN_SYNC_STARTED_SIGNAL] = g_signal_new ("sync-started", SERVICES_TYPE_SCAN, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0);
	services_scan_signals[SERVICES_SCAN_SYNC_FINISHED_SIGNAL] = g_signal_new ("sync-finished", SERVICES_TYPE_SCAN, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0);
	services_scan_signals[SERVICES_SCAN_SYNC_PROGRESS_SIGNAL] = g_signal_new ("sync-progress", SERVICES_TYPE_SCAN, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__DOUBLE, G_TYPE_NONE, 1, G_TYPE_DOUBLE);
}


static void
services_scan_instance_init (ServicesScan * self)
{
	self->counter = 0;
	self->counter_max = 0;
	self->is_sync = FALSE;
}


static void
services_scan_finalize (GObject * obj)
{
	ServicesScan * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, SERVICES_TYPE_SCAN, ServicesScan);
	G_OBJECT_CLASS (services_scan_parent_class)->finalize (obj);
}


GType
services_scan_get_type (void)
{
	static volatile gsize services_scan_type_id__volatile = 0;
	if (g_once_init_enter (&services_scan_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (ServicesScanClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) services_scan_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (ServicesScan), 0, (GInstanceInitFunc) services_scan_instance_init, NULL };
		GType services_scan_type_id;
		services_scan_type_id = g_type_register_static (G_TYPE_OBJECT, "ServicesScan", &g_define_type_info, 0);
		g_once_init_leave (&services_scan_type_id__volatile, services_scan_type_id);
	}
	return services_scan_type_id__volatile;
}



