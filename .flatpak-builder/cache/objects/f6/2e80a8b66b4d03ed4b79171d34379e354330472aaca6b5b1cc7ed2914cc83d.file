/* Database.c generated by valac 0.40.11, the Vala compiler
 * generated from Database.vala, do not modify */



#include <glib.h>
#include <glib-object.h>
#include <sqlite3.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <gtk/gtk.h>
#include <gee.h>
#include <gio/gio.h>
#include <glib/gstdio.h>
#include <glib/gi18n-lib.h>


#define SERVICES_TYPE_DATABASE (services_database_get_type ())
#define SERVICES_DATABASE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SERVICES_TYPE_DATABASE, ServicesDatabase))
#define SERVICES_DATABASE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SERVICES_TYPE_DATABASE, ServicesDatabaseClass))
#define SERVICES_IS_DATABASE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SERVICES_TYPE_DATABASE))
#define SERVICES_IS_DATABASE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SERVICES_TYPE_DATABASE))
#define SERVICES_DATABASE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SERVICES_TYPE_DATABASE, ServicesDatabaseClass))

typedef struct _ServicesDatabase ServicesDatabase;
typedef struct _ServicesDatabaseClass ServicesDatabaseClass;
typedef struct _ServicesDatabasePrivate ServicesDatabasePrivate;
enum  {
	SERVICES_DATABASE_0_PROPERTY,
	SERVICES_DATABASE_NUM_PROPERTIES
};
static GParamSpec* services_database_properties[SERVICES_DATABASE_NUM_PROPERTIES];
#define _sqlite3_close0(var) ((var == NULL) ? NULL : (var = (sqlite3_close (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))
#define _sqlite3_finalize0(var) ((var == NULL) ? NULL : (var = (sqlite3_finalize (var), NULL)))

#define OBJECTS_TYPE_ARTIST (objects_artist_get_type ())
#define OBJECTS_ARTIST(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), OBJECTS_TYPE_ARTIST, ObjectsArtist))
#define OBJECTS_ARTIST_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), OBJECTS_TYPE_ARTIST, ObjectsArtistClass))
#define OBJECTS_IS_ARTIST(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), OBJECTS_TYPE_ARTIST))
#define OBJECTS_IS_ARTIST_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), OBJECTS_TYPE_ARTIST))
#define OBJECTS_ARTIST_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), OBJECTS_TYPE_ARTIST, ObjectsArtistClass))

typedef struct _ObjectsArtist ObjectsArtist;
typedef struct _ObjectsArtistClass ObjectsArtistClass;
typedef struct _ObjectsArtistPrivate ObjectsArtistPrivate;

#define OBJECTS_TYPE_ALBUM (objects_album_get_type ())
#define OBJECTS_ALBUM(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), OBJECTS_TYPE_ALBUM, ObjectsAlbum))
#define OBJECTS_ALBUM_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), OBJECTS_TYPE_ALBUM, ObjectsAlbumClass))
#define OBJECTS_IS_ALBUM(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), OBJECTS_TYPE_ALBUM))
#define OBJECTS_IS_ALBUM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), OBJECTS_TYPE_ALBUM))
#define OBJECTS_ALBUM_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), OBJECTS_TYPE_ALBUM, ObjectsAlbumClass))

typedef struct _ObjectsAlbum ObjectsAlbum;
typedef struct _ObjectsAlbumClass ObjectsAlbumClass;
typedef struct _ObjectsAlbumPrivate ObjectsAlbumPrivate;

#define OBJECTS_TYPE_TRACK (objects_track_get_type ())
#define OBJECTS_TRACK(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), OBJECTS_TYPE_TRACK, ObjectsTrack))
#define OBJECTS_TRACK_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), OBJECTS_TYPE_TRACK, ObjectsTrackClass))
#define OBJECTS_IS_TRACK(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), OBJECTS_TYPE_TRACK))
#define OBJECTS_IS_TRACK_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), OBJECTS_TYPE_TRACK))
#define OBJECTS_TRACK_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), OBJECTS_TYPE_TRACK, ObjectsTrackClass))

typedef struct _ObjectsTrack ObjectsTrack;
typedef struct _ObjectsTrackClass ObjectsTrackClass;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
typedef struct _Block3Data Block3Data;
typedef struct _ObjectsTrackPrivate ObjectsTrackPrivate;

#define SERVICES_TYPE_COVER_IMPORT (services_cover_import_get_type ())
#define SERVICES_COVER_IMPORT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SERVICES_TYPE_COVER_IMPORT, ServicesCoverImport))
#define SERVICES_COVER_IMPORT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SERVICES_TYPE_COVER_IMPORT, ServicesCoverImportClass))
#define SERVICES_IS_COVER_IMPORT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SERVICES_TYPE_COVER_IMPORT))
#define SERVICES_IS_COVER_IMPORT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SERVICES_TYPE_COVER_IMPORT))
#define SERVICES_COVER_IMPORT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SERVICES_TYPE_COVER_IMPORT, ServicesCoverImportClass))

typedef struct _ServicesCoverImport ServicesCoverImport;
typedef struct _ServicesCoverImportClass ServicesCoverImportClass;
#define _g_date_time_unref0(var) ((var == NULL) ? NULL : (var = (g_date_time_unref (var), NULL)))

#define OBJECTS_TYPE_RADIO (objects_radio_get_type ())
#define OBJECTS_RADIO(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), OBJECTS_TYPE_RADIO, ObjectsRadio))
#define OBJECTS_RADIO_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), OBJECTS_TYPE_RADIO, ObjectsRadioClass))
#define OBJECTS_IS_RADIO(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), OBJECTS_TYPE_RADIO))
#define OBJECTS_IS_RADIO_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), OBJECTS_TYPE_RADIO))
#define OBJECTS_RADIO_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), OBJECTS_TYPE_RADIO, ObjectsRadioClass))

typedef struct _ObjectsRadio ObjectsRadio;
typedef struct _ObjectsRadioClass ObjectsRadioClass;

#define TYPE_UTILS (utils_get_type ())
#define UTILS(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_UTILS, Utils))
#define UTILS_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_UTILS, UtilsClass))
#define IS_UTILS(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_UTILS))
#define IS_UTILS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_UTILS))
#define UTILS_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_UTILS, UtilsClass))

typedef struct _Utils Utils;
typedef struct _UtilsClass UtilsClass;

#define OBJECTS_TYPE_PLAYLIST (objects_playlist_get_type ())
#define OBJECTS_PLAYLIST(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), OBJECTS_TYPE_PLAYLIST, ObjectsPlaylist))
#define OBJECTS_PLAYLIST_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), OBJECTS_TYPE_PLAYLIST, ObjectsPlaylistClass))
#define OBJECTS_IS_PLAYLIST(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), OBJECTS_TYPE_PLAYLIST))
#define OBJECTS_IS_PLAYLIST_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), OBJECTS_TYPE_PLAYLIST))
#define OBJECTS_PLAYLIST_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), OBJECTS_TYPE_PLAYLIST, ObjectsPlaylistClass))

typedef struct _ObjectsPlaylist ObjectsPlaylist;
typedef struct _ObjectsPlaylistClass ObjectsPlaylistClass;
typedef struct _ObjectsPlaylistPrivate ObjectsPlaylistPrivate;
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
typedef struct _UtilsPrivate UtilsPrivate;
enum  {
	SERVICES_DATABASE_ADDEN_NEW_TRACK_SIGNAL,
	SERVICES_DATABASE_ADDED_NEW_ARTIST_SIGNAL,
	SERVICES_DATABASE_ADDED_NEW_ALBUM_SIGNAL,
	SERVICES_DATABASE_ADDEN_NEW_RADIO_SIGNAL,
	SERVICES_DATABASE_ADDEN_NEW_PLAYLIST_SIGNAL,
	SERVICES_DATABASE_REMOVED_TRACK_SIGNAL,
	SERVICES_DATABASE_REMOVED_PLAYLIST_SIGNAL,
	SERVICES_DATABASE_UPDATED_ALBUM_COVER_SIGNAL,
	SERVICES_DATABASE_UPDATED_TRACK_COVER_SIGNAL,
	SERVICES_DATABASE_UPDATED_PLAYLIST_COVER_SIGNAL,
	SERVICES_DATABASE_UPDATED_TRACK_FAVORITE_SIGNAL,
	SERVICES_DATABASE_UPDATED_PLAYLIST_SIGNAL,
	SERVICES_DATABASE_RESET_LIBRARY_SIGNAL,
	SERVICES_DATABASE_NUM_SIGNALS
};
static guint services_database_signals[SERVICES_DATABASE_NUM_SIGNALS] = {0};
#define _vala_assert(expr, msg) if G_LIKELY (expr) ; else g_assertion_message_expr (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, msg);
#define _vala_return_if_fail(expr, msg) if G_LIKELY (expr) ; else { g_return_if_fail_warning (G_LOG_DOMAIN, G_STRFUNC, msg); return; }
#define _vala_return_val_if_fail(expr, msg, val) if G_LIKELY (expr) ; else { g_return_if_fail_warning (G_LOG_DOMAIN, G_STRFUNC, msg); return val; }
#define _vala_warn_if_fail(expr, msg) if G_LIKELY (expr) ; else g_warn_message (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, msg);

struct _ServicesDatabase {
	GObject parent_instance;
	ServicesDatabasePrivate * priv;
};

struct _ServicesDatabaseClass {
	GObjectClass parent_class;
};

struct _ServicesDatabasePrivate {
	sqlite3* db;
	gchar* db_path;
};

struct _ObjectsArtist {
	GObject parent_instance;
	ObjectsArtistPrivate * priv;
	gint id;
	gchar* name;
};

struct _ObjectsArtistClass {
	GObjectClass parent_class;
};

struct _ObjectsAlbum {
	GObject parent_instance;
	ObjectsAlbumPrivate * priv;
	gint id;
	gint artist_id;
	gchar* artist_name;
	gint year;
	gchar* title;
	gchar* genre;
};

struct _ObjectsAlbumClass {
	GObjectClass parent_class;
};

struct _Block3Data {
	int _ref_count_;
	ServicesDatabase* self;
	ObjectsTrack* track;
};

struct _ObjectsTrack {
	GObject parent_instance;
	ObjectsTrackPrivate * priv;
	gint track_order;
	gint id;
	gint album_id;
	gint track;
	gint disc;
	gint play_count;
	gint is_favorite;
	gint bitrate;
	gint bpm;
	gint rating;
	gint samplerate;
	gint channels;
	gint year;
	gint playlist;
	guint64 duration;
	gchar* path;
	gchar* title;
	gchar* favorite_added;
	gchar* last_played;
	gchar* album_title;
	gchar* artist_name;
	gchar* composer;
	gchar* grouping;
	gchar* comment;
	gchar* lyrics;
	gchar* genre;
	gchar* album_artist;
	gchar* date_added;
};

struct _ObjectsTrackClass {
	GObjectClass parent_class;
};

struct _ObjectsPlaylist {
	GObject parent_instance;
	ObjectsPlaylistPrivate * priv;
	gint id;
	gchar* title;
	gchar* note;
	gchar* date_added;
	gchar* date_updated;
	gint num_tracks;
};

struct _ObjectsPlaylistClass {
	GObjectClass parent_class;
};

struct _Utils {
	GObject parent_instance;
	UtilsPrivate * priv;
	gchar* MAIN_FOLDER;
	gchar* COVER_FOLDER;
};

struct _UtilsClass {
	GObjectClass parent_class;
};


static gpointer services_database_parent_class = NULL;
extern ServicesCoverImport* byte_cover_import;
extern Utils* byte_utils;
extern ServicesDatabase* byte_database;

GType services_database_get_type (void) G_GNUC_CONST;
#define SERVICES_DATABASE_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), SERVICES_TYPE_DATABASE, ServicesDatabasePrivate))
ServicesDatabase* services_database_new (gboolean skip_tables);
ServicesDatabase* services_database_construct (GType object_type,
                                               gboolean skip_tables);
static gint services_database_create_tables (ServicesDatabase* self);
gboolean services_database_music_file_exists (ServicesDatabase* self,
                                              const gchar* uri);
gboolean services_database_music_blacklist_exists (ServicesDatabase* self,
                                                   const gchar* uri);
gboolean services_database_radio_exists (ServicesDatabase* self,
                                         const gchar* url);
gboolean services_database_is_database_empty (ServicesDatabase* self);
GType objects_artist_get_type (void) G_GNUC_CONST;
gint services_database_get_id_if_artist_exists (ServicesDatabase* self,
                                                ObjectsArtist* artist);
gint services_database_insert_artist_if_not_exists (ServicesDatabase* self,
                                                    ObjectsArtist* artist);
GType objects_album_get_type (void) G_GNUC_CONST;
gint services_database_get_id_if_album_exists (ServicesDatabase* self,
                                               ObjectsAlbum* album);
gint services_database_insert_album_if_not_exists (ServicesDatabase* self,
                                                   ObjectsAlbum* album);
GType objects_track_get_type (void) G_GNUC_CONST;
void services_database_insert_track (ServicesDatabase* self,
                                     ObjectsTrack* track);
static Block3Data* block3_data_ref (Block3Data* _data3_);
static void block3_data_unref (void * _userdata_);
static gboolean ___lambda12_ (Block3Data* _data3_);
GType services_cover_import_get_type (void) G_GNUC_CONST;
void services_cover_import_import (ServicesCoverImport* self,
                                   ObjectsTrack* track);
static gboolean ____lambda12__gsource_func (gpointer self);
ObjectsTrack* services_database_get_track_by_id (ServicesDatabase* self,
                                                 gint id);
ObjectsTrack* objects_track_new (gint track_order,
                                 gint id,
                                 gint album_id,
                                 gint track,
                                 gint disc,
                                 gint play_count,
                                 gint is_favorite,
                                 gint bitrate,
                                 gint bpm,
                                 gint rating,
                                 gint samplerate,
                                 gint channels,
                                 gint year,
                                 gint playlist,
                                 guint64 duration,
                                 const gchar* path,
                                 const gchar* title,
                                 const gchar* favorite_added,
                                 const gchar* last_played,
                                 const gchar* album_title,
                                 const gchar* artist_name,
                                 const gchar* composer,
                                 const gchar* grouping,
                                 const gchar* comment,
                                 const gchar* lyrics,
                                 const gchar* genre,
                                 const gchar* album_artist,
                                 const gchar* date_added);
ObjectsTrack* objects_track_construct (GType object_type,
                                       gint track_order,
                                       gint id,
                                       gint album_id,
                                       gint track,
                                       gint disc,
                                       gint play_count,
                                       gint is_favorite,
                                       gint bitrate,
                                       gint bpm,
                                       gint rating,
                                       gint samplerate,
                                       gint channels,
                                       gint year,
                                       gint playlist,
                                       guint64 duration,
                                       const gchar* path,
                                       const gchar* title,
                                       const gchar* favorite_added,
                                       const gchar* last_played,
                                       const gchar* album_title,
                                       const gchar* artist_name,
                                       const gchar* composer,
                                       const gchar* grouping,
                                       const gchar* comment,
                                       const gchar* lyrics,
                                       const gchar* genre,
                                       const gchar* album_artist,
                                       const gchar* date_added);
GeeArrayList* services_database_get_all_albums_by_artist (ServicesDatabase* self,
                                                          gint id);
ObjectsAlbum* objects_album_new (gint id,
                                 gint artist_id,
                                 const gchar* artist_name,
                                 gint year,
                                 const gchar* title,
                                 const gchar* genre);
ObjectsAlbum* objects_album_construct (GType object_type,
                                       gint id,
                                       gint artist_id,
                                       const gchar* artist_name,
                                       gint year,
                                       const gchar* title,
                                       const gchar* genre);
GeeArrayList* services_database_get_all_albums (ServicesDatabase* self);
GeeArrayList* services_database_get_all_albums_order_by (ServicesDatabase* self,
                                                         gint item,
                                                         gboolean is_reverse);
GeeArrayList* services_database_get_all_albums_search (ServicesDatabase* self,
                                                       const gchar* search_text);
GeeArrayList* services_database_get_tracks_recently_added (ServicesDatabase* self);
GeeArrayList* services_database_get_all_tracks_by_artist (ServicesDatabase* self,
                                                          gint id);
GeeArrayList* services_database_get_all_tracks_order_by (ServicesDatabase* self,
                                                         gint item,
                                                         gboolean is_reverse);
GeeArrayList* services_database_get_all_tracks_favorites (ServicesDatabase* self);
GeeArrayList* services_database_get_all_tracks_favorites_search (ServicesDatabase* self,
                                                                 const gchar* search_text);
GeeArrayList* services_database_get_all_tracks_search (ServicesDatabase* self,
                                                       const gchar* search_text);
GeeArrayList* services_database_get_all_tracks_by_album (ServicesDatabase* self,
                                                         gint id);
GeeArrayList* services_database_get_all_tracks_by_playlist (ServicesDatabase* self,
                                                            gint id,
                                                            gint sort,
                                                            gboolean is_reverse);
GeeArrayList* services_database_get_all_artists (ServicesDatabase* self);
ObjectsArtist* objects_artist_new (gint id,
                                   const gchar* name);
ObjectsArtist* objects_artist_construct (GType object_type,
                                         gint id,
                                         const gchar* name);
GeeArrayList* services_database_get_all_artists_search (ServicesDatabase* self,
                                                        const gchar* search_text);
gint services_database_get_tracks_number (ServicesDatabase* self);
GType objects_radio_get_type (void) G_GNUC_CONST;
void services_database_insert_radio (ServicesDatabase* self,
                                     ObjectsRadio* radio);
const gchar* objects_radio_get_name (ObjectsRadio* self);
const gchar* objects_radio_get_url (ObjectsRadio* self);
const gchar* objects_radio_get_homepage (ObjectsRadio* self);
const gchar* objects_radio_get_tags (ObjectsRadio* self);
const gchar* objects_radio_get_favicon (ObjectsRadio* self);
const gchar* objects_radio_get_country (ObjectsRadio* self);
const gchar* objects_radio_get_state (ObjectsRadio* self);
void objects_radio_set_id (ObjectsRadio* self,
                           gint value);
GType utils_get_type (void) G_GNUC_CONST;
void utils_download_image (Utils* self,
                           const gchar* type,
                           gint id,
                           const gchar* url);
gint objects_radio_get_id (ObjectsRadio* self);
GeeArrayList* services_database_get_all_radios (ServicesDatabase* self);
ObjectsRadio* objects_radio_new (void);
ObjectsRadio* objects_radio_construct (GType object_type);
void objects_radio_set_name (ObjectsRadio* self,
                             const gchar* value);
void objects_radio_set_url (ObjectsRadio* self,
                            const gchar* value);
void objects_radio_set_homepage (ObjectsRadio* self,
                                 const gchar* value);
void objects_radio_set_tags (ObjectsRadio* self,
                             const gchar* value);
void objects_radio_set_favicon (ObjectsRadio* self,
                                const gchar* value);
void objects_radio_set_country (ObjectsRadio* self,
                                const gchar* value);
void objects_radio_set_state (ObjectsRadio* self,
                              const gchar* value);
GType objects_playlist_get_type (void) G_GNUC_CONST;
GeeArrayList* services_database_get_all_playlists (ServicesDatabase* self);
ObjectsPlaylist* objects_playlist_new (gint id,
                                       const gchar* title,
                                       const gchar* note,
                                       const gchar* date_added,
                                       const gchar* date_updated,
                                       gint num_tracks);
ObjectsPlaylist* objects_playlist_construct (GType object_type,
                                             gint id,
                                             const gchar* title,
                                             const gchar* note,
                                             const gchar* date_added,
                                             const gchar* date_updated,
                                             gint num_tracks);
gint services_database_insert_playlist (ServicesDatabase* self,
                                        ObjectsPlaylist* playlist);
void services_database_insert_track_into_playlist (ServicesDatabase* self,
                                                   ObjectsPlaylist* playlist,
                                                   gint track_id);
void services_database_update_playlist (ServicesDatabase* self,
                                        ObjectsPlaylist* playlist);
void services_database_add_track_count (ServicesDatabase* self,
                                        ObjectsTrack* track);
void services_database_set_track_favorite (ServicesDatabase* self,
                                           ObjectsTrack* track,
                                           gint favorite);
gint services_database_is_track_favorite (ServicesDatabase* self,
                                          ObjectsTrack* track);
void services_database_remove_from_library (ServicesDatabase* self,
                                            ObjectsTrack* track);
gboolean services_database_remove_radio_from_library (ServicesDatabase* self,
                                                      ObjectsRadio* radio);
gboolean services_database_remove_playlist_from_library (ServicesDatabase* self,
                                                         ObjectsPlaylist* playlist);
gboolean services_database_remove_from_playlist (ServicesDatabase* self,
                                                 ObjectsTrack* track);
void services_database_reset_all_library (ServicesDatabase* self);
ObjectsPlaylist* services_database_get_playlist_by_title (ServicesDatabase* self,
                                                          const gchar* title);
ObjectsPlaylist* services_database_create_new_playlist (ServicesDatabase* self);
static void g_cclosure_user_marshal_VOID__OBJECT_INT (GClosure * closure,
                                               GValue * return_value,
                                               guint n_param_values,
                                               const GValue * param_values,
                                               gpointer invocation_hint,
                                               gpointer marshal_data);
static void services_database_finalize (GObject * obj);


ServicesDatabase*
services_database_construct (GType object_type,
                             gboolean skip_tables)
{
	ServicesDatabase * self = NULL;
	gint rc = 0;
	const gchar* _tmp0_;
	gchar* _tmp1_;
	const gchar* _tmp6_;
	sqlite3* _tmp7_ = NULL;
	gint _tmp8_;
	gint _tmp9_;
	self = (ServicesDatabase*) g_object_new (object_type, NULL);
	rc = 0;
	_tmp0_ = g_get_home_dir ();
	_tmp1_ = g_strconcat (_tmp0_, "/.local/share/com.github.alainm23.byte/database.db", NULL);
	_g_free0 (self->priv->db_path);
	self->priv->db_path = _tmp1_;
	if (!skip_tables) {
		if (services_database_create_tables (self) != SQLITE_OK) {
			FILE* _tmp2_;
			gint _tmp3_;
			sqlite3* _tmp4_;
			const gchar* _tmp5_;
			_tmp2_ = stderr;
			_tmp3_ = rc;
			_tmp4_ = self->priv->db;
			_tmp5_ = sqlite3_errmsg (_tmp4_);
			fprintf (_tmp2_, "Error creating db table: %d, %s\n", _tmp3_, _tmp5_);
			gtk_main_quit ();
		}
	}
	_tmp6_ = self->priv->db_path;
	_tmp8_ = sqlite3_open (_tmp6_, &_tmp7_);
	_sqlite3_close0 (self->priv->db);
	self->priv->db = _tmp7_;
	rc = _tmp8_;
	_tmp9_ = rc;
	if (_tmp9_ != SQLITE_OK) {
		FILE* _tmp10_;
		gint _tmp11_;
		sqlite3* _tmp12_;
		const gchar* _tmp13_;
		_tmp10_ = stderr;
		_tmp11_ = rc;
		_tmp12_ = self->priv->db;
		_tmp13_ = sqlite3_errmsg (_tmp12_);
		fprintf (_tmp10_, "Can't open database: %d, %s\n", _tmp11_, _tmp13_);
		gtk_main_quit ();
	}
	return self;
}


ServicesDatabase*
services_database_new (gboolean skip_tables)
{
	return services_database_construct (SERVICES_TYPE_DATABASE, skip_tables);
}


static gint
_sqlite3_exec (sqlite3* self,
               const gchar* sql,
               sqlite3_callback callback,
               gpointer callback_target,
               gchar* * errmsg)
{
	gchar* _vala_errmsg = NULL;
	gint result = 0;
	const gchar* sqlite_errmsg = NULL;
	gint ec = 0;
	const gchar* _tmp0_ = NULL;
	gint _tmp1_;
	const gchar* _tmp4_;
	g_return_val_if_fail (self != NULL, 0);
	g_return_val_if_fail (sql != NULL, 0);
	_tmp1_ = sqlite3_exec (self, sql, callback, callback_target, (char**) (&_tmp0_));
	sqlite_errmsg = _tmp0_;
	ec = _tmp1_;
	if ((&_vala_errmsg) != NULL) {
		const gchar* _tmp2_;
		gchar* _tmp3_;
		_tmp2_ = sqlite_errmsg;
		_tmp3_ = g_strdup (_tmp2_);
		_g_free0 (_vala_errmsg);
		_vala_errmsg = _tmp3_;
	}
	_tmp4_ = sqlite_errmsg;
	sqlite3_free ((void*) _tmp4_);
	result = ec;
	if (errmsg) {
		*errmsg = _vala_errmsg;
	} else {
		_g_free0 (_vala_errmsg);
	}
	return result;
}


static gint
services_database_create_tables (ServicesDatabase* self)
{
	gint result = 0;
	gint rc = 0;
	const gchar* _tmp0_;
	sqlite3* _tmp1_ = NULL;
	gint _tmp2_;
	gint _tmp3_;
	sqlite3* _tmp8_;
	gint _tmp9_;
	sqlite3* _tmp10_;
	gint _tmp11_;
	sqlite3* _tmp12_;
	gint _tmp13_;
	sqlite3* _tmp14_;
	gint _tmp15_;
	sqlite3* _tmp16_;
	gint _tmp17_;
	sqlite3* _tmp18_;
	gint _tmp19_;
	sqlite3* _tmp20_;
	gint _tmp21_;
	sqlite3* _tmp22_;
	gint _tmp23_;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = self->priv->db_path;
	_tmp2_ = sqlite3_open (_tmp0_, &_tmp1_);
	_sqlite3_close0 (self->priv->db);
	self->priv->db = _tmp1_;
	rc = _tmp2_;
	_tmp3_ = rc;
	if (_tmp3_ != SQLITE_OK) {
		FILE* _tmp4_;
		gint _tmp5_;
		sqlite3* _tmp6_;
		const gchar* _tmp7_;
		_tmp4_ = stderr;
		_tmp5_ = rc;
		_tmp6_ = self->priv->db;
		_tmp7_ = sqlite3_errmsg (_tmp6_);
		fprintf (_tmp4_, "Can't open database: %d, %s\n", _tmp5_, _tmp7_);
		gtk_main_quit ();
	}
	_tmp8_ = self->priv->db;
	_tmp9_ = _sqlite3_exec (_tmp8_, "CREATE TABLE IF NOT EXISTS artists (" "id             INTEGER PRIMARY KEY AUTOINCREMENT, " "name           TEXT    NOT NULL," "CONSTRAINT unique_artist UNIQUE (name))", NULL, NULL, NULL);
	rc = _tmp9_;
	g_debug ("Database.vala:56: Table artists created");
	_tmp10_ = self->priv->db;
	_tmp11_ = _sqlite3_exec (_tmp10_, "CREATE TABLE IF NOT EXISTS albums (" "id             INTEGER PRIMARY KEY AUTOINCREMENT, " "artist_id      INT     NOT NULL," "year           INT     NOT NULL," "title          TEXT    NOT NULL," "genre          TEXT    NOT NULL," "CONSTRAINT unique_album UNIQUE (artist_id, title)," "FOREIGN KEY (artist_id) REFERENCES artists (id) ON DELETE CASCADE)", NULL, NULL, NULL);
	rc = _tmp11_;
	g_debug ("Database.vala:66: Table albums created");
	_tmp12_ = self->priv->db;
	_tmp13_ = _sqlite3_exec (_tmp12_, "CREATE TABLE IF NOT EXISTS tracks (" "id             INTEGER PRIMARY KEY AUTOINCREMENT," "album_id       INT     NOT NULL," "track          INT     NOT NULL," "disc           INT     NOT NULL," "play_count     INT     NOT NULL," "is_favorite    INT     NOT NULL," "duration       INT     NOT NULL," "samplerate     INT     NOT NULL," "channels       INT     NOT NULL," "bitrate        INT     NOT NULL," "bpm            INT     NOT NULL," "rating         INT     NOT NULL," "year           INT     NOT NULL," "path           TEXT    NOT NULL," "title          TEXT    NOT NULL," "date_added     TEXT    NOT NULL," "favorite_added TEXT    NOT NULL," "last_played    TEXT    NOT NULL," "composer       TEXT    NOT NULL," "grouping       TEXT    NOT NULL," "comment        TEXT    NOT NULL," "lyrics         TEXT    NOT NULL," "genre          TEXT    NOT NULL," "album_artist   TEXT    NOT NULL," "CONSTRAINT unique_track UNIQUE (path)," "FOREIGN KEY (album_id) REFERENCES albums (id) ON DELETE CASCADE)", NULL, NULL, NULL);
	rc = _tmp13_;
	g_debug ("Database.vala:95: Table trackS created");
	_tmp14_ = self->priv->db;
	_tmp15_ = _sqlite3_exec (_tmp14_, "CREATE TABLE IF NOT EXISTS radios (" "id         INTEGER PRIMARY KEY AUTOINCREMENT," "name       TEXT," "url        TEXT," "homepage   TEXT," "tags       TEXT," "favicon    TEXT," "country    TEXT," "state      TEXT)", NULL, NULL, NULL);
	rc = _tmp15_;
	g_debug ("Database.vala:106: Table radios created");
	_tmp16_ = self->priv->db;
	_tmp17_ = _sqlite3_exec (_tmp16_, "CREATE TABLE IF NOT EXISTS playlists (" "id           INTEGER PRIMARY KEY AUTOINCREMENT," "title        TEXT," "note         TEXT," "date_added   TEXT," "date_updated TEXT)", NULL, NULL, NULL);
	rc = _tmp17_;
	g_debug ("Database.vala:114: Table playlists created");
	_tmp18_ = self->priv->db;
	_tmp19_ = _sqlite3_exec (_tmp18_, "CREATE TABLE IF NOT EXISTS playlist_tracks (" "id           INTEGER PRIMARY KEY AUTOINCREMENT," "playlist_id  INT," "track_id     INT," "date_added   TEXT," "CONSTRAINT unique_track UNIQUE (playlist_id, track_id)," "FOREIGN KEY (track_id) REFERENCES tracks (id) ON DELETE CASCADE," "FOREIGN KEY (playlist_id) REFERENCES playlists (id) ON DELETE CASCADE)", NULL, NULL, NULL);
	rc = _tmp19_;
	g_debug ("Database.vala:124: Table playlist_tracks created");
	_tmp20_ = self->priv->db;
	_tmp21_ = _sqlite3_exec (_tmp20_, "CREATE TABLE IF NOT EXISTS blacklist (" "id     INTEGER PRIMARY KEY AUTOINCREMENT," "path   TEXT NOT NULL)", NULL, NULL, NULL);
	rc = _tmp21_;
	g_debug ("Database.vala:129: Table blacklist created");
	_tmp22_ = self->priv->db;
	_tmp23_ = _sqlite3_exec (_tmp22_, "PRAGMA foreign_keys = ON;", NULL, NULL, NULL);
	rc = _tmp23_;
	result = rc;
	return result;
}


gboolean
services_database_music_file_exists (ServicesDatabase* self,
                                     const gchar* uri)
{
	gboolean result = FALSE;
	gboolean file_exists = FALSE;
	sqlite3_stmt* stmt = NULL;
	gint res = 0;
	sqlite3* _tmp0_;
	sqlite3_stmt* _tmp1_ = NULL;
	gint _tmp2_;
	gint _tmp3_;
	sqlite3_stmt* _tmp4_;
	gchar* _tmp5_;
	GDestroyNotify _tmp6_;
	gint _tmp7_;
	sqlite3_stmt* _tmp8_;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (uri != NULL, FALSE);
	file_exists = FALSE;
	_tmp0_ = self->priv->db;
	_tmp2_ = sqlite3_prepare_v2 (_tmp0_, "SELECT COUNT (*) FROM tracks WHERE path = ?", -1, &_tmp1_, NULL);
	_sqlite3_finalize0 (stmt);
	stmt = _tmp1_;
	res = _tmp2_;
	_tmp3_ = res;
	_vala_assert (_tmp3_ == SQLITE_OK, "res == Sqlite.OK");
	_tmp4_ = stmt;
	_tmp5_ = g_strdup (uri);
	_tmp6_ = g_free;
	res = sqlite3_bind_text (_tmp4_, 1, _tmp5_, -1, _tmp6_);
	_tmp7_ = res;
	_vala_assert (_tmp7_ == SQLITE_OK, "res == Sqlite.OK");
	_tmp8_ = stmt;
	if (sqlite3_step (_tmp8_) == SQLITE_ROW) {
		sqlite3_stmt* _tmp9_;
		_tmp9_ = stmt;
		file_exists = sqlite3_column_int (_tmp9_, 0) > 0;
	}
	result = file_exists;
	_sqlite3_finalize0 (stmt);
	return result;
}


gboolean
services_database_music_blacklist_exists (ServicesDatabase* self,
                                          const gchar* uri)
{
	gboolean result = FALSE;
	gboolean file_exists = FALSE;
	sqlite3_stmt* stmt = NULL;
	gint res = 0;
	sqlite3* _tmp0_;
	sqlite3_stmt* _tmp1_ = NULL;
	gint _tmp2_;
	gint _tmp3_;
	sqlite3_stmt* _tmp4_;
	gchar* _tmp5_;
	GDestroyNotify _tmp6_;
	gint _tmp7_;
	sqlite3_stmt* _tmp8_;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (uri != NULL, FALSE);
	file_exists = FALSE;
	_tmp0_ = self->priv->db;
	_tmp2_ = sqlite3_prepare_v2 (_tmp0_, "SELECT COUNT (*) FROM blacklist WHERE path = ?", -1, &_tmp1_, NULL);
	_sqlite3_finalize0 (stmt);
	stmt = _tmp1_;
	res = _tmp2_;
	_tmp3_ = res;
	_vala_assert (_tmp3_ == SQLITE_OK, "res == Sqlite.OK");
	_tmp4_ = stmt;
	_tmp5_ = g_strdup (uri);
	_tmp6_ = g_free;
	res = sqlite3_bind_text (_tmp4_, 1, _tmp5_, -1, _tmp6_);
	_tmp7_ = res;
	_vala_assert (_tmp7_ == SQLITE_OK, "res == Sqlite.OK");
	_tmp8_ = stmt;
	if (sqlite3_step (_tmp8_) == SQLITE_ROW) {
		sqlite3_stmt* _tmp9_;
		_tmp9_ = stmt;
		file_exists = sqlite3_column_int (_tmp9_, 0) > 0;
	}
	result = file_exists;
	_sqlite3_finalize0 (stmt);
	return result;
}


gboolean
services_database_radio_exists (ServicesDatabase* self,
                                const gchar* url)
{
	gboolean result = FALSE;
	gboolean exists = FALSE;
	sqlite3_stmt* stmt = NULL;
	gint res = 0;
	sqlite3* _tmp0_;
	sqlite3_stmt* _tmp1_ = NULL;
	gint _tmp2_;
	gint _tmp3_;
	sqlite3_stmt* _tmp4_;
	gchar* _tmp5_;
	GDestroyNotify _tmp6_;
	gint _tmp7_;
	sqlite3_stmt* _tmp8_;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (url != NULL, FALSE);
	exists = FALSE;
	_tmp0_ = self->priv->db;
	_tmp2_ = sqlite3_prepare_v2 (_tmp0_, "SELECT COUNT (*) FROM radios WHERE url = ?", -1, &_tmp1_, NULL);
	_sqlite3_finalize0 (stmt);
	stmt = _tmp1_;
	res = _tmp2_;
	_tmp3_ = res;
	_vala_assert (_tmp3_ == SQLITE_OK, "res == Sqlite.OK");
	_tmp4_ = stmt;
	_tmp5_ = g_strdup (url);
	_tmp6_ = g_free;
	res = sqlite3_bind_text (_tmp4_, 1, _tmp5_, -1, _tmp6_);
	_tmp7_ = res;
	_vala_assert (_tmp7_ == SQLITE_OK, "res == Sqlite.OK");
	_tmp8_ = stmt;
	if (sqlite3_step (_tmp8_) == SQLITE_ROW) {
		sqlite3_stmt* _tmp9_;
		_tmp9_ = stmt;
		exists = sqlite3_column_int (_tmp9_, 0) > 0;
	}
	result = exists;
	_sqlite3_finalize0 (stmt);
	return result;
}


gboolean
services_database_is_database_empty (ServicesDatabase* self)
{
	gboolean result = FALSE;
	gboolean empty = FALSE;
	sqlite3_stmt* stmt = NULL;
	gint res = 0;
	sqlite3* _tmp0_;
	sqlite3_stmt* _tmp1_ = NULL;
	gint _tmp2_;
	gint _tmp3_;
	sqlite3_stmt* _tmp4_;
	g_return_val_if_fail (self != NULL, FALSE);
	empty = FALSE;
	_tmp0_ = self->priv->db;
	_tmp2_ = sqlite3_prepare_v2 (_tmp0_, "SELECT COUNT (*) FROM tracks", -1, &_tmp1_, NULL);
	_sqlite3_finalize0 (stmt);
	stmt = _tmp1_;
	res = _tmp2_;
	_tmp3_ = res;
	_vala_assert (_tmp3_ == SQLITE_OK, "res == Sqlite.OK");
	_tmp4_ = stmt;
	if (sqlite3_step (_tmp4_) == SQLITE_ROW) {
		sqlite3_stmt* _tmp5_;
		_tmp5_ = stmt;
		empty = sqlite3_column_int (_tmp5_, 0) <= 0;
	}
	result = empty;
	_sqlite3_finalize0 (stmt);
	return result;
}


gint
services_database_get_id_if_artist_exists (ServicesDatabase* self,
                                           ObjectsArtist* artist)
{
	gint result = 0;
	sqlite3_stmt* stmt = NULL;
	gchar* sql = NULL;
	gint res = 0;
	gchar* _tmp0_;
	sqlite3* _tmp1_;
	const gchar* _tmp2_;
	sqlite3_stmt* _tmp3_ = NULL;
	gint _tmp4_;
	gint _tmp5_;
	sqlite3_stmt* _tmp6_;
	const gchar* _tmp7_;
	gchar* _tmp8_;
	GDestroyNotify _tmp9_;
	gint _tmp10_;
	sqlite3_stmt* _tmp11_;
	g_return_val_if_fail (self != NULL, 0);
	g_return_val_if_fail (artist != NULL, 0);
	_tmp0_ = g_strdup ("\n" \
"            SELECT COUNT (*) FROM artists WHERE name = ?;\n" \
"        ");
	_g_free0 (sql);
	sql = _tmp0_;
	_tmp1_ = self->priv->db;
	_tmp2_ = sql;
	_tmp4_ = sqlite3_prepare_v2 (_tmp1_, _tmp2_, -1, &_tmp3_, NULL);
	_sqlite3_finalize0 (stmt);
	stmt = _tmp3_;
	res = _tmp4_;
	_tmp5_ = res;
	_vala_assert (_tmp5_ == SQLITE_OK, "res == Sqlite.OK");
	_tmp6_ = stmt;
	_tmp7_ = artist->name;
	_tmp8_ = g_strdup (_tmp7_);
	_tmp9_ = g_free;
	res = sqlite3_bind_text (_tmp6_, 1, _tmp8_, -1, _tmp9_);
	_tmp10_ = res;
	_vala_assert (_tmp10_ == SQLITE_OK, "res == Sqlite.OK");
	_tmp11_ = stmt;
	if (sqlite3_step (_tmp11_) == SQLITE_ROW) {
		sqlite3_stmt* _tmp12_;
		_tmp12_ = stmt;
		if (sqlite3_column_int (_tmp12_, 0) > 0) {
			sqlite3_stmt* _tmp13_;
			gchar* _tmp14_;
			sqlite3* _tmp15_;
			const gchar* _tmp16_;
			sqlite3_stmt* _tmp17_ = NULL;
			gint _tmp18_;
			gint _tmp19_;
			sqlite3_stmt* _tmp20_;
			const gchar* _tmp21_;
			gchar* _tmp22_;
			GDestroyNotify _tmp23_;
			gint _tmp24_;
			sqlite3_stmt* _tmp25_;
			_tmp13_ = stmt;
			sqlite3_reset (_tmp13_);
			_tmp14_ = g_strdup ("\n" \
"                    SELECT id FROM artists WHERE name = ?;\n" \
"                ");
			_g_free0 (sql);
			sql = _tmp14_;
			_tmp15_ = self->priv->db;
			_tmp16_ = sql;
			_tmp18_ = sqlite3_prepare_v2 (_tmp15_, _tmp16_, -1, &_tmp17_, NULL);
			_sqlite3_finalize0 (stmt);
			stmt = _tmp17_;
			res = _tmp18_;
			_tmp19_ = res;
			_vala_assert (_tmp19_ == SQLITE_OK, "res == Sqlite.OK");
			_tmp20_ = stmt;
			_tmp21_ = artist->name;
			_tmp22_ = g_strdup (_tmp21_);
			_tmp23_ = g_free;
			res = sqlite3_bind_text (_tmp20_, 1, _tmp22_, -1, _tmp23_);
			_tmp24_ = res;
			_vala_assert (_tmp24_ == SQLITE_OK, "res == Sqlite.OK");
			_tmp25_ = stmt;
			if (sqlite3_step (_tmp25_) == SQLITE_ROW) {
				sqlite3_stmt* _tmp26_;
				_tmp26_ = stmt;
				result = sqlite3_column_int (_tmp26_, 0);
				_g_free0 (sql);
				_sqlite3_finalize0 (stmt);
				return result;
			} else {
				sqlite3* _tmp27_;
				sqlite3* _tmp28_;
				const gchar* _tmp29_;
				_tmp27_ = self->priv->db;
				_tmp28_ = self->priv->db;
				_tmp29_ = sqlite3_errmsg (_tmp28_);
				g_warning ("Database.vala:233: Error: %d: %s", sqlite3_errcode (_tmp27_), _tmp29_);
				result = 0;
				_g_free0 (sql);
				_sqlite3_finalize0 (stmt);
				return result;
			}
		} else {
			result = 0;
			_g_free0 (sql);
			_sqlite3_finalize0 (stmt);
			return result;
		}
	} else {
		result = 0;
		_g_free0 (sql);
		_sqlite3_finalize0 (stmt);
		return result;
	}
	_g_free0 (sql);
	_sqlite3_finalize0 (stmt);
}


gint
services_database_insert_artist_if_not_exists (ServicesDatabase* self,
                                               ObjectsArtist* artist)
{
	gint result = 0;
	sqlite3_stmt* stmt = NULL;
	gchar* sql = NULL;
	gint id = 0;
	gint _tmp0_;
	g_return_val_if_fail (self != NULL, 0);
	g_return_val_if_fail (artist != NULL, 0);
	id = services_database_get_id_if_artist_exists (self, artist);
	_tmp0_ = id;
	if (_tmp0_ == 0) {
		gchar* _tmp1_;
		gint res = 0;
		sqlite3* _tmp2_;
		const gchar* _tmp3_;
		sqlite3_stmt* _tmp4_ = NULL;
		gint _tmp5_;
		gint _tmp6_;
		sqlite3_stmt* _tmp7_;
		const gchar* _tmp8_;
		gchar* _tmp9_;
		GDestroyNotify _tmp10_;
		gint _tmp11_;
		sqlite3_stmt* _tmp12_;
		gint _tmp16_;
		_tmp1_ = g_strdup ("\n" \
"                INSERT OR IGNORE INTO artists (name) VALUES (?);\n" \
"            ");
		_g_free0 (sql);
		sql = _tmp1_;
		_tmp2_ = self->priv->db;
		_tmp3_ = sql;
		_tmp5_ = sqlite3_prepare_v2 (_tmp2_, _tmp3_, -1, &_tmp4_, NULL);
		_sqlite3_finalize0 (stmt);
		stmt = _tmp4_;
		res = _tmp5_;
		_tmp6_ = res;
		_vala_assert (_tmp6_ == SQLITE_OK, "res == Sqlite.OK");
		_tmp7_ = stmt;
		_tmp8_ = artist->name;
		_tmp9_ = g_strdup (_tmp8_);
		_tmp10_ = g_free;
		res = sqlite3_bind_text (_tmp7_, 1, _tmp9_, -1, _tmp10_);
		_tmp11_ = res;
		_vala_assert (_tmp11_ == SQLITE_OK, "res == Sqlite.OK");
		_tmp12_ = stmt;
		if (sqlite3_step (_tmp12_) != SQLITE_DONE) {
			sqlite3* _tmp13_;
			sqlite3* _tmp14_;
			const gchar* _tmp15_;
			_tmp13_ = self->priv->db;
			_tmp14_ = self->priv->db;
			_tmp15_ = sqlite3_errmsg (_tmp14_);
			g_warning ("Database.vala:262: Error: %d: %s", sqlite3_errcode (_tmp13_), _tmp15_);
		}
		artist->id = services_database_get_id_if_artist_exists (self, artist);
		g_signal_emit (self, services_database_signals[SERVICES_DATABASE_ADDED_NEW_ARTIST_SIGNAL], 0, artist);
		_tmp16_ = artist->id;
		result = _tmp16_;
		_g_free0 (sql);
		_sqlite3_finalize0 (stmt);
		return result;
	} else {
		result = id;
		_g_free0 (sql);
		_sqlite3_finalize0 (stmt);
		return result;
	}
	_g_free0 (sql);
	_sqlite3_finalize0 (stmt);
}


gint
services_database_get_id_if_album_exists (ServicesDatabase* self,
                                          ObjectsAlbum* album)
{
	gint result = 0;
	sqlite3_stmt* stmt = NULL;
	gchar* sql = NULL;
	gint res = 0;
	gchar* _tmp0_;
	sqlite3* _tmp1_;
	const gchar* _tmp2_;
	sqlite3_stmt* _tmp3_ = NULL;
	gint _tmp4_;
	gint _tmp5_;
	sqlite3_stmt* _tmp6_;
	const gchar* _tmp7_;
	gchar* _tmp8_;
	GDestroyNotify _tmp9_;
	gint _tmp10_;
	sqlite3_stmt* _tmp11_;
	g_return_val_if_fail (self != NULL, 0);
	g_return_val_if_fail (album != NULL, 0);
	_tmp0_ = g_strdup ("\n" \
"            SELECT COUNT (*) FROM albums WHERE title = ?;\n" \
"        ");
	_g_free0 (sql);
	sql = _tmp0_;
	_tmp1_ = self->priv->db;
	_tmp2_ = sql;
	_tmp4_ = sqlite3_prepare_v2 (_tmp1_, _tmp2_, -1, &_tmp3_, NULL);
	_sqlite3_finalize0 (stmt);
	stmt = _tmp3_;
	res = _tmp4_;
	_tmp5_ = res;
	_vala_assert (_tmp5_ == SQLITE_OK, "res == Sqlite.OK");
	_tmp6_ = stmt;
	_tmp7_ = album->title;
	_tmp8_ = g_strdup (_tmp7_);
	_tmp9_ = g_free;
	res = sqlite3_bind_text (_tmp6_, 1, _tmp8_, -1, _tmp9_);
	_tmp10_ = res;
	_vala_assert (_tmp10_ == SQLITE_OK, "res == Sqlite.OK");
	_tmp11_ = stmt;
	if (sqlite3_step (_tmp11_) == SQLITE_ROW) {
		sqlite3_stmt* _tmp12_;
		_tmp12_ = stmt;
		if (sqlite3_column_int (_tmp12_, 0) > 0) {
			sqlite3_stmt* _tmp13_;
			gchar* _tmp14_;
			sqlite3* _tmp15_;
			const gchar* _tmp16_;
			sqlite3_stmt* _tmp17_ = NULL;
			gint _tmp18_;
			gint _tmp19_;
			sqlite3_stmt* _tmp20_;
			const gchar* _tmp21_;
			gchar* _tmp22_;
			GDestroyNotify _tmp23_;
			gint _tmp24_;
			sqlite3_stmt* _tmp25_;
			_tmp13_ = stmt;
			sqlite3_reset (_tmp13_);
			_tmp14_ = g_strdup ("\n" \
"                    SELECT id FROM albums WHERE title = ?;\n" \
"                ");
			_g_free0 (sql);
			sql = _tmp14_;
			_tmp15_ = self->priv->db;
			_tmp16_ = sql;
			_tmp18_ = sqlite3_prepare_v2 (_tmp15_, _tmp16_, -1, &_tmp17_, NULL);
			_sqlite3_finalize0 (stmt);
			stmt = _tmp17_;
			res = _tmp18_;
			_tmp19_ = res;
			_vala_assert (_tmp19_ == SQLITE_OK, "res == Sqlite.OK");
			_tmp20_ = stmt;
			_tmp21_ = album->title;
			_tmp22_ = g_strdup (_tmp21_);
			_tmp23_ = g_free;
			res = sqlite3_bind_text (_tmp20_, 1, _tmp22_, -1, _tmp23_);
			_tmp24_ = res;
			_vala_assert (_tmp24_ == SQLITE_OK, "res == Sqlite.OK");
			_tmp25_ = stmt;
			if (sqlite3_step (_tmp25_) == SQLITE_ROW) {
				sqlite3_stmt* _tmp26_;
				_tmp26_ = stmt;
				result = sqlite3_column_int (_tmp26_, 0);
				_g_free0 (sql);
				_sqlite3_finalize0 (stmt);
				return result;
			} else {
				sqlite3* _tmp27_;
				sqlite3* _tmp28_;
				const gchar* _tmp29_;
				_tmp27_ = self->priv->db;
				_tmp28_ = self->priv->db;
				_tmp29_ = sqlite3_errmsg (_tmp28_);
				g_warning ("Database.vala:306: Error: %d: %s", sqlite3_errcode (_tmp27_), _tmp29_);
				result = 0;
				_g_free0 (sql);
				_sqlite3_finalize0 (stmt);
				return result;
			}
		} else {
			result = 0;
			_g_free0 (sql);
			_sqlite3_finalize0 (stmt);
			return result;
		}
	} else {
		result = 0;
		_g_free0 (sql);
		_sqlite3_finalize0 (stmt);
		return result;
	}
	_g_free0 (sql);
	_sqlite3_finalize0 (stmt);
}


gint
services_database_insert_album_if_not_exists (ServicesDatabase* self,
                                              ObjectsAlbum* album)
{
	gint result = 0;
	sqlite3_stmt* stmt = NULL;
	gchar* sql = NULL;
	gint id = 0;
	gint _tmp0_;
	g_return_val_if_fail (self != NULL, 0);
	g_return_val_if_fail (album != NULL, 0);
	id = services_database_get_id_if_album_exists (self, album);
	_tmp0_ = id;
	if (_tmp0_ == 0) {
		gchar* _tmp1_;
		gint res = 0;
		sqlite3* _tmp2_;
		const gchar* _tmp3_;
		sqlite3_stmt* _tmp4_ = NULL;
		gint _tmp5_;
		gint _tmp6_;
		sqlite3_stmt* _tmp7_;
		gint _tmp8_;
		gint _tmp9_;
		sqlite3_stmt* _tmp10_;
		gint _tmp11_;
		gint _tmp12_;
		sqlite3_stmt* _tmp13_;
		const gchar* _tmp14_;
		gchar* _tmp15_;
		GDestroyNotify _tmp16_;
		gint _tmp17_;
		sqlite3_stmt* _tmp18_;
		const gchar* _tmp19_;
		gchar* _tmp20_;
		GDestroyNotify _tmp21_;
		gint _tmp22_;
		sqlite3_stmt* _tmp23_;
		gint _tmp27_;
		_tmp1_ = g_strdup ("\n" \
"                INSERT OR IGNORE INTO albums (artist_id, year, title, " \
"genre) VALUES (?, ?, ?, ?);\n" \
"            ");
		_g_free0 (sql);
		sql = _tmp1_;
		_tmp2_ = self->priv->db;
		_tmp3_ = sql;
		_tmp5_ = sqlite3_prepare_v2 (_tmp2_, _tmp3_, -1, &_tmp4_, NULL);
		_sqlite3_finalize0 (stmt);
		stmt = _tmp4_;
		res = _tmp5_;
		_tmp6_ = res;
		_vala_assert (_tmp6_ == SQLITE_OK, "res == Sqlite.OK");
		_tmp7_ = stmt;
		_tmp8_ = album->artist_id;
		res = sqlite3_bind_int (_tmp7_, 1, _tmp8_);
		_tmp9_ = res;
		_vala_assert (_tmp9_ == SQLITE_OK, "res == Sqlite.OK");
		_tmp10_ = stmt;
		_tmp11_ = album->year;
		res = sqlite3_bind_int (_tmp10_, 2, _tmp11_);
		_tmp12_ = res;
		_vala_assert (_tmp12_ == SQLITE_OK, "res == Sqlite.OK");
		_tmp13_ = stmt;
		_tmp14_ = album->title;
		_tmp15_ = g_strdup (_tmp14_);
		_tmp16_ = g_free;
		res = sqlite3_bind_text (_tmp13_, 3, _tmp15_, -1, _tmp16_);
		_tmp17_ = res;
		_vala_assert (_tmp17_ == SQLITE_OK, "res == Sqlite.OK");
		_tmp18_ = stmt;
		_tmp19_ = album->genre;
		_tmp20_ = g_strdup (_tmp19_);
		_tmp21_ = g_free;
		res = sqlite3_bind_text (_tmp18_, 4, _tmp20_, -1, _tmp21_);
		_tmp22_ = res;
		_vala_assert (_tmp22_ == SQLITE_OK, "res == Sqlite.OK");
		_tmp23_ = stmt;
		if (sqlite3_step (_tmp23_) != SQLITE_DONE) {
			sqlite3* _tmp24_;
			sqlite3* _tmp25_;
			const gchar* _tmp26_;
			_tmp24_ = self->priv->db;
			_tmp25_ = self->priv->db;
			_tmp26_ = sqlite3_errmsg (_tmp25_);
			g_warning ("Database.vala:344: Error: %d: %s", sqlite3_errcode (_tmp24_), _tmp26_);
		}
		album->id = services_database_get_id_if_album_exists (self, album);
		g_signal_emit (self, services_database_signals[SERVICES_DATABASE_ADDED_NEW_ALBUM_SIGNAL], 0, album);
		_tmp27_ = album->id;
		result = _tmp27_;
		_g_free0 (sql);
		_sqlite3_finalize0 (stmt);
		return result;
	} else {
		result = id;
		_g_free0 (sql);
		_sqlite3_finalize0 (stmt);
		return result;
	}
	_g_free0 (sql);
	_sqlite3_finalize0 (stmt);
}


static gpointer
_g_object_ref0 (gpointer self)
{
	return self ? g_object_ref (self) : NULL;
}


static Block3Data*
block3_data_ref (Block3Data* _data3_)
{
	g_atomic_int_inc (&_data3_->_ref_count_);
	return _data3_;
}


static void
block3_data_unref (void * _userdata_)
{
	Block3Data* _data3_;
	_data3_ = (Block3Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data3_->_ref_count_)) {
		ServicesDatabase* self;
		self = _data3_->self;
		_g_object_unref0 (_data3_->track);
		_g_object_unref0 (self);
		g_slice_free (Block3Data, _data3_);
	}
}


static gboolean
___lambda12_ (Block3Data* _data3_)
{
	ServicesDatabase* self;
	gboolean result = FALSE;
	ServicesCoverImport* _tmp0_;
	self = _data3_->self;
	_tmp0_ = byte_cover_import;
	services_cover_import_import (_tmp0_, _data3_->track);
	result = FALSE;
	return result;
}


static gboolean
____lambda12__gsource_func (gpointer self)
{
	gboolean result;
	result = ___lambda12_ (self);
	return result;
}


void
services_database_insert_track (ServicesDatabase* self,
                                ObjectsTrack* track)
{
	Block3Data* _data3_;
	ObjectsTrack* _tmp0_;
	sqlite3_stmt* stmt = NULL;
	gchar* sql = NULL;
	gint res = 0;
	gchar* _tmp1_;
	sqlite3* _tmp2_;
	const gchar* _tmp3_;
	sqlite3_stmt* _tmp4_ = NULL;
	gint _tmp5_;
	gint _tmp6_;
	sqlite3_stmt* _tmp7_;
	gint _tmp8_;
	gint _tmp9_;
	sqlite3_stmt* _tmp10_;
	gint _tmp11_;
	gint _tmp12_;
	sqlite3_stmt* _tmp13_;
	gint _tmp14_;
	gint _tmp15_;
	sqlite3_stmt* _tmp16_;
	gint _tmp17_;
	gint _tmp18_;
	sqlite3_stmt* _tmp19_;
	gint _tmp20_;
	gint _tmp21_;
	sqlite3_stmt* _tmp22_;
	gint _tmp23_;
	gint _tmp24_;
	sqlite3_stmt* _tmp25_;
	gint _tmp26_;
	gint _tmp27_;
	sqlite3_stmt* _tmp28_;
	gint _tmp29_;
	gint _tmp30_;
	sqlite3_stmt* _tmp31_;
	gint _tmp32_;
	gint _tmp33_;
	sqlite3_stmt* _tmp34_;
	gint _tmp35_;
	gint _tmp36_;
	sqlite3_stmt* _tmp37_;
	gint _tmp38_;
	gint _tmp39_;
	sqlite3_stmt* _tmp40_;
	guint64 _tmp41_;
	gint _tmp42_;
	sqlite3_stmt* _tmp43_;
	const gchar* _tmp44_;
	gchar* _tmp45_;
	GDestroyNotify _tmp46_;
	gint _tmp47_;
	sqlite3_stmt* _tmp48_;
	const gchar* _tmp49_;
	gchar* _tmp50_;
	GDestroyNotify _tmp51_;
	gint _tmp52_;
	sqlite3_stmt* _tmp53_;
	const gchar* _tmp54_;
	gchar* _tmp55_;
	GDestroyNotify _tmp56_;
	gint _tmp57_;
	sqlite3_stmt* _tmp58_;
	const gchar* _tmp59_;
	gchar* _tmp60_;
	GDestroyNotify _tmp61_;
	gint _tmp62_;
	sqlite3_stmt* _tmp63_;
	const gchar* _tmp64_;
	gchar* _tmp65_;
	GDestroyNotify _tmp66_;
	gint _tmp67_;
	sqlite3_stmt* _tmp68_;
	const gchar* _tmp69_;
	gchar* _tmp70_;
	GDestroyNotify _tmp71_;
	gint _tmp72_;
	sqlite3_stmt* _tmp73_;
	const gchar* _tmp74_;
	gchar* _tmp75_;
	GDestroyNotify _tmp76_;
	gint _tmp77_;
	sqlite3_stmt* _tmp78_;
	const gchar* _tmp79_;
	gchar* _tmp80_;
	GDestroyNotify _tmp81_;
	gint _tmp82_;
	sqlite3_stmt* _tmp83_;
	const gchar* _tmp84_;
	gchar* _tmp85_;
	GDestroyNotify _tmp86_;
	gint _tmp87_;
	sqlite3_stmt* _tmp88_;
	const gchar* _tmp89_;
	gchar* _tmp90_;
	GDestroyNotify _tmp91_;
	gint _tmp92_;
	sqlite3_stmt* _tmp93_;
	const gchar* _tmp94_;
	gchar* _tmp95_;
	GDestroyNotify _tmp96_;
	gint _tmp97_;
	sqlite3_stmt* _tmp98_;
	sqlite3_stmt* _tmp102_;
	gchar* _tmp103_;
	sqlite3* _tmp104_;
	const gchar* _tmp105_;
	sqlite3_stmt* _tmp106_ = NULL;
	gint _tmp107_;
	gint _tmp108_;
	sqlite3_stmt* _tmp109_;
	const gchar* _tmp110_;
	gchar* _tmp111_;
	GDestroyNotify _tmp112_;
	gint _tmp113_;
	sqlite3_stmt* _tmp114_;
	sqlite3_stmt* _tmp122_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (track != NULL);
	_data3_ = g_slice_new0 (Block3Data);
	_data3_->_ref_count_ = 1;
	_data3_->self = g_object_ref (self);
	_tmp0_ = _g_object_ref0 (track);
	_g_object_unref0 (_data3_->track);
	_data3_->track = _tmp0_;
	_tmp1_ = g_strdup ("\n" \
"            INSERT OR IGNORE INTO tracks (album_id, track, disc, play_" \
"count, is_favorite,\n" \
"                bitrate, bpm, rating, samplerate, channels, year, dura" \
"tion,\n" \
"                path, title, favorite_added, last_played, composer, gr" \
"ouping, \n" \
"                comment, lyrics, genre, album_artist, date_added)\n" \
"            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?," \
" ?, ?, ?, ?, ?, ?); \n" \
"        ");
	_g_free0 (sql);
	sql = _tmp1_;
	_tmp2_ = self->priv->db;
	_tmp3_ = sql;
	_tmp5_ = sqlite3_prepare_v2 (_tmp2_, _tmp3_, -1, &_tmp4_, NULL);
	_sqlite3_finalize0 (stmt);
	stmt = _tmp4_;
	res = _tmp5_;
	_tmp6_ = res;
	_vala_assert (_tmp6_ == SQLITE_OK, "res == Sqlite.OK");
	_tmp7_ = stmt;
	_tmp8_ = _data3_->track->album_id;
	res = sqlite3_bind_int (_tmp7_, 1, _tmp8_);
	_tmp9_ = res;
	_vala_assert (_tmp9_ == SQLITE_OK, "res == Sqlite.OK");
	_tmp10_ = stmt;
	_tmp11_ = _data3_->track->track;
	res = sqlite3_bind_int (_tmp10_, 2, _tmp11_);
	_tmp12_ = res;
	_vala_assert (_tmp12_ == SQLITE_OK, "res == Sqlite.OK");
	_tmp13_ = stmt;
	_tmp14_ = _data3_->track->disc;
	res = sqlite3_bind_int (_tmp13_, 3, _tmp14_);
	_tmp15_ = res;
	_vala_assert (_tmp15_ == SQLITE_OK, "res == Sqlite.OK");
	_tmp16_ = stmt;
	_tmp17_ = _data3_->track->play_count;
	res = sqlite3_bind_int (_tmp16_, 4, _tmp17_);
	_tmp18_ = res;
	_vala_assert (_tmp18_ == SQLITE_OK, "res == Sqlite.OK");
	_tmp19_ = stmt;
	_tmp20_ = _data3_->track->is_favorite;
	res = sqlite3_bind_int (_tmp19_, 5, _tmp20_);
	_tmp21_ = res;
	_vala_assert (_tmp21_ == SQLITE_OK, "res == Sqlite.OK");
	_tmp22_ = stmt;
	_tmp23_ = _data3_->track->bitrate;
	res = sqlite3_bind_int (_tmp22_, 6, _tmp23_);
	_tmp24_ = res;
	_vala_assert (_tmp24_ == SQLITE_OK, "res == Sqlite.OK");
	_tmp25_ = stmt;
	_tmp26_ = _data3_->track->bpm;
	res = sqlite3_bind_int (_tmp25_, 7, _tmp26_);
	_tmp27_ = res;
	_vala_assert (_tmp27_ == SQLITE_OK, "res == Sqlite.OK");
	_tmp28_ = stmt;
	_tmp29_ = _data3_->track->rating;
	res = sqlite3_bind_int (_tmp28_, 8, _tmp29_);
	_tmp30_ = res;
	_vala_assert (_tmp30_ == SQLITE_OK, "res == Sqlite.OK");
	_tmp31_ = stmt;
	_tmp32_ = _data3_->track->samplerate;
	res = sqlite3_bind_int (_tmp31_, 9, _tmp32_);
	_tmp33_ = res;
	_vala_assert (_tmp33_ == SQLITE_OK, "res == Sqlite.OK");
	_tmp34_ = stmt;
	_tmp35_ = _data3_->track->channels;
	res = sqlite3_bind_int (_tmp34_, 10, _tmp35_);
	_tmp36_ = res;
	_vala_assert (_tmp36_ == SQLITE_OK, "res == Sqlite.OK");
	_tmp37_ = stmt;
	_tmp38_ = _data3_->track->year;
	res = sqlite3_bind_int (_tmp37_, 11, _tmp38_);
	_tmp39_ = res;
	_vala_assert (_tmp39_ == SQLITE_OK, "res == Sqlite.OK");
	_tmp40_ = stmt;
	_tmp41_ = _data3_->track->duration;
	res = sqlite3_bind_int64 (_tmp40_, 12, (gint64) _tmp41_);
	_tmp42_ = res;
	_vala_assert (_tmp42_ == SQLITE_OK, "res == Sqlite.OK");
	_tmp43_ = stmt;
	_tmp44_ = _data3_->track->path;
	_tmp45_ = g_strdup (_tmp44_);
	_tmp46_ = g_free;
	res = sqlite3_bind_text (_tmp43_, 13, _tmp45_, -1, _tmp46_);
	_tmp47_ = res;
	_vala_assert (_tmp47_ == SQLITE_OK, "res == Sqlite.OK");
	_tmp48_ = stmt;
	_tmp49_ = _data3_->track->title;
	_tmp50_ = g_strdup (_tmp49_);
	_tmp51_ = g_free;
	res = sqlite3_bind_text (_tmp48_, 14, _tmp50_, -1, _tmp51_);
	_tmp52_ = res;
	_vala_assert (_tmp52_ == SQLITE_OK, "res == Sqlite.OK");
	_tmp53_ = stmt;
	_tmp54_ = _data3_->track->favorite_added;
	_tmp55_ = g_strdup (_tmp54_);
	_tmp56_ = g_free;
	res = sqlite3_bind_text (_tmp53_, 15, _tmp55_, -1, _tmp56_);
	_tmp57_ = res;
	_vala_assert (_tmp57_ == SQLITE_OK, "res == Sqlite.OK");
	_tmp58_ = stmt;
	_tmp59_ = _data3_->track->last_played;
	_tmp60_ = g_strdup (_tmp59_);
	_tmp61_ = g_free;
	res = sqlite3_bind_text (_tmp58_, 16, _tmp60_, -1, _tmp61_);
	_tmp62_ = res;
	_vala_assert (_tmp62_ == SQLITE_OK, "res == Sqlite.OK");
	_tmp63_ = stmt;
	_tmp64_ = _data3_->track->composer;
	_tmp65_ = g_strdup (_tmp64_);
	_tmp66_ = g_free;
	res = sqlite3_bind_text (_tmp63_, 17, _tmp65_, -1, _tmp66_);
	_tmp67_ = res;
	_vala_assert (_tmp67_ == SQLITE_OK, "res == Sqlite.OK");
	_tmp68_ = stmt;
	_tmp69_ = _data3_->track->grouping;
	_tmp70_ = g_strdup (_tmp69_);
	_tmp71_ = g_free;
	res = sqlite3_bind_text (_tmp68_, 18, _tmp70_, -1, _tmp71_);
	_tmp72_ = res;
	_vala_assert (_tmp72_ == SQLITE_OK, "res == Sqlite.OK");
	_tmp73_ = stmt;
	_tmp74_ = _data3_->track->comment;
	_tmp75_ = g_strdup (_tmp74_);
	_tmp76_ = g_free;
	res = sqlite3_bind_text (_tmp73_, 19, _tmp75_, -1, _tmp76_);
	_tmp77_ = res;
	_vala_assert (_tmp77_ == SQLITE_OK, "res == Sqlite.OK");
	_tmp78_ = stmt;
	_tmp79_ = _data3_->track->lyrics;
	_tmp80_ = g_strdup (_tmp79_);
	_tmp81_ = g_free;
	res = sqlite3_bind_text (_tmp78_, 20, _tmp80_, -1, _tmp81_);
	_tmp82_ = res;
	_vala_assert (_tmp82_ == SQLITE_OK, "res == Sqlite.OK");
	_tmp83_ = stmt;
	_tmp84_ = _data3_->track->genre;
	_tmp85_ = g_strdup (_tmp84_);
	_tmp86_ = g_free;
	res = sqlite3_bind_text (_tmp83_, 21, _tmp85_, -1, _tmp86_);
	_tmp87_ = res;
	_vala_assert (_tmp87_ == SQLITE_OK, "res == Sqlite.OK");
	_tmp88_ = stmt;
	_tmp89_ = _data3_->track->album_artist;
	_tmp90_ = g_strdup (_tmp89_);
	_tmp91_ = g_free;
	res = sqlite3_bind_text (_tmp88_, 22, _tmp90_, -1, _tmp91_);
	_tmp92_ = res;
	_vala_assert (_tmp92_ == SQLITE_OK, "res == Sqlite.OK");
	_tmp93_ = stmt;
	_tmp94_ = _data3_->track->date_added;
	_tmp95_ = g_strdup (_tmp94_);
	_tmp96_ = g_free;
	res = sqlite3_bind_text (_tmp93_, 23, _tmp95_, -1, _tmp96_);
	_tmp97_ = res;
	_vala_assert (_tmp97_ == SQLITE_OK, "res == Sqlite.OK");
	_tmp98_ = stmt;
	if (sqlite3_step (_tmp98_) != SQLITE_DONE) {
		sqlite3* _tmp99_;
		sqlite3* _tmp100_;
		const gchar* _tmp101_;
		_tmp99_ = self->priv->db;
		_tmp100_ = self->priv->db;
		_tmp101_ = sqlite3_errmsg (_tmp100_);
		g_warning ("Database.vala:443: Error: %d: %s", sqlite3_errcode (_tmp99_), _tmp101_);
	}
	_tmp102_ = stmt;
	sqlite3_reset (_tmp102_);
	_tmp103_ = g_strdup ("\n            SELECT id FROM tracks WHERE path = ?;\n        ");
	_g_free0 (sql);
	sql = _tmp103_;
	_tmp104_ = self->priv->db;
	_tmp105_ = sql;
	_tmp107_ = sqlite3_prepare_v2 (_tmp104_, _tmp105_, -1, &_tmp106_, NULL);
	_sqlite3_finalize0 (stmt);
	stmt = _tmp106_;
	res = _tmp107_;
	_tmp108_ = res;
	_vala_assert (_tmp108_ == SQLITE_OK, "res == Sqlite.OK");
	_tmp109_ = stmt;
	_tmp110_ = _data3_->track->path;
	_tmp111_ = g_strdup (_tmp110_);
	_tmp112_ = g_free;
	res = sqlite3_bind_text (_tmp109_, 1, _tmp111_, -1, _tmp112_);
	_tmp113_ = res;
	_vala_assert (_tmp113_ == SQLITE_OK, "res == Sqlite.OK");
	_tmp114_ = stmt;
	if (sqlite3_step (_tmp114_) == SQLITE_ROW) {
		sqlite3_stmt* _tmp115_;
		FILE* _tmp116_;
		gint _tmp117_;
		const gchar* _tmp118_;
		_tmp115_ = stmt;
		_data3_->track->id = sqlite3_column_int (_tmp115_, 0);
		_tmp116_ = stdout;
		_tmp117_ = _data3_->track->id;
		_tmp118_ = _data3_->track->title;
		fprintf (_tmp116_, "Track ID: %d - %s\n", _tmp117_, _tmp118_);
		g_signal_emit (self, services_database_signals[SERVICES_DATABASE_ADDEN_NEW_TRACK_SIGNAL], 0, _data3_->track);
		g_idle_add_full (G_PRIORITY_DEFAULT_IDLE, ____lambda12__gsource_func, block3_data_ref (_data3_), block3_data_unref);
	} else {
		sqlite3* _tmp119_;
		sqlite3* _tmp120_;
		const gchar* _tmp121_;
		_tmp119_ = self->priv->db;
		_tmp120_ = self->priv->db;
		_tmp121_ = sqlite3_errmsg (_tmp120_);
		g_warning ("Database.vala:469: Error: %d: %s", sqlite3_errcode (_tmp119_), _tmp121_);
		g_signal_emit (self, services_database_signals[SERVICES_DATABASE_ADDEN_NEW_TRACK_SIGNAL], 0, NULL);
	}
	_tmp122_ = stmt;
	sqlite3_reset (_tmp122_);
	_g_free0 (sql);
	_sqlite3_finalize0 (stmt);
	block3_data_unref (_data3_);
	_data3_ = NULL;
}


static gchar*
g_date_time_to_string (GDateTime* self)
{
	gchar* result = NULL;
	gchar* _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = g_date_time_format (self, "%FT%H:%M:%S%z");
	result = _tmp0_;
	return result;
}


ObjectsTrack*
services_database_get_track_by_id (ServicesDatabase* self,
                                   gint id)
{
	ObjectsTrack* result = NULL;
	sqlite3_stmt* stmt = NULL;
	gint res = 0;
	gchar* sql = NULL;
	gchar* _tmp0_;
	sqlite3* _tmp1_;
	const gchar* _tmp2_;
	sqlite3_stmt* _tmp3_ = NULL;
	gint _tmp4_;
	gint _tmp5_;
	sqlite3_stmt* _tmp6_;
	gint _tmp7_;
	ObjectsTrack* track = NULL;
	GDateTime* _tmp8_;
	GDateTime* _tmp9_;
	gchar* _tmp10_;
	gchar* _tmp11_;
	ObjectsTrack* _tmp12_;
	ObjectsTrack* _tmp13_;
	sqlite3_stmt* _tmp14_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = g_strdup ("\n" \
"            SELECT tracks.id, tracks.path, tracks.title, tracks.durati" \
"on, tracks.is_favorite, tracks.date_added, \n" \
"            tracks.album_id, albums.title, artists.name, tracks.favori" \
"te_added, tracks.last_played FROM tracks \n" \
"            INNER JOIN albums ON tracks.album_id = albums.id\n" \
"            INNER JOIN artists ON albums.artist_id = artists.id WHERE " \
"id = ?;\n" \
"        ");
	sql = _tmp0_;
	_tmp1_ = self->priv->db;
	_tmp2_ = sql;
	_tmp4_ = sqlite3_prepare_v2 (_tmp1_, _tmp2_, -1, &_tmp3_, NULL);
	_sqlite3_finalize0 (stmt);
	stmt = _tmp3_;
	res = _tmp4_;
	_tmp5_ = res;
	_vala_assert (_tmp5_ == SQLITE_OK, "res == Sqlite.OK");
	_tmp6_ = stmt;
	res = sqlite3_bind_int (_tmp6_, 1, id);
	_tmp7_ = res;
	_vala_assert (_tmp7_ == SQLITE_OK, "res == Sqlite.OK");
	_tmp8_ = g_date_time_new_now_local ();
	_tmp9_ = _tmp8_;
	_tmp10_ = g_date_time_to_string (_tmp9_);
	_tmp11_ = _tmp10_;
	_tmp12_ = objects_track_new (0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (guint64) 0, "", "", "", "", "", "", "", "", "", "", "", "", _tmp11_);
	_tmp13_ = _tmp12_;
	_g_free0 (_tmp11_);
	_g_date_time_unref0 (_tmp9_);
	track = _tmp13_;
	_tmp14_ = stmt;
	if (sqlite3_step (_tmp14_) == SQLITE_ROW) {
		ObjectsTrack* _tmp15_;
		sqlite3_stmt* _tmp16_;
		ObjectsTrack* _tmp17_;
		sqlite3_stmt* _tmp18_;
		const gchar* _tmp19_;
		gchar* _tmp20_;
		ObjectsTrack* _tmp21_;
		sqlite3_stmt* _tmp22_;
		const gchar* _tmp23_;
		gchar* _tmp24_;
		ObjectsTrack* _tmp25_;
		sqlite3_stmt* _tmp26_;
		ObjectsTrack* _tmp27_;
		sqlite3_stmt* _tmp28_;
		ObjectsTrack* _tmp29_;
		sqlite3_stmt* _tmp30_;
		ObjectsTrack* _tmp31_;
		sqlite3_stmt* _tmp32_;
		const gchar* _tmp33_;
		gchar* _tmp34_;
		ObjectsTrack* _tmp35_;
		sqlite3_stmt* _tmp36_;
		ObjectsTrack* _tmp37_;
		sqlite3_stmt* _tmp38_;
		ObjectsTrack* _tmp39_;
		sqlite3_stmt* _tmp40_;
		const gchar* _tmp41_;
		gchar* _tmp42_;
		ObjectsTrack* _tmp43_;
		sqlite3_stmt* _tmp44_;
		const gchar* _tmp45_;
		gchar* _tmp46_;
		ObjectsTrack* _tmp47_;
		sqlite3_stmt* _tmp48_;
		const gchar* _tmp49_;
		gchar* _tmp50_;
		ObjectsTrack* _tmp51_;
		sqlite3_stmt* _tmp52_;
		const gchar* _tmp53_;
		gchar* _tmp54_;
		_tmp15_ = track;
		_tmp16_ = stmt;
		_tmp15_->id = sqlite3_column_int (_tmp16_, 0);
		_tmp17_ = track;
		_tmp18_ = stmt;
		_tmp19_ = sqlite3_column_text (_tmp18_, 1);
		_tmp20_ = g_strdup (_tmp19_);
		_g_free0 (_tmp17_->path);
		_tmp17_->path = _tmp20_;
		_tmp21_ = track;
		_tmp22_ = stmt;
		_tmp23_ = sqlite3_column_text (_tmp22_, 2);
		_tmp24_ = g_strdup (_tmp23_);
		_g_free0 (_tmp21_->title);
		_tmp21_->title = _tmp24_;
		_tmp25_ = track;
		_tmp26_ = stmt;
		_tmp25_->duration = (guint64) sqlite3_column_int64 (_tmp26_, 3);
		_tmp27_ = track;
		_tmp28_ = stmt;
		_tmp27_->is_favorite = sqlite3_column_int (_tmp28_, 4);
		_tmp29_ = track;
		_tmp30_ = stmt;
		_tmp29_->track = sqlite3_column_int (_tmp30_, 5);
		_tmp31_ = track;
		_tmp32_ = stmt;
		_tmp33_ = sqlite3_column_text (_tmp32_, 6);
		_tmp34_ = g_strdup (_tmp33_);
		_g_free0 (_tmp31_->date_added);
		_tmp31_->date_added = _tmp34_;
		_tmp35_ = track;
		_tmp36_ = stmt;
		_tmp35_->play_count = sqlite3_column_int (_tmp36_, 7);
		_tmp37_ = track;
		_tmp38_ = stmt;
		_tmp37_->album_id = sqlite3_column_int (_tmp38_, 8);
		_tmp39_ = track;
		_tmp40_ = stmt;
		_tmp41_ = sqlite3_column_text (_tmp40_, 9);
		_tmp42_ = g_strdup (_tmp41_);
		_g_free0 (_tmp39_->album_title);
		_tmp39_->album_title = _tmp42_;
		_tmp43_ = track;
		_tmp44_ = stmt;
		_tmp45_ = sqlite3_column_text (_tmp44_, 10);
		_tmp46_ = g_strdup (_tmp45_);
		_g_free0 (_tmp43_->artist_name);
		_tmp43_->artist_name = _tmp46_;
		_tmp47_ = track;
		_tmp48_ = stmt;
		_tmp49_ = sqlite3_column_text (_tmp48_, 11);
		_tmp50_ = g_strdup (_tmp49_);
		_g_free0 (_tmp47_->favorite_added);
		_tmp47_->favorite_added = _tmp50_;
		_tmp51_ = track;
		_tmp52_ = stmt;
		_tmp53_ = sqlite3_column_text (_tmp52_, 12);
		_tmp54_ = g_strdup (_tmp53_);
		_g_free0 (_tmp51_->last_played);
		_tmp51_->last_played = _tmp54_;
	}
	result = track;
	_g_free0 (sql);
	_sqlite3_finalize0 (stmt);
	return result;
}


GeeArrayList*
services_database_get_all_albums_by_artist (ServicesDatabase* self,
                                            gint id)
{
	GeeArrayList* result = NULL;
	sqlite3_stmt* stmt = NULL;
	gchar* sql = NULL;
	gint res = 0;
	gchar* _tmp0_;
	sqlite3* _tmp1_;
	const gchar* _tmp2_;
	sqlite3_stmt* _tmp3_ = NULL;
	gint _tmp4_;
	gint _tmp5_;
	sqlite3_stmt* _tmp6_;
	gint _tmp7_;
	GeeArrayList* all = NULL;
	GeeArrayList* _tmp8_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = g_strdup ("\n" \
"            SELECT albums.id, albums.artist_id, albums.year, albums.ti" \
"tle, albums.genre, artists.name from albums\n" \
"            INNER JOIN artists ON artists.id = albums.artist_id WHERE " \
"artists.id = ? ORDER BY albums.year DESC;\n" \
"        ");
	_g_free0 (sql);
	sql = _tmp0_;
	_tmp1_ = self->priv->db;
	_tmp2_ = sql;
	_tmp4_ = sqlite3_prepare_v2 (_tmp1_, _tmp2_, -1, &_tmp3_, NULL);
	_sqlite3_finalize0 (stmt);
	stmt = _tmp3_;
	res = _tmp4_;
	_tmp5_ = res;
	_vala_assert (_tmp5_ == SQLITE_OK, "res == Sqlite.OK");
	_tmp6_ = stmt;
	res = sqlite3_bind_int (_tmp6_, 1, id);
	_tmp7_ = res;
	_vala_assert (_tmp7_ == SQLITE_OK, "res == Sqlite.OK");
	_tmp8_ = gee_array_list_new (OBJECTS_TYPE_ALBUM, (GBoxedCopyFunc) g_object_ref, (GDestroyNotify) g_object_unref, NULL, NULL, NULL);
	all = _tmp8_;
	while (TRUE) {
		sqlite3_stmt* _tmp9_;
		gint _tmp10_;
		ObjectsAlbum* album = NULL;
		ObjectsAlbum* _tmp11_;
		ObjectsAlbum* _tmp12_;
		sqlite3_stmt* _tmp13_;
		ObjectsAlbum* _tmp14_;
		sqlite3_stmt* _tmp15_;
		ObjectsAlbum* _tmp16_;
		sqlite3_stmt* _tmp17_;
		ObjectsAlbum* _tmp18_;
		sqlite3_stmt* _tmp19_;
		const gchar* _tmp20_;
		gchar* _tmp21_;
		ObjectsAlbum* _tmp22_;
		sqlite3_stmt* _tmp23_;
		const gchar* _tmp24_;
		gchar* _tmp25_;
		ObjectsAlbum* _tmp26_;
		sqlite3_stmt* _tmp27_;
		const gchar* _tmp28_;
		gchar* _tmp29_;
		GeeArrayList* _tmp30_;
		ObjectsAlbum* _tmp31_;
		_tmp9_ = stmt;
		res = sqlite3_step (_tmp9_);
		_tmp10_ = res;
		if (!(_tmp10_ == SQLITE_ROW)) {
			break;
		}
		_tmp11_ = objects_album_new (0, 0, "", 0, "", "");
		album = _tmp11_;
		_tmp12_ = album;
		_tmp13_ = stmt;
		_tmp12_->id = sqlite3_column_int (_tmp13_, 0);
		_tmp14_ = album;
		_tmp15_ = stmt;
		_tmp14_->artist_id = sqlite3_column_int (_tmp15_, 1);
		_tmp16_ = album;
		_tmp17_ = stmt;
		_tmp16_->year = sqlite3_column_int (_tmp17_, 2);
		_tmp18_ = album;
		_tmp19_ = stmt;
		_tmp20_ = sqlite3_column_text (_tmp19_, 3);
		_tmp21_ = g_strdup (_tmp20_);
		_g_free0 (_tmp18_->title);
		_tmp18_->title = _tmp21_;
		_tmp22_ = album;
		_tmp23_ = stmt;
		_tmp24_ = sqlite3_column_text (_tmp23_, 4);
		_tmp25_ = g_strdup (_tmp24_);
		_g_free0 (_tmp22_->genre);
		_tmp22_->genre = _tmp25_;
		_tmp26_ = album;
		_tmp27_ = stmt;
		_tmp28_ = sqlite3_column_text (_tmp27_, 5);
		_tmp29_ = g_strdup (_tmp28_);
		_g_free0 (_tmp26_->artist_name);
		_tmp26_->artist_name = _tmp29_;
		_tmp30_ = all;
		_tmp31_ = album;
		gee_abstract_collection_add ((GeeAbstractCollection*) _tmp30_, _tmp31_);
		_g_object_unref0 (album);
	}
	result = all;
	_g_free0 (sql);
	_sqlite3_finalize0 (stmt);
	return result;
}


GeeArrayList*
services_database_get_all_albums (ServicesDatabase* self)
{
	GeeArrayList* result = NULL;
	sqlite3_stmt* stmt = NULL;
	gchar* sql = NULL;
	gint res = 0;
	gchar* _tmp0_;
	sqlite3* _tmp1_;
	const gchar* _tmp2_;
	sqlite3_stmt* _tmp3_ = NULL;
	gint _tmp4_;
	gint _tmp5_;
	GeeArrayList* all = NULL;
	GeeArrayList* _tmp6_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = g_strdup ("\n" \
"            SELECT albums.id, albums.artist_id, albums.year, albums.ti" \
"tle, albums.genre, artists.name from albums\n" \
"            INNER JOIN artists ON artists.id = albums.artist_id ORDER " \
"BY albums.title;\n" \
"        ");
	_g_free0 (sql);
	sql = _tmp0_;
	_tmp1_ = self->priv->db;
	_tmp2_ = sql;
	_tmp4_ = sqlite3_prepare_v2 (_tmp1_, _tmp2_, -1, &_tmp3_, NULL);
	_sqlite3_finalize0 (stmt);
	stmt = _tmp3_;
	res = _tmp4_;
	_tmp5_ = res;
	_vala_assert (_tmp5_ == SQLITE_OK, "res == Sqlite.OK");
	_tmp6_ = gee_array_list_new (OBJECTS_TYPE_ALBUM, (GBoxedCopyFunc) g_object_ref, (GDestroyNotify) g_object_unref, NULL, NULL, NULL);
	all = _tmp6_;
	while (TRUE) {
		sqlite3_stmt* _tmp7_;
		gint _tmp8_;
		ObjectsAlbum* album = NULL;
		ObjectsAlbum* _tmp9_;
		ObjectsAlbum* _tmp10_;
		sqlite3_stmt* _tmp11_;
		ObjectsAlbum* _tmp12_;
		sqlite3_stmt* _tmp13_;
		ObjectsAlbum* _tmp14_;
		sqlite3_stmt* _tmp15_;
		ObjectsAlbum* _tmp16_;
		sqlite3_stmt* _tmp17_;
		const gchar* _tmp18_;
		gchar* _tmp19_;
		ObjectsAlbum* _tmp20_;
		sqlite3_stmt* _tmp21_;
		const gchar* _tmp22_;
		gchar* _tmp23_;
		ObjectsAlbum* _tmp24_;
		sqlite3_stmt* _tmp25_;
		const gchar* _tmp26_;
		gchar* _tmp27_;
		GeeArrayList* _tmp28_;
		ObjectsAlbum* _tmp29_;
		_tmp7_ = stmt;
		res = sqlite3_step (_tmp7_);
		_tmp8_ = res;
		if (!(_tmp8_ == SQLITE_ROW)) {
			break;
		}
		_tmp9_ = objects_album_new (0, 0, "", 0, "", "");
		album = _tmp9_;
		_tmp10_ = album;
		_tmp11_ = stmt;
		_tmp10_->id = sqlite3_column_int (_tmp11_, 0);
		_tmp12_ = album;
		_tmp13_ = stmt;
		_tmp12_->artist_id = sqlite3_column_int (_tmp13_, 1);
		_tmp14_ = album;
		_tmp15_ = stmt;
		_tmp14_->year = sqlite3_column_int (_tmp15_, 2);
		_tmp16_ = album;
		_tmp17_ = stmt;
		_tmp18_ = sqlite3_column_text (_tmp17_, 3);
		_tmp19_ = g_strdup (_tmp18_);
		_g_free0 (_tmp16_->title);
		_tmp16_->title = _tmp19_;
		_tmp20_ = album;
		_tmp21_ = stmt;
		_tmp22_ = sqlite3_column_text (_tmp21_, 4);
		_tmp23_ = g_strdup (_tmp22_);
		_g_free0 (_tmp20_->genre);
		_tmp20_->genre = _tmp23_;
		_tmp24_ = album;
		_tmp25_ = stmt;
		_tmp26_ = sqlite3_column_text (_tmp25_, 5);
		_tmp27_ = g_strdup (_tmp26_);
		_g_free0 (_tmp24_->artist_name);
		_tmp24_->artist_name = _tmp27_;
		_tmp28_ = all;
		_tmp29_ = album;
		gee_abstract_collection_add ((GeeAbstractCollection*) _tmp28_, _tmp29_);
		_g_object_unref0 (album);
	}
	result = all;
	_g_free0 (sql);
	_sqlite3_finalize0 (stmt);
	return result;
}


GeeArrayList*
services_database_get_all_albums_order_by (ServicesDatabase* self,
                                           gint item,
                                           gboolean is_reverse)
{
	GeeArrayList* result = NULL;
	sqlite3_stmt* stmt = NULL;
	gchar* sql = NULL;
	gint res = 0;
	gchar* order_mode = NULL;
	gchar* _tmp0_;
	gchar* reverse_mode = NULL;
	gchar* _tmp1_;
	const gchar* _tmp7_;
	const gchar* _tmp8_;
	gchar* _tmp9_;
	sqlite3* _tmp10_;
	const gchar* _tmp11_;
	sqlite3_stmt* _tmp12_ = NULL;
	gint _tmp13_;
	gint _tmp14_;
	GeeArrayList* all = NULL;
	GeeArrayList* _tmp15_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = g_strdup ("albums.title");
	order_mode = _tmp0_;
	_tmp1_ = g_strdup ("DESC");
	reverse_mode = _tmp1_;
	if (item == 0) {
		gchar* _tmp2_;
		_tmp2_ = g_strdup ("albums.title");
		_g_free0 (order_mode);
		order_mode = _tmp2_;
	} else {
		if (item == 1) {
			gchar* _tmp3_;
			_tmp3_ = g_strdup ("artists.name");
			_g_free0 (order_mode);
			order_mode = _tmp3_;
		} else {
			if (item == 2) {
				gchar* _tmp4_;
				_tmp4_ = g_strdup ("albums.year");
				_g_free0 (order_mode);
				order_mode = _tmp4_;
			} else {
				if (item == 3) {
					gchar* _tmp5_;
					_tmp5_ = g_strdup ("albums.genre");
					_g_free0 (order_mode);
					order_mode = _tmp5_;
				}
			}
		}
	}
	if (is_reverse == FALSE) {
		gchar* _tmp6_;
		_tmp6_ = g_strdup ("ASC");
		_g_free0 (reverse_mode);
		reverse_mode = _tmp6_;
	}
	_tmp7_ = order_mode;
	_tmp8_ = reverse_mode;
	_tmp9_ = g_strdup_printf ("\n" \
"            SELECT albums.id, albums.artist_id, albums.year, albums.ti" \
"tle, albums.genre, artists.name from albums\n" \
"            INNER JOIN artists ON artists.id = albums.artist_id ORDER " \
"BY %s %s;\n" \
"        ", _tmp7_, _tmp8_);
	_g_free0 (sql);
	sql = _tmp9_;
	_tmp10_ = self->priv->db;
	_tmp11_ = sql;
	_tmp13_ = sqlite3_prepare_v2 (_tmp10_, _tmp11_, -1, &_tmp12_, NULL);
	_sqlite3_finalize0 (stmt);
	stmt = _tmp12_;
	res = _tmp13_;
	_tmp14_ = res;
	_vala_assert (_tmp14_ == SQLITE_OK, "res == Sqlite.OK");
	_tmp15_ = gee_array_list_new (OBJECTS_TYPE_ALBUM, (GBoxedCopyFunc) g_object_ref, (GDestroyNotify) g_object_unref, NULL, NULL, NULL);
	all = _tmp15_;
	while (TRUE) {
		sqlite3_stmt* _tmp16_;
		gint _tmp17_;
		ObjectsAlbum* album = NULL;
		ObjectsAlbum* _tmp18_;
		ObjectsAlbum* _tmp19_;
		sqlite3_stmt* _tmp20_;
		ObjectsAlbum* _tmp21_;
		sqlite3_stmt* _tmp22_;
		ObjectsAlbum* _tmp23_;
		sqlite3_stmt* _tmp24_;
		ObjectsAlbum* _tmp25_;
		sqlite3_stmt* _tmp26_;
		const gchar* _tmp27_;
		gchar* _tmp28_;
		ObjectsAlbum* _tmp29_;
		sqlite3_stmt* _tmp30_;
		const gchar* _tmp31_;
		gchar* _tmp32_;
		ObjectsAlbum* _tmp33_;
		sqlite3_stmt* _tmp34_;
		const gchar* _tmp35_;
		gchar* _tmp36_;
		GeeArrayList* _tmp37_;
		ObjectsAlbum* _tmp38_;
		_tmp16_ = stmt;
		res = sqlite3_step (_tmp16_);
		_tmp17_ = res;
		if (!(_tmp17_ == SQLITE_ROW)) {
			break;
		}
		_tmp18_ = objects_album_new (0, 0, "", 0, "", "");
		album = _tmp18_;
		_tmp19_ = album;
		_tmp20_ = stmt;
		_tmp19_->id = sqlite3_column_int (_tmp20_, 0);
		_tmp21_ = album;
		_tmp22_ = stmt;
		_tmp21_->artist_id = sqlite3_column_int (_tmp22_, 1);
		_tmp23_ = album;
		_tmp24_ = stmt;
		_tmp23_->year = sqlite3_column_int (_tmp24_, 2);
		_tmp25_ = album;
		_tmp26_ = stmt;
		_tmp27_ = sqlite3_column_text (_tmp26_, 3);
		_tmp28_ = g_strdup (_tmp27_);
		_g_free0 (_tmp25_->title);
		_tmp25_->title = _tmp28_;
		_tmp29_ = album;
		_tmp30_ = stmt;
		_tmp31_ = sqlite3_column_text (_tmp30_, 4);
		_tmp32_ = g_strdup (_tmp31_);
		_g_free0 (_tmp29_->genre);
		_tmp29_->genre = _tmp32_;
		_tmp33_ = album;
		_tmp34_ = stmt;
		_tmp35_ = sqlite3_column_text (_tmp34_, 5);
		_tmp36_ = g_strdup (_tmp35_);
		_g_free0 (_tmp33_->artist_name);
		_tmp33_->artist_name = _tmp36_;
		_tmp37_ = all;
		_tmp38_ = album;
		gee_abstract_collection_add ((GeeAbstractCollection*) _tmp37_, _tmp38_);
		_g_object_unref0 (album);
	}
	result = all;
	_g_free0 (reverse_mode);
	_g_free0 (order_mode);
	_g_free0 (sql);
	_sqlite3_finalize0 (stmt);
	return result;
}


GeeArrayList*
services_database_get_all_albums_search (ServicesDatabase* self,
                                         const gchar* search_text)
{
	GeeArrayList* result = NULL;
	sqlite3_stmt* stmt = NULL;
	gchar* sql = NULL;
	gint res = 0;
	gchar* _search_text = NULL;
	gchar* _tmp0_;
	gchar* _tmp1_;
	gchar* _tmp2_;
	gchar* _tmp3_;
	const gchar* _tmp4_;
	const gchar* _tmp5_;
	const gchar* _tmp6_;
	const gchar* _tmp7_;
	gchar* _tmp8_;
	sqlite3* _tmp9_;
	const gchar* _tmp10_;
	sqlite3_stmt* _tmp11_ = NULL;
	gint _tmp12_;
	gint _tmp13_;
	GeeArrayList* all = NULL;
	GeeArrayList* _tmp14_;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (search_text != NULL, NULL);
	_tmp0_ = g_strconcat ("%", search_text, NULL);
	_tmp1_ = _tmp0_;
	_tmp2_ = g_strconcat (_tmp1_, "%", NULL);
	_tmp3_ = _tmp2_;
	_g_free0 (_tmp1_);
	_search_text = _tmp3_;
	_tmp4_ = _search_text;
	_tmp5_ = _search_text;
	_tmp6_ = _search_text;
	_tmp7_ = _search_text;
	_tmp8_ = g_strdup_printf ("\n" \
"            SELECT albums.id, albums.artist_id, albums.year, albums.ti" \
"tle, albums.genre, artists.name from albums\n" \
"            INNER JOIN artists ON artists.id = albums.artist_id\n" \
"            WHERE albums.title LIKE '%s' OR\n" \
"            artists.name LIKE '%s' OR\n" \
"            albums.genre LIKE '%s' OR \n" \
"            albums.year LIKE '%s';\n" \
"        ", _tmp4_, _tmp5_, _tmp6_, _tmp7_);
	_g_free0 (sql);
	sql = _tmp8_;
	_tmp9_ = self->priv->db;
	_tmp10_ = sql;
	_tmp12_ = sqlite3_prepare_v2 (_tmp9_, _tmp10_, -1, &_tmp11_, NULL);
	_sqlite3_finalize0 (stmt);
	stmt = _tmp11_;
	res = _tmp12_;
	_tmp13_ = res;
	_vala_assert (_tmp13_ == SQLITE_OK, "res == Sqlite.OK");
	_tmp14_ = gee_array_list_new (OBJECTS_TYPE_ALBUM, (GBoxedCopyFunc) g_object_ref, (GDestroyNotify) g_object_unref, NULL, NULL, NULL);
	all = _tmp14_;
	while (TRUE) {
		sqlite3_stmt* _tmp15_;
		gint _tmp16_;
		ObjectsAlbum* album = NULL;
		ObjectsAlbum* _tmp17_;
		ObjectsAlbum* _tmp18_;
		sqlite3_stmt* _tmp19_;
		ObjectsAlbum* _tmp20_;
		sqlite3_stmt* _tmp21_;
		ObjectsAlbum* _tmp22_;
		sqlite3_stmt* _tmp23_;
		ObjectsAlbum* _tmp24_;
		sqlite3_stmt* _tmp25_;
		const gchar* _tmp26_;
		gchar* _tmp27_;
		ObjectsAlbum* _tmp28_;
		sqlite3_stmt* _tmp29_;
		const gchar* _tmp30_;
		gchar* _tmp31_;
		ObjectsAlbum* _tmp32_;
		sqlite3_stmt* _tmp33_;
		const gchar* _tmp34_;
		gchar* _tmp35_;
		GeeArrayList* _tmp36_;
		ObjectsAlbum* _tmp37_;
		_tmp15_ = stmt;
		res = sqlite3_step (_tmp15_);
		_tmp16_ = res;
		if (!(_tmp16_ == SQLITE_ROW)) {
			break;
		}
		_tmp17_ = objects_album_new (0, 0, "", 0, "", "");
		album = _tmp17_;
		_tmp18_ = album;
		_tmp19_ = stmt;
		_tmp18_->id = sqlite3_column_int (_tmp19_, 0);
		_tmp20_ = album;
		_tmp21_ = stmt;
		_tmp20_->artist_id = sqlite3_column_int (_tmp21_, 1);
		_tmp22_ = album;
		_tmp23_ = stmt;
		_tmp22_->year = sqlite3_column_int (_tmp23_, 2);
		_tmp24_ = album;
		_tmp25_ = stmt;
		_tmp26_ = sqlite3_column_text (_tmp25_, 3);
		_tmp27_ = g_strdup (_tmp26_);
		_g_free0 (_tmp24_->title);
		_tmp24_->title = _tmp27_;
		_tmp28_ = album;
		_tmp29_ = stmt;
		_tmp30_ = sqlite3_column_text (_tmp29_, 4);
		_tmp31_ = g_strdup (_tmp30_);
		_g_free0 (_tmp28_->genre);
		_tmp28_->genre = _tmp31_;
		_tmp32_ = album;
		_tmp33_ = stmt;
		_tmp34_ = sqlite3_column_text (_tmp33_, 5);
		_tmp35_ = g_strdup (_tmp34_);
		_g_free0 (_tmp32_->artist_name);
		_tmp32_->artist_name = _tmp35_;
		_tmp36_ = all;
		_tmp37_ = album;
		gee_abstract_collection_add ((GeeAbstractCollection*) _tmp36_, _tmp37_);
		_g_object_unref0 (album);
	}
	result = all;
	_g_free0 (_search_text);
	_g_free0 (sql);
	_sqlite3_finalize0 (stmt);
	return result;
}


GeeArrayList*
services_database_get_tracks_recently_added (ServicesDatabase* self)
{
	GeeArrayList* result = NULL;
	sqlite3_stmt* stmt = NULL;
	gchar* sql = NULL;
	gint res = 0;
	gchar* _tmp0_;
	sqlite3* _tmp1_;
	const gchar* _tmp2_;
	sqlite3_stmt* _tmp3_ = NULL;
	gint _tmp4_;
	gint _tmp5_;
	GeeArrayList* all = NULL;
	GeeArrayList* _tmp6_;
	gint index = 0;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = g_strdup ("\n" \
"            SELECT tracks.id, tracks.path, tracks.title, tracks.durati" \
"on, tracks.is_favorite, tracks.date_added, \n" \
"            tracks.album_id, albums.title, artists.name, tracks.favori" \
"te_added, tracks.last_played FROM tracks \n" \
"            INNER JOIN albums ON tracks.album_id = albums.id\n" \
"            INNER JOIN artists ON albums.artist_id = artists.id ORDER " \
"BY tracks.date_added DESC LIMIT 100;\n" \
"        ");
	_g_free0 (sql);
	sql = _tmp0_;
	_tmp1_ = self->priv->db;
	_tmp2_ = sql;
	_tmp4_ = sqlite3_prepare_v2 (_tmp1_, _tmp2_, -1, &_tmp3_, NULL);
	_sqlite3_finalize0 (stmt);
	stmt = _tmp3_;
	res = _tmp4_;
	_tmp5_ = res;
	_vala_assert (_tmp5_ == SQLITE_OK, "res == Sqlite.OK");
	_tmp6_ = gee_array_list_new (OBJECTS_TYPE_TRACK, (GBoxedCopyFunc) g_object_ref, (GDestroyNotify) g_object_unref, NULL, NULL, NULL);
	all = _tmp6_;
	index = 0;
	while (TRUE) {
		sqlite3_stmt* _tmp7_;
		gint _tmp8_;
		ObjectsTrack* track = NULL;
		GDateTime* _tmp9_;
		GDateTime* _tmp10_;
		gchar* _tmp11_;
		gchar* _tmp12_;
		ObjectsTrack* _tmp13_;
		ObjectsTrack* _tmp14_;
		ObjectsTrack* _tmp15_;
		gint _tmp16_;
		ObjectsTrack* _tmp17_;
		sqlite3_stmt* _tmp18_;
		ObjectsTrack* _tmp19_;
		sqlite3_stmt* _tmp20_;
		const gchar* _tmp21_;
		gchar* _tmp22_;
		ObjectsTrack* _tmp23_;
		sqlite3_stmt* _tmp24_;
		const gchar* _tmp25_;
		gchar* _tmp26_;
		ObjectsTrack* _tmp27_;
		sqlite3_stmt* _tmp28_;
		ObjectsTrack* _tmp29_;
		sqlite3_stmt* _tmp30_;
		ObjectsTrack* _tmp31_;
		sqlite3_stmt* _tmp32_;
		const gchar* _tmp33_;
		gchar* _tmp34_;
		ObjectsTrack* _tmp35_;
		sqlite3_stmt* _tmp36_;
		ObjectsTrack* _tmp37_;
		sqlite3_stmt* _tmp38_;
		const gchar* _tmp39_;
		gchar* _tmp40_;
		ObjectsTrack* _tmp41_;
		sqlite3_stmt* _tmp42_;
		const gchar* _tmp43_;
		gchar* _tmp44_;
		ObjectsTrack* _tmp45_;
		sqlite3_stmt* _tmp46_;
		const gchar* _tmp47_;
		gchar* _tmp48_;
		ObjectsTrack* _tmp49_;
		sqlite3_stmt* _tmp50_;
		const gchar* _tmp51_;
		gchar* _tmp52_;
		GeeArrayList* _tmp53_;
		ObjectsTrack* _tmp54_;
		gint _tmp55_;
		_tmp7_ = stmt;
		res = sqlite3_step (_tmp7_);
		_tmp8_ = res;
		if (!(_tmp8_ == SQLITE_ROW)) {
			break;
		}
		_tmp9_ = g_date_time_new_now_local ();
		_tmp10_ = _tmp9_;
		_tmp11_ = g_date_time_to_string (_tmp10_);
		_tmp12_ = _tmp11_;
		_tmp13_ = objects_track_new (0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (guint64) 0, "", "", "", "", "", "", "", "", "", "", "", "", _tmp12_);
		_tmp14_ = _tmp13_;
		_g_free0 (_tmp12_);
		_g_date_time_unref0 (_tmp10_);
		track = _tmp14_;
		_tmp15_ = track;
		_tmp16_ = index;
		_tmp15_->track_order = _tmp16_;
		_tmp17_ = track;
		_tmp18_ = stmt;
		_tmp17_->id = sqlite3_column_int (_tmp18_, 0);
		_tmp19_ = track;
		_tmp20_ = stmt;
		_tmp21_ = sqlite3_column_text (_tmp20_, 1);
		_tmp22_ = g_strdup (_tmp21_);
		_g_free0 (_tmp19_->path);
		_tmp19_->path = _tmp22_;
		_tmp23_ = track;
		_tmp24_ = stmt;
		_tmp25_ = sqlite3_column_text (_tmp24_, 2);
		_tmp26_ = g_strdup (_tmp25_);
		_g_free0 (_tmp23_->title);
		_tmp23_->title = _tmp26_;
		_tmp27_ = track;
		_tmp28_ = stmt;
		_tmp27_->duration = (guint64) sqlite3_column_int64 (_tmp28_, 3);
		_tmp29_ = track;
		_tmp30_ = stmt;
		_tmp29_->is_favorite = sqlite3_column_int (_tmp30_, 4);
		_tmp31_ = track;
		_tmp32_ = stmt;
		_tmp33_ = sqlite3_column_text (_tmp32_, 5);
		_tmp34_ = g_strdup (_tmp33_);
		_g_free0 (_tmp31_->date_added);
		_tmp31_->date_added = _tmp34_;
		_tmp35_ = track;
		_tmp36_ = stmt;
		_tmp35_->album_id = sqlite3_column_int (_tmp36_, 6);
		_tmp37_ = track;
		_tmp38_ = stmt;
		_tmp39_ = sqlite3_column_text (_tmp38_, 7);
		_tmp40_ = g_strdup (_tmp39_);
		_g_free0 (_tmp37_->album_title);
		_tmp37_->album_title = _tmp40_;
		_tmp41_ = track;
		_tmp42_ = stmt;
		_tmp43_ = sqlite3_column_text (_tmp42_, 8);
		_tmp44_ = g_strdup (_tmp43_);
		_g_free0 (_tmp41_->artist_name);
		_tmp41_->artist_name = _tmp44_;
		_tmp45_ = track;
		_tmp46_ = stmt;
		_tmp47_ = sqlite3_column_text (_tmp46_, 9);
		_tmp48_ = g_strdup (_tmp47_);
		_g_free0 (_tmp45_->favorite_added);
		_tmp45_->favorite_added = _tmp48_;
		_tmp49_ = track;
		_tmp50_ = stmt;
		_tmp51_ = sqlite3_column_text (_tmp50_, 10);
		_tmp52_ = g_strdup (_tmp51_);
		_g_free0 (_tmp49_->last_played);
		_tmp49_->last_played = _tmp52_;
		_tmp53_ = all;
		_tmp54_ = track;
		gee_abstract_collection_add ((GeeAbstractCollection*) _tmp53_, _tmp54_);
		_tmp55_ = index;
		index = _tmp55_ + 1;
		_g_object_unref0 (track);
	}
	result = all;
	_g_free0 (sql);
	_sqlite3_finalize0 (stmt);
	return result;
}


GeeArrayList*
services_database_get_all_tracks_by_artist (ServicesDatabase* self,
                                            gint id)
{
	GeeArrayList* result = NULL;
	sqlite3_stmt* stmt = NULL;
	gchar* sql = NULL;
	gint res = 0;
	gchar* _tmp0_;
	sqlite3* _tmp1_;
	const gchar* _tmp2_;
	sqlite3_stmt* _tmp3_ = NULL;
	gint _tmp4_;
	gint _tmp5_;
	sqlite3_stmt* _tmp6_;
	gint _tmp7_;
	GeeArrayList* all = NULL;
	GeeArrayList* _tmp8_;
	gint index = 0;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = g_strdup ("\n" \
"            SELECT tracks.id, tracks.path, tracks.title, tracks.durati" \
"on, tracks.is_favorite, tracks.date_added, \n" \
"            tracks.album_id, albums.title, artists.id, artists.name, t" \
"racks.favorite_added, tracks.last_played, tracks.play_count FROM track" \
"s \n" \
"            INNER JOIN albums ON tracks.album_id = albums.id\n" \
"            INNER JOIN artists ON albums.artist_id = artists.id WHERE " \
"artists.id = ? ORDER BY tracks.play_count DESC;\n" \
"        ");
	_g_free0 (sql);
	sql = _tmp0_;
	_tmp1_ = self->priv->db;
	_tmp2_ = sql;
	_tmp4_ = sqlite3_prepare_v2 (_tmp1_, _tmp2_, -1, &_tmp3_, NULL);
	_sqlite3_finalize0 (stmt);
	stmt = _tmp3_;
	res = _tmp4_;
	_tmp5_ = res;
	_vala_assert (_tmp5_ == SQLITE_OK, "res == Sqlite.OK");
	_tmp6_ = stmt;
	res = sqlite3_bind_int (_tmp6_, 1, id);
	_tmp7_ = res;
	_vala_assert (_tmp7_ == SQLITE_OK, "res == Sqlite.OK");
	_tmp8_ = gee_array_list_new (OBJECTS_TYPE_TRACK, (GBoxedCopyFunc) g_object_ref, (GDestroyNotify) g_object_unref, NULL, NULL, NULL);
	all = _tmp8_;
	index = 0;
	while (TRUE) {
		sqlite3_stmt* _tmp9_;
		gint _tmp10_;
		ObjectsTrack* track = NULL;
		GDateTime* _tmp11_;
		GDateTime* _tmp12_;
		gchar* _tmp13_;
		gchar* _tmp14_;
		ObjectsTrack* _tmp15_;
		ObjectsTrack* _tmp16_;
		ObjectsTrack* _tmp17_;
		gint _tmp18_;
		ObjectsTrack* _tmp19_;
		sqlite3_stmt* _tmp20_;
		ObjectsTrack* _tmp21_;
		sqlite3_stmt* _tmp22_;
		const gchar* _tmp23_;
		gchar* _tmp24_;
		ObjectsTrack* _tmp25_;
		sqlite3_stmt* _tmp26_;
		const gchar* _tmp27_;
		gchar* _tmp28_;
		ObjectsTrack* _tmp29_;
		sqlite3_stmt* _tmp30_;
		ObjectsTrack* _tmp31_;
		sqlite3_stmt* _tmp32_;
		ObjectsTrack* _tmp33_;
		sqlite3_stmt* _tmp34_;
		const gchar* _tmp35_;
		gchar* _tmp36_;
		ObjectsTrack* _tmp37_;
		sqlite3_stmt* _tmp38_;
		ObjectsTrack* _tmp39_;
		sqlite3_stmt* _tmp40_;
		const gchar* _tmp41_;
		gchar* _tmp42_;
		ObjectsTrack* _tmp43_;
		sqlite3_stmt* _tmp44_;
		const gchar* _tmp45_;
		gchar* _tmp46_;
		ObjectsTrack* _tmp47_;
		sqlite3_stmt* _tmp48_;
		const gchar* _tmp49_;
		gchar* _tmp50_;
		ObjectsTrack* _tmp51_;
		sqlite3_stmt* _tmp52_;
		const gchar* _tmp53_;
		gchar* _tmp54_;
		ObjectsTrack* _tmp55_;
		sqlite3_stmt* _tmp56_;
		GeeArrayList* _tmp57_;
		ObjectsTrack* _tmp58_;
		gint _tmp59_;
		_tmp9_ = stmt;
		res = sqlite3_step (_tmp9_);
		_tmp10_ = res;
		if (!(_tmp10_ == SQLITE_ROW)) {
			break;
		}
		_tmp11_ = g_date_time_new_now_local ();
		_tmp12_ = _tmp11_;
		_tmp13_ = g_date_time_to_string (_tmp12_);
		_tmp14_ = _tmp13_;
		_tmp15_ = objects_track_new (0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (guint64) 0, "", "", "", "", "", "", "", "", "", "", "", "", _tmp14_);
		_tmp16_ = _tmp15_;
		_g_free0 (_tmp14_);
		_g_date_time_unref0 (_tmp12_);
		track = _tmp16_;
		_tmp17_ = track;
		_tmp18_ = index;
		_tmp17_->track_order = _tmp18_;
		_tmp19_ = track;
		_tmp20_ = stmt;
		_tmp19_->id = sqlite3_column_int (_tmp20_, 0);
		_tmp21_ = track;
		_tmp22_ = stmt;
		_tmp23_ = sqlite3_column_text (_tmp22_, 1);
		_tmp24_ = g_strdup (_tmp23_);
		_g_free0 (_tmp21_->path);
		_tmp21_->path = _tmp24_;
		_tmp25_ = track;
		_tmp26_ = stmt;
		_tmp27_ = sqlite3_column_text (_tmp26_, 2);
		_tmp28_ = g_strdup (_tmp27_);
		_g_free0 (_tmp25_->title);
		_tmp25_->title = _tmp28_;
		_tmp29_ = track;
		_tmp30_ = stmt;
		_tmp29_->duration = (guint64) sqlite3_column_int64 (_tmp30_, 3);
		_tmp31_ = track;
		_tmp32_ = stmt;
		_tmp31_->is_favorite = sqlite3_column_int (_tmp32_, 4);
		_tmp33_ = track;
		_tmp34_ = stmt;
		_tmp35_ = sqlite3_column_text (_tmp34_, 5);
		_tmp36_ = g_strdup (_tmp35_);
		_g_free0 (_tmp33_->date_added);
		_tmp33_->date_added = _tmp36_;
		_tmp37_ = track;
		_tmp38_ = stmt;
		_tmp37_->album_id = sqlite3_column_int (_tmp38_, 6);
		_tmp39_ = track;
		_tmp40_ = stmt;
		_tmp41_ = sqlite3_column_text (_tmp40_, 7);
		_tmp42_ = g_strdup (_tmp41_);
		_g_free0 (_tmp39_->album_title);
		_tmp39_->album_title = _tmp42_;
		_tmp43_ = track;
		_tmp44_ = stmt;
		_tmp45_ = sqlite3_column_text (_tmp44_, 9);
		_tmp46_ = g_strdup (_tmp45_);
		_g_free0 (_tmp43_->artist_name);
		_tmp43_->artist_name = _tmp46_;
		_tmp47_ = track;
		_tmp48_ = stmt;
		_tmp49_ = sqlite3_column_text (_tmp48_, 10);
		_tmp50_ = g_strdup (_tmp49_);
		_g_free0 (_tmp47_->favorite_added);
		_tmp47_->favorite_added = _tmp50_;
		_tmp51_ = track;
		_tmp52_ = stmt;
		_tmp53_ = sqlite3_column_text (_tmp52_, 11);
		_tmp54_ = g_strdup (_tmp53_);
		_g_free0 (_tmp51_->last_played);
		_tmp51_->last_played = _tmp54_;
		_tmp55_ = track;
		_tmp56_ = stmt;
		_tmp55_->play_count = sqlite3_column_int (_tmp56_, 12);
		_tmp57_ = all;
		_tmp58_ = track;
		gee_abstract_collection_add ((GeeAbstractCollection*) _tmp57_, _tmp58_);
		_tmp59_ = index;
		index = _tmp59_ + 1;
		_g_object_unref0 (track);
	}
	result = all;
	_g_free0 (sql);
	_sqlite3_finalize0 (stmt);
	return result;
}


GeeArrayList*
services_database_get_all_tracks_order_by (ServicesDatabase* self,
                                           gint item,
                                           gboolean is_reverse)
{
	GeeArrayList* result = NULL;
	sqlite3_stmt* stmt = NULL;
	gchar* sql = NULL;
	gint res = 0;
	gchar* order_mode = NULL;
	gchar* _tmp0_;
	gchar* reverse_mode = NULL;
	gchar* _tmp1_;
	const gchar* _tmp8_;
	const gchar* _tmp9_;
	gchar* _tmp10_;
	sqlite3* _tmp11_;
	const gchar* _tmp12_;
	sqlite3_stmt* _tmp13_ = NULL;
	gint _tmp14_;
	gint _tmp15_;
	GeeArrayList* all = NULL;
	GeeArrayList* _tmp16_;
	gint index = 0;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = g_strdup ("tracks.title");
	order_mode = _tmp0_;
	_tmp1_ = g_strdup ("DESC");
	reverse_mode = _tmp1_;
	if (item == 0) {
		gchar* _tmp2_;
		_tmp2_ = g_strdup ("tracks.title");
		_g_free0 (order_mode);
		order_mode = _tmp2_;
	} else {
		if (item == 1) {
			gchar* _tmp3_;
			_tmp3_ = g_strdup ("artists.name");
			_g_free0 (order_mode);
			order_mode = _tmp3_;
		} else {
			if (item == 2) {
				gchar* _tmp4_;
				_tmp4_ = g_strdup ("albums.title");
				_g_free0 (order_mode);
				order_mode = _tmp4_;
			} else {
				if (item == 3) {
					gchar* _tmp5_;
					_tmp5_ = g_strdup ("tracks.date_added");
					_g_free0 (order_mode);
					order_mode = _tmp5_;
				} else {
					gchar* _tmp6_;
					_tmp6_ = g_strdup ("tracks.play_count");
					_g_free0 (order_mode);
					order_mode = _tmp6_;
				}
			}
		}
	}
	if (is_reverse == FALSE) {
		gchar* _tmp7_;
		_tmp7_ = g_strdup ("ASC");
		_g_free0 (reverse_mode);
		reverse_mode = _tmp7_;
	}
	_tmp8_ = order_mode;
	_tmp9_ = reverse_mode;
	_tmp10_ = g_strdup_printf ("\n" \
"            SELECT  tracks.id, tracks.path, tracks.title, tracks.durat" \
"ion, tracks.is_favorite,tracks.date_added, tracks.play_count, \n" \
"            tracks.album_id, albums.title, artists.name, tracks.favori" \
"te_added, tracks.last_played FROM tracks \n" \
"            INNER JOIN albums ON tracks.album_id = albums.id\n" \
"            INNER JOIN artists ON albums.artist_id = artists.id ORDER " \
"BY %s %s;\n" \
"        ", _tmp8_, _tmp9_);
	_g_free0 (sql);
	sql = _tmp10_;
	_tmp11_ = self->priv->db;
	_tmp12_ = sql;
	_tmp14_ = sqlite3_prepare_v2 (_tmp11_, _tmp12_, -1, &_tmp13_, NULL);
	_sqlite3_finalize0 (stmt);
	stmt = _tmp13_;
	res = _tmp14_;
	_tmp15_ = res;
	_vala_assert (_tmp15_ == SQLITE_OK, "res == Sqlite.OK");
	_tmp16_ = gee_array_list_new (OBJECTS_TYPE_TRACK, (GBoxedCopyFunc) g_object_ref, (GDestroyNotify) g_object_unref, NULL, NULL, NULL);
	all = _tmp16_;
	index = 0;
	while (TRUE) {
		sqlite3_stmt* _tmp17_;
		gint _tmp18_;
		ObjectsTrack* track = NULL;
		GDateTime* _tmp19_;
		GDateTime* _tmp20_;
		gchar* _tmp21_;
		gchar* _tmp22_;
		ObjectsTrack* _tmp23_;
		ObjectsTrack* _tmp24_;
		ObjectsTrack* _tmp25_;
		gint _tmp26_;
		ObjectsTrack* _tmp27_;
		sqlite3_stmt* _tmp28_;
		ObjectsTrack* _tmp29_;
		sqlite3_stmt* _tmp30_;
		const gchar* _tmp31_;
		gchar* _tmp32_;
		ObjectsTrack* _tmp33_;
		sqlite3_stmt* _tmp34_;
		const gchar* _tmp35_;
		gchar* _tmp36_;
		ObjectsTrack* _tmp37_;
		sqlite3_stmt* _tmp38_;
		ObjectsTrack* _tmp39_;
		sqlite3_stmt* _tmp40_;
		ObjectsTrack* _tmp41_;
		sqlite3_stmt* _tmp42_;
		const gchar* _tmp43_;
		gchar* _tmp44_;
		ObjectsTrack* _tmp45_;
		sqlite3_stmt* _tmp46_;
		ObjectsTrack* _tmp47_;
		sqlite3_stmt* _tmp48_;
		ObjectsTrack* _tmp49_;
		sqlite3_stmt* _tmp50_;
		const gchar* _tmp51_;
		gchar* _tmp52_;
		ObjectsTrack* _tmp53_;
		sqlite3_stmt* _tmp54_;
		const gchar* _tmp55_;
		gchar* _tmp56_;
		ObjectsTrack* _tmp57_;
		sqlite3_stmt* _tmp58_;
		const gchar* _tmp59_;
		gchar* _tmp60_;
		ObjectsTrack* _tmp61_;
		sqlite3_stmt* _tmp62_;
		const gchar* _tmp63_;
		gchar* _tmp64_;
		GeeArrayList* _tmp65_;
		ObjectsTrack* _tmp66_;
		gint _tmp67_;
		_tmp17_ = stmt;
		res = sqlite3_step (_tmp17_);
		_tmp18_ = res;
		if (!(_tmp18_ == SQLITE_ROW)) {
			break;
		}
		_tmp19_ = g_date_time_new_now_local ();
		_tmp20_ = _tmp19_;
		_tmp21_ = g_date_time_to_string (_tmp20_);
		_tmp22_ = _tmp21_;
		_tmp23_ = objects_track_new (0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (guint64) 0, "", "", "", "", "", "", "", "", "", "", "", "", _tmp22_);
		_tmp24_ = _tmp23_;
		_g_free0 (_tmp22_);
		_g_date_time_unref0 (_tmp20_);
		track = _tmp24_;
		_tmp25_ = track;
		_tmp26_ = index;
		_tmp25_->track_order = _tmp26_;
		_tmp27_ = track;
		_tmp28_ = stmt;
		_tmp27_->id = sqlite3_column_int (_tmp28_, 0);
		_tmp29_ = track;
		_tmp30_ = stmt;
		_tmp31_ = sqlite3_column_text (_tmp30_, 1);
		_tmp32_ = g_strdup (_tmp31_);
		_g_free0 (_tmp29_->path);
		_tmp29_->path = _tmp32_;
		_tmp33_ = track;
		_tmp34_ = stmt;
		_tmp35_ = sqlite3_column_text (_tmp34_, 2);
		_tmp36_ = g_strdup (_tmp35_);
		_g_free0 (_tmp33_->title);
		_tmp33_->title = _tmp36_;
		_tmp37_ = track;
		_tmp38_ = stmt;
		_tmp37_->duration = (guint64) sqlite3_column_int64 (_tmp38_, 3);
		_tmp39_ = track;
		_tmp40_ = stmt;
		_tmp39_->is_favorite = sqlite3_column_int (_tmp40_, 4);
		_tmp41_ = track;
		_tmp42_ = stmt;
		_tmp43_ = sqlite3_column_text (_tmp42_, 5);
		_tmp44_ = g_strdup (_tmp43_);
		_g_free0 (_tmp41_->date_added);
		_tmp41_->date_added = _tmp44_;
		_tmp45_ = track;
		_tmp46_ = stmt;
		_tmp45_->play_count = sqlite3_column_int (_tmp46_, 6);
		_tmp47_ = track;
		_tmp48_ = stmt;
		_tmp47_->album_id = sqlite3_column_int (_tmp48_, 7);
		_tmp49_ = track;
		_tmp50_ = stmt;
		_tmp51_ = sqlite3_column_text (_tmp50_, 8);
		_tmp52_ = g_strdup (_tmp51_);
		_g_free0 (_tmp49_->album_title);
		_tmp49_->album_title = _tmp52_;
		_tmp53_ = track;
		_tmp54_ = stmt;
		_tmp55_ = sqlite3_column_text (_tmp54_, 9);
		_tmp56_ = g_strdup (_tmp55_);
		_g_free0 (_tmp53_->artist_name);
		_tmp53_->artist_name = _tmp56_;
		_tmp57_ = track;
		_tmp58_ = stmt;
		_tmp59_ = sqlite3_column_text (_tmp58_, 10);
		_tmp60_ = g_strdup (_tmp59_);
		_g_free0 (_tmp57_->favorite_added);
		_tmp57_->favorite_added = _tmp60_;
		_tmp61_ = track;
		_tmp62_ = stmt;
		_tmp63_ = sqlite3_column_text (_tmp62_, 11);
		_tmp64_ = g_strdup (_tmp63_);
		_g_free0 (_tmp61_->last_played);
		_tmp61_->last_played = _tmp64_;
		_tmp65_ = all;
		_tmp66_ = track;
		gee_abstract_collection_add ((GeeAbstractCollection*) _tmp65_, _tmp66_);
		_tmp67_ = index;
		index = _tmp67_ + 1;
		_g_object_unref0 (track);
	}
	result = all;
	_g_free0 (reverse_mode);
	_g_free0 (order_mode);
	_g_free0 (sql);
	_sqlite3_finalize0 (stmt);
	return result;
}


GeeArrayList*
services_database_get_all_tracks_favorites (ServicesDatabase* self)
{
	GeeArrayList* result = NULL;
	sqlite3_stmt* stmt = NULL;
	gchar* sql = NULL;
	gint res = 0;
	gchar* _tmp0_;
	sqlite3* _tmp1_;
	const gchar* _tmp2_;
	sqlite3_stmt* _tmp3_ = NULL;
	gint _tmp4_;
	gint _tmp5_;
	GeeArrayList* all = NULL;
	GeeArrayList* _tmp6_;
	gint index = 0;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = g_strdup ("\n" \
"            SELECT  tracks.id, tracks.path, tracks.title, tracks.durat" \
"ion, tracks.is_favorite, tracks.date_added, tracks.play_count, \n" \
"            tracks.album_id, albums.title, artists.name, tracks.favori" \
"te_added, tracks.last_played FROM tracks \n" \
"            INNER JOIN albums ON tracks.album_id = albums.id\n" \
"            INNER JOIN artists ON albums.artist_id = artists.id \n" \
"            WHERE tracks.is_favorite = 1 ORDER BY tracks.favorite_adde" \
"d;\n" \
"        ");
	_g_free0 (sql);
	sql = _tmp0_;
	_tmp1_ = self->priv->db;
	_tmp2_ = sql;
	_tmp4_ = sqlite3_prepare_v2 (_tmp1_, _tmp2_, -1, &_tmp3_, NULL);
	_sqlite3_finalize0 (stmt);
	stmt = _tmp3_;
	res = _tmp4_;
	_tmp5_ = res;
	_vala_assert (_tmp5_ == SQLITE_OK, "res == Sqlite.OK");
	_tmp6_ = gee_array_list_new (OBJECTS_TYPE_TRACK, (GBoxedCopyFunc) g_object_ref, (GDestroyNotify) g_object_unref, NULL, NULL, NULL);
	all = _tmp6_;
	index = 0;
	while (TRUE) {
		sqlite3_stmt* _tmp7_;
		gint _tmp8_;
		ObjectsTrack* track = NULL;
		GDateTime* _tmp9_;
		GDateTime* _tmp10_;
		gchar* _tmp11_;
		gchar* _tmp12_;
		ObjectsTrack* _tmp13_;
		ObjectsTrack* _tmp14_;
		ObjectsTrack* _tmp15_;
		gint _tmp16_;
		ObjectsTrack* _tmp17_;
		sqlite3_stmt* _tmp18_;
		ObjectsTrack* _tmp19_;
		sqlite3_stmt* _tmp20_;
		const gchar* _tmp21_;
		gchar* _tmp22_;
		ObjectsTrack* _tmp23_;
		sqlite3_stmt* _tmp24_;
		const gchar* _tmp25_;
		gchar* _tmp26_;
		ObjectsTrack* _tmp27_;
		sqlite3_stmt* _tmp28_;
		ObjectsTrack* _tmp29_;
		sqlite3_stmt* _tmp30_;
		ObjectsTrack* _tmp31_;
		sqlite3_stmt* _tmp32_;
		const gchar* _tmp33_;
		gchar* _tmp34_;
		ObjectsTrack* _tmp35_;
		sqlite3_stmt* _tmp36_;
		ObjectsTrack* _tmp37_;
		sqlite3_stmt* _tmp38_;
		ObjectsTrack* _tmp39_;
		sqlite3_stmt* _tmp40_;
		const gchar* _tmp41_;
		gchar* _tmp42_;
		ObjectsTrack* _tmp43_;
		sqlite3_stmt* _tmp44_;
		const gchar* _tmp45_;
		gchar* _tmp46_;
		ObjectsTrack* _tmp47_;
		sqlite3_stmt* _tmp48_;
		const gchar* _tmp49_;
		gchar* _tmp50_;
		ObjectsTrack* _tmp51_;
		sqlite3_stmt* _tmp52_;
		const gchar* _tmp53_;
		gchar* _tmp54_;
		GeeArrayList* _tmp55_;
		ObjectsTrack* _tmp56_;
		gint _tmp57_;
		_tmp7_ = stmt;
		res = sqlite3_step (_tmp7_);
		_tmp8_ = res;
		if (!(_tmp8_ == SQLITE_ROW)) {
			break;
		}
		_tmp9_ = g_date_time_new_now_local ();
		_tmp10_ = _tmp9_;
		_tmp11_ = g_date_time_to_string (_tmp10_);
		_tmp12_ = _tmp11_;
		_tmp13_ = objects_track_new (0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (guint64) 0, "", "", "", "", "", "", "", "", "", "", "", "", _tmp12_);
		_tmp14_ = _tmp13_;
		_g_free0 (_tmp12_);
		_g_date_time_unref0 (_tmp10_);
		track = _tmp14_;
		_tmp15_ = track;
		_tmp16_ = index;
		_tmp15_->track_order = _tmp16_;
		_tmp17_ = track;
		_tmp18_ = stmt;
		_tmp17_->id = sqlite3_column_int (_tmp18_, 0);
		_tmp19_ = track;
		_tmp20_ = stmt;
		_tmp21_ = sqlite3_column_text (_tmp20_, 1);
		_tmp22_ = g_strdup (_tmp21_);
		_g_free0 (_tmp19_->path);
		_tmp19_->path = _tmp22_;
		_tmp23_ = track;
		_tmp24_ = stmt;
		_tmp25_ = sqlite3_column_text (_tmp24_, 2);
		_tmp26_ = g_strdup (_tmp25_);
		_g_free0 (_tmp23_->title);
		_tmp23_->title = _tmp26_;
		_tmp27_ = track;
		_tmp28_ = stmt;
		_tmp27_->duration = (guint64) sqlite3_column_int64 (_tmp28_, 3);
		_tmp29_ = track;
		_tmp30_ = stmt;
		_tmp29_->is_favorite = sqlite3_column_int (_tmp30_, 4);
		_tmp31_ = track;
		_tmp32_ = stmt;
		_tmp33_ = sqlite3_column_text (_tmp32_, 5);
		_tmp34_ = g_strdup (_tmp33_);
		_g_free0 (_tmp31_->date_added);
		_tmp31_->date_added = _tmp34_;
		_tmp35_ = track;
		_tmp36_ = stmt;
		_tmp35_->play_count = sqlite3_column_int (_tmp36_, 6);
		_tmp37_ = track;
		_tmp38_ = stmt;
		_tmp37_->album_id = sqlite3_column_int (_tmp38_, 7);
		_tmp39_ = track;
		_tmp40_ = stmt;
		_tmp41_ = sqlite3_column_text (_tmp40_, 8);
		_tmp42_ = g_strdup (_tmp41_);
		_g_free0 (_tmp39_->album_title);
		_tmp39_->album_title = _tmp42_;
		_tmp43_ = track;
		_tmp44_ = stmt;
		_tmp45_ = sqlite3_column_text (_tmp44_, 9);
		_tmp46_ = g_strdup (_tmp45_);
		_g_free0 (_tmp43_->artist_name);
		_tmp43_->artist_name = _tmp46_;
		_tmp47_ = track;
		_tmp48_ = stmt;
		_tmp49_ = sqlite3_column_text (_tmp48_, 10);
		_tmp50_ = g_strdup (_tmp49_);
		_g_free0 (_tmp47_->favorite_added);
		_tmp47_->favorite_added = _tmp50_;
		_tmp51_ = track;
		_tmp52_ = stmt;
		_tmp53_ = sqlite3_column_text (_tmp52_, 11);
		_tmp54_ = g_strdup (_tmp53_);
		_g_free0 (_tmp51_->last_played);
		_tmp51_->last_played = _tmp54_;
		_tmp55_ = all;
		_tmp56_ = track;
		gee_abstract_collection_add ((GeeAbstractCollection*) _tmp55_, _tmp56_);
		_tmp57_ = index;
		index = _tmp57_ + 1;
		_g_object_unref0 (track);
	}
	result = all;
	_g_free0 (sql);
	_sqlite3_finalize0 (stmt);
	return result;
}


GeeArrayList*
services_database_get_all_tracks_favorites_search (ServicesDatabase* self,
                                                   const gchar* search_text)
{
	GeeArrayList* result = NULL;
	sqlite3_stmt* stmt = NULL;
	gchar* sql = NULL;
	gint res = 0;
	gchar* _search_text = NULL;
	gchar* _tmp0_;
	gchar* _tmp1_;
	gchar* _tmp2_;
	gchar* _tmp3_;
	const gchar* _tmp4_;
	const gchar* _tmp5_;
	const gchar* _tmp6_;
	gchar* _tmp7_;
	sqlite3* _tmp8_;
	const gchar* _tmp9_;
	sqlite3_stmt* _tmp10_ = NULL;
	gint _tmp11_;
	gint _tmp12_;
	GeeArrayList* all = NULL;
	GeeArrayList* _tmp13_;
	gint index = 0;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (search_text != NULL, NULL);
	_tmp0_ = g_strconcat ("%", search_text, NULL);
	_tmp1_ = _tmp0_;
	_tmp2_ = g_strconcat (_tmp1_, "%", NULL);
	_tmp3_ = _tmp2_;
	_g_free0 (_tmp1_);
	_search_text = _tmp3_;
	_tmp4_ = _search_text;
	_tmp5_ = _search_text;
	_tmp6_ = _search_text;
	_tmp7_ = g_strdup_printf ("\n" \
"            SELECT  tracks.id, tracks.path, tracks.title, tracks.durat" \
"ion, tracks.is_favorite, tracks.date_added, \n" \
"            tracks.play_count, tracks.album_id, albums.title, artists." \
"name, tracks.favorite_added, tracks.last_played FROM tracks \n" \
"            INNER JOIN albums ON tracks.album_id = albums.id\n" \
"            INNER JOIN artists ON albums.artist_id = artists.id\n" \
"            WHERE (tracks.title LIKE '%s' OR \n" \
"            artists.name LIKE '%s' OR \n" \
"            albums.title LIKE '%s') \n" \
"            AND tracks.is_favorite = 1;\n" \
"        ", _tmp4_, _tmp5_, _tmp6_);
	_g_free0 (sql);
	sql = _tmp7_;
	_tmp8_ = self->priv->db;
	_tmp9_ = sql;
	_tmp11_ = sqlite3_prepare_v2 (_tmp8_, _tmp9_, -1, &_tmp10_, NULL);
	_sqlite3_finalize0 (stmt);
	stmt = _tmp10_;
	res = _tmp11_;
	_tmp12_ = res;
	_vala_assert (_tmp12_ == SQLITE_OK, "res == Sqlite.OK");
	_tmp13_ = gee_array_list_new (OBJECTS_TYPE_TRACK, (GBoxedCopyFunc) g_object_ref, (GDestroyNotify) g_object_unref, NULL, NULL, NULL);
	all = _tmp13_;
	index = 0;
	while (TRUE) {
		sqlite3_stmt* _tmp14_;
		gint _tmp15_;
		ObjectsTrack* track = NULL;
		GDateTime* _tmp16_;
		GDateTime* _tmp17_;
		gchar* _tmp18_;
		gchar* _tmp19_;
		ObjectsTrack* _tmp20_;
		ObjectsTrack* _tmp21_;
		ObjectsTrack* _tmp22_;
		gint _tmp23_;
		ObjectsTrack* _tmp24_;
		sqlite3_stmt* _tmp25_;
		ObjectsTrack* _tmp26_;
		sqlite3_stmt* _tmp27_;
		const gchar* _tmp28_;
		gchar* _tmp29_;
		ObjectsTrack* _tmp30_;
		sqlite3_stmt* _tmp31_;
		const gchar* _tmp32_;
		gchar* _tmp33_;
		ObjectsTrack* _tmp34_;
		sqlite3_stmt* _tmp35_;
		ObjectsTrack* _tmp36_;
		sqlite3_stmt* _tmp37_;
		ObjectsTrack* _tmp38_;
		sqlite3_stmt* _tmp39_;
		const gchar* _tmp40_;
		gchar* _tmp41_;
		ObjectsTrack* _tmp42_;
		sqlite3_stmt* _tmp43_;
		ObjectsTrack* _tmp44_;
		sqlite3_stmt* _tmp45_;
		ObjectsTrack* _tmp46_;
		sqlite3_stmt* _tmp47_;
		const gchar* _tmp48_;
		gchar* _tmp49_;
		ObjectsTrack* _tmp50_;
		sqlite3_stmt* _tmp51_;
		const gchar* _tmp52_;
		gchar* _tmp53_;
		ObjectsTrack* _tmp54_;
		sqlite3_stmt* _tmp55_;
		const gchar* _tmp56_;
		gchar* _tmp57_;
		ObjectsTrack* _tmp58_;
		sqlite3_stmt* _tmp59_;
		const gchar* _tmp60_;
		gchar* _tmp61_;
		GeeArrayList* _tmp62_;
		ObjectsTrack* _tmp63_;
		gint _tmp64_;
		_tmp14_ = stmt;
		res = sqlite3_step (_tmp14_);
		_tmp15_ = res;
		if (!(_tmp15_ == SQLITE_ROW)) {
			break;
		}
		_tmp16_ = g_date_time_new_now_local ();
		_tmp17_ = _tmp16_;
		_tmp18_ = g_date_time_to_string (_tmp17_);
		_tmp19_ = _tmp18_;
		_tmp20_ = objects_track_new (0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (guint64) 0, "", "", "", "", "", "", "", "", "", "", "", "", _tmp19_);
		_tmp21_ = _tmp20_;
		_g_free0 (_tmp19_);
		_g_date_time_unref0 (_tmp17_);
		track = _tmp21_;
		_tmp22_ = track;
		_tmp23_ = index;
		_tmp22_->track_order = _tmp23_;
		_tmp24_ = track;
		_tmp25_ = stmt;
		_tmp24_->id = sqlite3_column_int (_tmp25_, 0);
		_tmp26_ = track;
		_tmp27_ = stmt;
		_tmp28_ = sqlite3_column_text (_tmp27_, 1);
		_tmp29_ = g_strdup (_tmp28_);
		_g_free0 (_tmp26_->path);
		_tmp26_->path = _tmp29_;
		_tmp30_ = track;
		_tmp31_ = stmt;
		_tmp32_ = sqlite3_column_text (_tmp31_, 2);
		_tmp33_ = g_strdup (_tmp32_);
		_g_free0 (_tmp30_->title);
		_tmp30_->title = _tmp33_;
		_tmp34_ = track;
		_tmp35_ = stmt;
		_tmp34_->duration = (guint64) sqlite3_column_int64 (_tmp35_, 3);
		_tmp36_ = track;
		_tmp37_ = stmt;
		_tmp36_->is_favorite = sqlite3_column_int (_tmp37_, 4);
		_tmp38_ = track;
		_tmp39_ = stmt;
		_tmp40_ = sqlite3_column_text (_tmp39_, 5);
		_tmp41_ = g_strdup (_tmp40_);
		_g_free0 (_tmp38_->date_added);
		_tmp38_->date_added = _tmp41_;
		_tmp42_ = track;
		_tmp43_ = stmt;
		_tmp42_->play_count = sqlite3_column_int (_tmp43_, 6);
		_tmp44_ = track;
		_tmp45_ = stmt;
		_tmp44_->album_id = sqlite3_column_int (_tmp45_, 7);
		_tmp46_ = track;
		_tmp47_ = stmt;
		_tmp48_ = sqlite3_column_text (_tmp47_, 8);
		_tmp49_ = g_strdup (_tmp48_);
		_g_free0 (_tmp46_->album_title);
		_tmp46_->album_title = _tmp49_;
		_tmp50_ = track;
		_tmp51_ = stmt;
		_tmp52_ = sqlite3_column_text (_tmp51_, 9);
		_tmp53_ = g_strdup (_tmp52_);
		_g_free0 (_tmp50_->artist_name);
		_tmp50_->artist_name = _tmp53_;
		_tmp54_ = track;
		_tmp55_ = stmt;
		_tmp56_ = sqlite3_column_text (_tmp55_, 10);
		_tmp57_ = g_strdup (_tmp56_);
		_g_free0 (_tmp54_->favorite_added);
		_tmp54_->favorite_added = _tmp57_;
		_tmp58_ = track;
		_tmp59_ = stmt;
		_tmp60_ = sqlite3_column_text (_tmp59_, 11);
		_tmp61_ = g_strdup (_tmp60_);
		_g_free0 (_tmp58_->last_played);
		_tmp58_->last_played = _tmp61_;
		_tmp62_ = all;
		_tmp63_ = track;
		gee_abstract_collection_add ((GeeAbstractCollection*) _tmp62_, _tmp63_);
		_tmp64_ = index;
		index = _tmp64_ + 1;
		_g_object_unref0 (track);
	}
	result = all;
	_g_free0 (_search_text);
	_g_free0 (sql);
	_sqlite3_finalize0 (stmt);
	return result;
}


GeeArrayList*
services_database_get_all_tracks_search (ServicesDatabase* self,
                                         const gchar* search_text)
{
	GeeArrayList* result = NULL;
	sqlite3_stmt* stmt = NULL;
	gchar* sql = NULL;
	gint res = 0;
	gchar* _search_text = NULL;
	gchar* _tmp0_;
	gchar* _tmp1_;
	gchar* _tmp2_;
	gchar* _tmp3_;
	const gchar* _tmp4_;
	const gchar* _tmp5_;
	const gchar* _tmp6_;
	gchar* _tmp7_;
	sqlite3* _tmp8_;
	const gchar* _tmp9_;
	sqlite3_stmt* _tmp10_ = NULL;
	gint _tmp11_;
	gint _tmp12_;
	GeeArrayList* all = NULL;
	GeeArrayList* _tmp13_;
	gint index = 0;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (search_text != NULL, NULL);
	_tmp0_ = g_strconcat ("%", search_text, NULL);
	_tmp1_ = _tmp0_;
	_tmp2_ = g_strconcat (_tmp1_, "%", NULL);
	_tmp3_ = _tmp2_;
	_g_free0 (_tmp1_);
	_search_text = _tmp3_;
	_tmp4_ = _search_text;
	_tmp5_ = _search_text;
	_tmp6_ = _search_text;
	_tmp7_ = g_strdup_printf ("\n" \
"            SELECT  tracks.id, tracks.path, tracks.title, tracks.durat" \
"ion, tracks.is_favorite, tracks.date_added, tracks.play_count, \n" \
"            tracks.album_id, albums.title, artists.name, tracks.favori" \
"te_added, tracks.last_played FROM tracks \n" \
"            INNER JOIN albums ON tracks.album_id = albums.id\n" \
"            INNER JOIN artists ON albums.artist_id = artists.id\n" \
"            WHERE tracks.title LIKE '%s' OR \n" \
"            artists.name LIKE '%s' OR \n" \
"            albums.title LIKE '%s';\n" \
"        ", _tmp4_, _tmp5_, _tmp6_);
	_g_free0 (sql);
	sql = _tmp7_;
	_tmp8_ = self->priv->db;
	_tmp9_ = sql;
	_tmp11_ = sqlite3_prepare_v2 (_tmp8_, _tmp9_, -1, &_tmp10_, NULL);
	_sqlite3_finalize0 (stmt);
	stmt = _tmp10_;
	res = _tmp11_;
	_tmp12_ = res;
	_vala_assert (_tmp12_ == SQLITE_OK, "res == Sqlite.OK");
	_tmp13_ = gee_array_list_new (OBJECTS_TYPE_TRACK, (GBoxedCopyFunc) g_object_ref, (GDestroyNotify) g_object_unref, NULL, NULL, NULL);
	all = _tmp13_;
	index = 0;
	while (TRUE) {
		sqlite3_stmt* _tmp14_;
		gint _tmp15_;
		ObjectsTrack* track = NULL;
		GDateTime* _tmp16_;
		GDateTime* _tmp17_;
		gchar* _tmp18_;
		gchar* _tmp19_;
		ObjectsTrack* _tmp20_;
		ObjectsTrack* _tmp21_;
		ObjectsTrack* _tmp22_;
		gint _tmp23_;
		ObjectsTrack* _tmp24_;
		sqlite3_stmt* _tmp25_;
		ObjectsTrack* _tmp26_;
		sqlite3_stmt* _tmp27_;
		const gchar* _tmp28_;
		gchar* _tmp29_;
		ObjectsTrack* _tmp30_;
		sqlite3_stmt* _tmp31_;
		const gchar* _tmp32_;
		gchar* _tmp33_;
		ObjectsTrack* _tmp34_;
		sqlite3_stmt* _tmp35_;
		ObjectsTrack* _tmp36_;
		sqlite3_stmt* _tmp37_;
		ObjectsTrack* _tmp38_;
		sqlite3_stmt* _tmp39_;
		const gchar* _tmp40_;
		gchar* _tmp41_;
		ObjectsTrack* _tmp42_;
		sqlite3_stmt* _tmp43_;
		ObjectsTrack* _tmp44_;
		sqlite3_stmt* _tmp45_;
		ObjectsTrack* _tmp46_;
		sqlite3_stmt* _tmp47_;
		const gchar* _tmp48_;
		gchar* _tmp49_;
		ObjectsTrack* _tmp50_;
		sqlite3_stmt* _tmp51_;
		const gchar* _tmp52_;
		gchar* _tmp53_;
		ObjectsTrack* _tmp54_;
		sqlite3_stmt* _tmp55_;
		const gchar* _tmp56_;
		gchar* _tmp57_;
		ObjectsTrack* _tmp58_;
		sqlite3_stmt* _tmp59_;
		const gchar* _tmp60_;
		gchar* _tmp61_;
		GeeArrayList* _tmp62_;
		ObjectsTrack* _tmp63_;
		gint _tmp64_;
		_tmp14_ = stmt;
		res = sqlite3_step (_tmp14_);
		_tmp15_ = res;
		if (!(_tmp15_ == SQLITE_ROW)) {
			break;
		}
		_tmp16_ = g_date_time_new_now_local ();
		_tmp17_ = _tmp16_;
		_tmp18_ = g_date_time_to_string (_tmp17_);
		_tmp19_ = _tmp18_;
		_tmp20_ = objects_track_new (0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (guint64) 0, "", "", "", "", "", "", "", "", "", "", "", "", _tmp19_);
		_tmp21_ = _tmp20_;
		_g_free0 (_tmp19_);
		_g_date_time_unref0 (_tmp17_);
		track = _tmp21_;
		_tmp22_ = track;
		_tmp23_ = index;
		_tmp22_->track_order = _tmp23_;
		_tmp24_ = track;
		_tmp25_ = stmt;
		_tmp24_->id = sqlite3_column_int (_tmp25_, 0);
		_tmp26_ = track;
		_tmp27_ = stmt;
		_tmp28_ = sqlite3_column_text (_tmp27_, 1);
		_tmp29_ = g_strdup (_tmp28_);
		_g_free0 (_tmp26_->path);
		_tmp26_->path = _tmp29_;
		_tmp30_ = track;
		_tmp31_ = stmt;
		_tmp32_ = sqlite3_column_text (_tmp31_, 2);
		_tmp33_ = g_strdup (_tmp32_);
		_g_free0 (_tmp30_->title);
		_tmp30_->title = _tmp33_;
		_tmp34_ = track;
		_tmp35_ = stmt;
		_tmp34_->duration = (guint64) sqlite3_column_int64 (_tmp35_, 3);
		_tmp36_ = track;
		_tmp37_ = stmt;
		_tmp36_->is_favorite = sqlite3_column_int (_tmp37_, 4);
		_tmp38_ = track;
		_tmp39_ = stmt;
		_tmp40_ = sqlite3_column_text (_tmp39_, 5);
		_tmp41_ = g_strdup (_tmp40_);
		_g_free0 (_tmp38_->date_added);
		_tmp38_->date_added = _tmp41_;
		_tmp42_ = track;
		_tmp43_ = stmt;
		_tmp42_->play_count = sqlite3_column_int (_tmp43_, 6);
		_tmp44_ = track;
		_tmp45_ = stmt;
		_tmp44_->album_id = sqlite3_column_int (_tmp45_, 7);
		_tmp46_ = track;
		_tmp47_ = stmt;
		_tmp48_ = sqlite3_column_text (_tmp47_, 8);
		_tmp49_ = g_strdup (_tmp48_);
		_g_free0 (_tmp46_->album_title);
		_tmp46_->album_title = _tmp49_;
		_tmp50_ = track;
		_tmp51_ = stmt;
		_tmp52_ = sqlite3_column_text (_tmp51_, 9);
		_tmp53_ = g_strdup (_tmp52_);
		_g_free0 (_tmp50_->artist_name);
		_tmp50_->artist_name = _tmp53_;
		_tmp54_ = track;
		_tmp55_ = stmt;
		_tmp56_ = sqlite3_column_text (_tmp55_, 10);
		_tmp57_ = g_strdup (_tmp56_);
		_g_free0 (_tmp54_->favorite_added);
		_tmp54_->favorite_added = _tmp57_;
		_tmp58_ = track;
		_tmp59_ = stmt;
		_tmp60_ = sqlite3_column_text (_tmp59_, 11);
		_tmp61_ = g_strdup (_tmp60_);
		_g_free0 (_tmp58_->last_played);
		_tmp58_->last_played = _tmp61_;
		_tmp62_ = all;
		_tmp63_ = track;
		gee_abstract_collection_add ((GeeAbstractCollection*) _tmp62_, _tmp63_);
		_tmp64_ = index;
		index = _tmp64_ + 1;
		_g_object_unref0 (track);
	}
	result = all;
	_g_free0 (_search_text);
	_g_free0 (sql);
	_sqlite3_finalize0 (stmt);
	return result;
}


GeeArrayList*
services_database_get_all_tracks_by_album (ServicesDatabase* self,
                                           gint id)
{
	GeeArrayList* result = NULL;
	sqlite3_stmt* stmt = NULL;
	gchar* sql = NULL;
	gint res = 0;
	gchar* _tmp0_;
	sqlite3* _tmp1_;
	const gchar* _tmp2_;
	sqlite3_stmt* _tmp3_ = NULL;
	gint _tmp4_;
	gint _tmp5_;
	GeeArrayList* all = NULL;
	GeeArrayList* _tmp6_;
	gint index = 0;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = g_strdup_printf ("\n" \
"            SELECT tracks.id, tracks.path, tracks.title, tracks.durati" \
"on, tracks.is_favorite, tracks.track, tracks.date_added, tracks.play_c" \
"ount, \n" \
"            tracks.album_id, albums.title, artists.name, tracks.favori" \
"te_added, tracks.last_played FROM tracks\n" \
"            INNER JOIN albums ON tracks.album_id = albums.id\n" \
"            INNER JOIN artists ON albums.artist_id = artists.id WHERE " \
"tracks.album_id = %i ORDER BY tracks.track;\n" \
"        ", id);
	_g_free0 (sql);
	sql = _tmp0_;
	_tmp1_ = self->priv->db;
	_tmp2_ = sql;
	_tmp4_ = sqlite3_prepare_v2 (_tmp1_, _tmp2_, -1, &_tmp3_, NULL);
	_sqlite3_finalize0 (stmt);
	stmt = _tmp3_;
	res = _tmp4_;
	_tmp5_ = res;
	_vala_assert (_tmp5_ == SQLITE_OK, "res == Sqlite.OK");
	_tmp6_ = gee_array_list_new (OBJECTS_TYPE_TRACK, (GBoxedCopyFunc) g_object_ref, (GDestroyNotify) g_object_unref, NULL, NULL, NULL);
	all = _tmp6_;
	index = 0;
	while (TRUE) {
		sqlite3_stmt* _tmp7_;
		gint _tmp8_;
		ObjectsTrack* track = NULL;
		GDateTime* _tmp9_;
		GDateTime* _tmp10_;
		gchar* _tmp11_;
		gchar* _tmp12_;
		ObjectsTrack* _tmp13_;
		ObjectsTrack* _tmp14_;
		ObjectsTrack* _tmp15_;
		gint _tmp16_;
		ObjectsTrack* _tmp17_;
		sqlite3_stmt* _tmp18_;
		ObjectsTrack* _tmp19_;
		sqlite3_stmt* _tmp20_;
		const gchar* _tmp21_;
		gchar* _tmp22_;
		ObjectsTrack* _tmp23_;
		sqlite3_stmt* _tmp24_;
		const gchar* _tmp25_;
		gchar* _tmp26_;
		ObjectsTrack* _tmp27_;
		sqlite3_stmt* _tmp28_;
		ObjectsTrack* _tmp29_;
		sqlite3_stmt* _tmp30_;
		ObjectsTrack* _tmp31_;
		sqlite3_stmt* _tmp32_;
		ObjectsTrack* _tmp33_;
		sqlite3_stmt* _tmp34_;
		const gchar* _tmp35_;
		gchar* _tmp36_;
		ObjectsTrack* _tmp37_;
		sqlite3_stmt* _tmp38_;
		ObjectsTrack* _tmp39_;
		sqlite3_stmt* _tmp40_;
		ObjectsTrack* _tmp41_;
		sqlite3_stmt* _tmp42_;
		const gchar* _tmp43_;
		gchar* _tmp44_;
		ObjectsTrack* _tmp45_;
		sqlite3_stmt* _tmp46_;
		const gchar* _tmp47_;
		gchar* _tmp48_;
		ObjectsTrack* _tmp49_;
		sqlite3_stmt* _tmp50_;
		const gchar* _tmp51_;
		gchar* _tmp52_;
		ObjectsTrack* _tmp53_;
		sqlite3_stmt* _tmp54_;
		const gchar* _tmp55_;
		gchar* _tmp56_;
		GeeArrayList* _tmp57_;
		ObjectsTrack* _tmp58_;
		gint _tmp59_;
		_tmp7_ = stmt;
		res = sqlite3_step (_tmp7_);
		_tmp8_ = res;
		if (!(_tmp8_ == SQLITE_ROW)) {
			break;
		}
		_tmp9_ = g_date_time_new_now_local ();
		_tmp10_ = _tmp9_;
		_tmp11_ = g_date_time_to_string (_tmp10_);
		_tmp12_ = _tmp11_;
		_tmp13_ = objects_track_new (0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (guint64) 0, "", "", "", "", "", "", "", "", "", "", "", "", _tmp12_);
		_tmp14_ = _tmp13_;
		_g_free0 (_tmp12_);
		_g_date_time_unref0 (_tmp10_);
		track = _tmp14_;
		_tmp15_ = track;
		_tmp16_ = index;
		_tmp15_->track_order = _tmp16_;
		_tmp17_ = track;
		_tmp18_ = stmt;
		_tmp17_->id = sqlite3_column_int (_tmp18_, 0);
		_tmp19_ = track;
		_tmp20_ = stmt;
		_tmp21_ = sqlite3_column_text (_tmp20_, 1);
		_tmp22_ = g_strdup (_tmp21_);
		_g_free0 (_tmp19_->path);
		_tmp19_->path = _tmp22_;
		_tmp23_ = track;
		_tmp24_ = stmt;
		_tmp25_ = sqlite3_column_text (_tmp24_, 2);
		_tmp26_ = g_strdup (_tmp25_);
		_g_free0 (_tmp23_->title);
		_tmp23_->title = _tmp26_;
		_tmp27_ = track;
		_tmp28_ = stmt;
		_tmp27_->duration = (guint64) sqlite3_column_int64 (_tmp28_, 3);
		_tmp29_ = track;
		_tmp30_ = stmt;
		_tmp29_->is_favorite = sqlite3_column_int (_tmp30_, 4);
		_tmp31_ = track;
		_tmp32_ = stmt;
		_tmp31_->track = sqlite3_column_int (_tmp32_, 5);
		_tmp33_ = track;
		_tmp34_ = stmt;
		_tmp35_ = sqlite3_column_text (_tmp34_, 6);
		_tmp36_ = g_strdup (_tmp35_);
		_g_free0 (_tmp33_->date_added);
		_tmp33_->date_added = _tmp36_;
		_tmp37_ = track;
		_tmp38_ = stmt;
		_tmp37_->play_count = sqlite3_column_int (_tmp38_, 7);
		_tmp39_ = track;
		_tmp40_ = stmt;
		_tmp39_->album_id = sqlite3_column_int (_tmp40_, 8);
		_tmp41_ = track;
		_tmp42_ = stmt;
		_tmp43_ = sqlite3_column_text (_tmp42_, 9);
		_tmp44_ = g_strdup (_tmp43_);
		_g_free0 (_tmp41_->album_title);
		_tmp41_->album_title = _tmp44_;
		_tmp45_ = track;
		_tmp46_ = stmt;
		_tmp47_ = sqlite3_column_text (_tmp46_, 10);
		_tmp48_ = g_strdup (_tmp47_);
		_g_free0 (_tmp45_->artist_name);
		_tmp45_->artist_name = _tmp48_;
		_tmp49_ = track;
		_tmp50_ = stmt;
		_tmp51_ = sqlite3_column_text (_tmp50_, 11);
		_tmp52_ = g_strdup (_tmp51_);
		_g_free0 (_tmp49_->favorite_added);
		_tmp49_->favorite_added = _tmp52_;
		_tmp53_ = track;
		_tmp54_ = stmt;
		_tmp55_ = sqlite3_column_text (_tmp54_, 12);
		_tmp56_ = g_strdup (_tmp55_);
		_g_free0 (_tmp53_->last_played);
		_tmp53_->last_played = _tmp56_;
		_tmp57_ = all;
		_tmp58_ = track;
		gee_abstract_collection_add ((GeeAbstractCollection*) _tmp57_, _tmp58_);
		_tmp59_ = index;
		index = _tmp59_ + 1;
		_g_object_unref0 (track);
	}
	result = all;
	_g_free0 (sql);
	_sqlite3_finalize0 (stmt);
	return result;
}


GeeArrayList*
services_database_get_all_tracks_by_playlist (ServicesDatabase* self,
                                              gint id,
                                              gint sort,
                                              gboolean is_reverse)
{
	GeeArrayList* result = NULL;
	sqlite3_stmt* stmt = NULL;
	gchar* sql = NULL;
	gint res = 0;
	gchar* order_mode = NULL;
	gchar* _tmp0_;
	gchar* reverse_mode = NULL;
	gchar* _tmp1_;
	const gchar* _tmp8_;
	const gchar* _tmp9_;
	gchar* _tmp10_;
	sqlite3* _tmp11_;
	const gchar* _tmp12_;
	sqlite3_stmt* _tmp13_ = NULL;
	gint _tmp14_;
	gint _tmp15_;
	sqlite3_stmt* _tmp16_;
	gint _tmp17_;
	GeeArrayList* all = NULL;
	GeeArrayList* _tmp18_;
	gint index = 0;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = g_strdup ("tracks.title");
	order_mode = _tmp0_;
	_tmp1_ = g_strdup ("DESC");
	reverse_mode = _tmp1_;
	if (sort == 0) {
		gchar* _tmp2_;
		_tmp2_ = g_strdup ("tracks.title");
		_g_free0 (order_mode);
		order_mode = _tmp2_;
	} else {
		if (sort == 1) {
			gchar* _tmp3_;
			_tmp3_ = g_strdup ("artists.name");
			_g_free0 (order_mode);
			order_mode = _tmp3_;
		} else {
			if (sort == 2) {
				gchar* _tmp4_;
				_tmp4_ = g_strdup ("albums.title");
				_g_free0 (order_mode);
				order_mode = _tmp4_;
			} else {
				if (sort == 3) {
					gchar* _tmp5_;
					_tmp5_ = g_strdup ("playlist_tracks.date_added");
					_g_free0 (order_mode);
					order_mode = _tmp5_;
				} else {
					gchar* _tmp6_;
					_tmp6_ = g_strdup ("tracks.play_count");
					_g_free0 (order_mode);
					order_mode = _tmp6_;
				}
			}
		}
	}
	if (is_reverse == FALSE) {
		gchar* _tmp7_;
		_tmp7_ = g_strdup ("ASC");
		_g_free0 (reverse_mode);
		reverse_mode = _tmp7_;
	}
	_tmp8_ = order_mode;
	_tmp9_ = reverse_mode;
	_tmp10_ = g_strdup_printf ("\n" \
"            SELECT tracks.id, tracks.path, tracks.title, tracks.durati" \
"on, tracks.is_favorite, tracks.track, tracks.date_added, tracks.play_c" \
"ount, tracks.album_id, albums.title, artists.name, tracks.favorite_add" \
"ed, tracks.last_played, playlist_tracks.date_added FROM playlist_track" \
"s \n" \
"            LEFT JOIN tracks ON playlist_tracks.track_id = tracks.id\n" \
"            LEFT JOIN albums ON tracks.album_id = albums.id\n" \
"            LEFT JOIN artists ON albums.artist_id = artists.id WHERE p" \
"laylist_tracks.playlist_id = ? ORDER BY %s %s;\n" \
"        ", _tmp8_, _tmp9_);
	_g_free0 (sql);
	sql = _tmp10_;
	_tmp11_ = self->priv->db;
	_tmp12_ = sql;
	_tmp14_ = sqlite3_prepare_v2 (_tmp11_, _tmp12_, -1, &_tmp13_, NULL);
	_sqlite3_finalize0 (stmt);
	stmt = _tmp13_;
	res = _tmp14_;
	_tmp15_ = res;
	_vala_assert (_tmp15_ == SQLITE_OK, "res == Sqlite.OK");
	_tmp16_ = stmt;
	res = sqlite3_bind_int (_tmp16_, 1, id);
	_tmp17_ = res;
	_vala_assert (_tmp17_ == SQLITE_OK, "res == Sqlite.OK");
	_tmp18_ = gee_array_list_new (OBJECTS_TYPE_TRACK, (GBoxedCopyFunc) g_object_ref, (GDestroyNotify) g_object_unref, NULL, NULL, NULL);
	all = _tmp18_;
	index = 0;
	while (TRUE) {
		sqlite3_stmt* _tmp19_;
		gint _tmp20_;
		ObjectsTrack* track = NULL;
		GDateTime* _tmp21_;
		GDateTime* _tmp22_;
		gchar* _tmp23_;
		gchar* _tmp24_;
		ObjectsTrack* _tmp25_;
		ObjectsTrack* _tmp26_;
		ObjectsTrack* _tmp27_;
		gint _tmp28_;
		ObjectsTrack* _tmp29_;
		sqlite3_stmt* _tmp30_;
		ObjectsTrack* _tmp31_;
		sqlite3_stmt* _tmp32_;
		const gchar* _tmp33_;
		gchar* _tmp34_;
		ObjectsTrack* _tmp35_;
		sqlite3_stmt* _tmp36_;
		const gchar* _tmp37_;
		gchar* _tmp38_;
		ObjectsTrack* _tmp39_;
		sqlite3_stmt* _tmp40_;
		ObjectsTrack* _tmp41_;
		sqlite3_stmt* _tmp42_;
		ObjectsTrack* _tmp43_;
		sqlite3_stmt* _tmp44_;
		ObjectsTrack* _tmp45_;
		sqlite3_stmt* _tmp46_;
		const gchar* _tmp47_;
		gchar* _tmp48_;
		ObjectsTrack* _tmp49_;
		sqlite3_stmt* _tmp50_;
		ObjectsTrack* _tmp51_;
		sqlite3_stmt* _tmp52_;
		ObjectsTrack* _tmp53_;
		sqlite3_stmt* _tmp54_;
		const gchar* _tmp55_;
		gchar* _tmp56_;
		ObjectsTrack* _tmp57_;
		sqlite3_stmt* _tmp58_;
		const gchar* _tmp59_;
		gchar* _tmp60_;
		ObjectsTrack* _tmp61_;
		sqlite3_stmt* _tmp62_;
		const gchar* _tmp63_;
		gchar* _tmp64_;
		ObjectsTrack* _tmp65_;
		sqlite3_stmt* _tmp66_;
		const gchar* _tmp67_;
		gchar* _tmp68_;
		ObjectsTrack* _tmp69_;
		GeeArrayList* _tmp70_;
		ObjectsTrack* _tmp71_;
		gint _tmp72_;
		_tmp19_ = stmt;
		res = sqlite3_step (_tmp19_);
		_tmp20_ = res;
		if (!(_tmp20_ == SQLITE_ROW)) {
			break;
		}
		_tmp21_ = g_date_time_new_now_local ();
		_tmp22_ = _tmp21_;
		_tmp23_ = g_date_time_to_string (_tmp22_);
		_tmp24_ = _tmp23_;
		_tmp25_ = objects_track_new (0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (guint64) 0, "", "", "", "", "", "", "", "", "", "", "", "", _tmp24_);
		_tmp26_ = _tmp25_;
		_g_free0 (_tmp24_);
		_g_date_time_unref0 (_tmp22_);
		track = _tmp26_;
		_tmp27_ = track;
		_tmp28_ = index;
		_tmp27_->track_order = _tmp28_;
		_tmp29_ = track;
		_tmp30_ = stmt;
		_tmp29_->id = sqlite3_column_int (_tmp30_, 0);
		_tmp31_ = track;
		_tmp32_ = stmt;
		_tmp33_ = sqlite3_column_text (_tmp32_, 1);
		_tmp34_ = g_strdup (_tmp33_);
		_g_free0 (_tmp31_->path);
		_tmp31_->path = _tmp34_;
		_tmp35_ = track;
		_tmp36_ = stmt;
		_tmp37_ = sqlite3_column_text (_tmp36_, 2);
		_tmp38_ = g_strdup (_tmp37_);
		_g_free0 (_tmp35_->title);
		_tmp35_->title = _tmp38_;
		_tmp39_ = track;
		_tmp40_ = stmt;
		_tmp39_->duration = (guint64) sqlite3_column_int64 (_tmp40_, 3);
		_tmp41_ = track;
		_tmp42_ = stmt;
		_tmp41_->is_favorite = sqlite3_column_int (_tmp42_, 4);
		_tmp43_ = track;
		_tmp44_ = stmt;
		_tmp43_->track = sqlite3_column_int (_tmp44_, 5);
		_tmp45_ = track;
		_tmp46_ = stmt;
		_tmp47_ = sqlite3_column_text (_tmp46_, 6);
		_tmp48_ = g_strdup (_tmp47_);
		_g_free0 (_tmp45_->date_added);
		_tmp45_->date_added = _tmp48_;
		_tmp49_ = track;
		_tmp50_ = stmt;
		_tmp49_->play_count = sqlite3_column_int (_tmp50_, 7);
		_tmp51_ = track;
		_tmp52_ = stmt;
		_tmp51_->album_id = sqlite3_column_int (_tmp52_, 8);
		_tmp53_ = track;
		_tmp54_ = stmt;
		_tmp55_ = sqlite3_column_text (_tmp54_, 9);
		_tmp56_ = g_strdup (_tmp55_);
		_g_free0 (_tmp53_->album_title);
		_tmp53_->album_title = _tmp56_;
		_tmp57_ = track;
		_tmp58_ = stmt;
		_tmp59_ = sqlite3_column_text (_tmp58_, 10);
		_tmp60_ = g_strdup (_tmp59_);
		_g_free0 (_tmp57_->artist_name);
		_tmp57_->artist_name = _tmp60_;
		_tmp61_ = track;
		_tmp62_ = stmt;
		_tmp63_ = sqlite3_column_text (_tmp62_, 11);
		_tmp64_ = g_strdup (_tmp63_);
		_g_free0 (_tmp61_->favorite_added);
		_tmp61_->favorite_added = _tmp64_;
		_tmp65_ = track;
		_tmp66_ = stmt;
		_tmp67_ = sqlite3_column_text (_tmp66_, 12);
		_tmp68_ = g_strdup (_tmp67_);
		_g_free0 (_tmp65_->last_played);
		_tmp65_->last_played = _tmp68_;
		_tmp69_ = track;
		_tmp69_->playlist = id;
		_tmp70_ = all;
		_tmp71_ = track;
		gee_abstract_collection_add ((GeeAbstractCollection*) _tmp70_, _tmp71_);
		_tmp72_ = index;
		index = _tmp72_ + 1;
		_g_object_unref0 (track);
	}
	result = all;
	_g_free0 (reverse_mode);
	_g_free0 (order_mode);
	_g_free0 (sql);
	_sqlite3_finalize0 (stmt);
	return result;
}


GeeArrayList*
services_database_get_all_artists (ServicesDatabase* self)
{
	GeeArrayList* result = NULL;
	sqlite3_stmt* stmt = NULL;
	gchar* sql = NULL;
	gint res = 0;
	gchar* _tmp0_;
	sqlite3* _tmp1_;
	const gchar* _tmp2_;
	sqlite3_stmt* _tmp3_ = NULL;
	gint _tmp4_;
	gint _tmp5_;
	GeeArrayList* all = NULL;
	GeeArrayList* _tmp6_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = g_strdup ("\n" \
"            SELECT artists.id, artists.name FROM artists ORDER BY arti" \
"sts.name;\n" \
"        ");
	_g_free0 (sql);
	sql = _tmp0_;
	_tmp1_ = self->priv->db;
	_tmp2_ = sql;
	_tmp4_ = sqlite3_prepare_v2 (_tmp1_, _tmp2_, -1, &_tmp3_, NULL);
	_sqlite3_finalize0 (stmt);
	stmt = _tmp3_;
	res = _tmp4_;
	_tmp5_ = res;
	_vala_assert (_tmp5_ == SQLITE_OK, "res == Sqlite.OK");
	_tmp6_ = gee_array_list_new (OBJECTS_TYPE_ARTIST, (GBoxedCopyFunc) g_object_ref, (GDestroyNotify) g_object_unref, NULL, NULL, NULL);
	all = _tmp6_;
	while (TRUE) {
		sqlite3_stmt* _tmp7_;
		gint _tmp8_;
		ObjectsArtist* artist = NULL;
		ObjectsArtist* _tmp9_;
		ObjectsArtist* _tmp10_;
		sqlite3_stmt* _tmp11_;
		ObjectsArtist* _tmp12_;
		sqlite3_stmt* _tmp13_;
		const gchar* _tmp14_;
		gchar* _tmp15_;
		GeeArrayList* _tmp16_;
		ObjectsArtist* _tmp17_;
		_tmp7_ = stmt;
		res = sqlite3_step (_tmp7_);
		_tmp8_ = res;
		if (!(_tmp8_ == SQLITE_ROW)) {
			break;
		}
		_tmp9_ = objects_artist_new (0, "");
		artist = _tmp9_;
		_tmp10_ = artist;
		_tmp11_ = stmt;
		_tmp10_->id = sqlite3_column_int (_tmp11_, 0);
		_tmp12_ = artist;
		_tmp13_ = stmt;
		_tmp14_ = sqlite3_column_text (_tmp13_, 1);
		_tmp15_ = g_strdup (_tmp14_);
		_g_free0 (_tmp12_->name);
		_tmp12_->name = _tmp15_;
		_tmp16_ = all;
		_tmp17_ = artist;
		gee_abstract_collection_add ((GeeAbstractCollection*) _tmp16_, _tmp17_);
		_g_object_unref0 (artist);
	}
	result = all;
	_g_free0 (sql);
	_sqlite3_finalize0 (stmt);
	return result;
}


GeeArrayList*
services_database_get_all_artists_search (ServicesDatabase* self,
                                          const gchar* search_text)
{
	GeeArrayList* result = NULL;
	sqlite3_stmt* stmt = NULL;
	gchar* sql = NULL;
	gint res = 0;
	gchar* _tmp0_;
	gchar* _tmp1_;
	gchar* _tmp2_;
	gchar* _tmp3_;
	gchar* _tmp4_;
	sqlite3* _tmp5_;
	const gchar* _tmp6_;
	sqlite3_stmt* _tmp7_ = NULL;
	gint _tmp8_;
	gint _tmp9_;
	GeeArrayList* all = NULL;
	GeeArrayList* _tmp10_;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (search_text != NULL, NULL);
	_tmp0_ = g_strconcat ("%", search_text, NULL);
	_tmp1_ = _tmp0_;
	_tmp2_ = g_strconcat (_tmp1_, "%", NULL);
	_tmp3_ = _tmp2_;
	_tmp4_ = g_strdup_printf ("\n" \
"            SELECT artists.id, artists.name FROM artists WHERE artists" \
".name LIKE '%s';\n" \
"        ", _tmp3_);
	_g_free0 (sql);
	sql = _tmp4_;
	_g_free0 (_tmp3_);
	_g_free0 (_tmp1_);
	_tmp5_ = self->priv->db;
	_tmp6_ = sql;
	_tmp8_ = sqlite3_prepare_v2 (_tmp5_, _tmp6_, -1, &_tmp7_, NULL);
	_sqlite3_finalize0 (stmt);
	stmt = _tmp7_;
	res = _tmp8_;
	_tmp9_ = res;
	_vala_assert (_tmp9_ == SQLITE_OK, "res == Sqlite.OK");
	_tmp10_ = gee_array_list_new (OBJECTS_TYPE_ARTIST, (GBoxedCopyFunc) g_object_ref, (GDestroyNotify) g_object_unref, NULL, NULL, NULL);
	all = _tmp10_;
	while (TRUE) {
		sqlite3_stmt* _tmp11_;
		gint _tmp12_;
		ObjectsArtist* artist = NULL;
		ObjectsArtist* _tmp13_;
		ObjectsArtist* _tmp14_;
		sqlite3_stmt* _tmp15_;
		ObjectsArtist* _tmp16_;
		sqlite3_stmt* _tmp17_;
		const gchar* _tmp18_;
		gchar* _tmp19_;
		GeeArrayList* _tmp20_;
		ObjectsArtist* _tmp21_;
		_tmp11_ = stmt;
		res = sqlite3_step (_tmp11_);
		_tmp12_ = res;
		if (!(_tmp12_ == SQLITE_ROW)) {
			break;
		}
		_tmp13_ = objects_artist_new (0, "");
		artist = _tmp13_;
		_tmp14_ = artist;
		_tmp15_ = stmt;
		_tmp14_->id = sqlite3_column_int (_tmp15_, 0);
		_tmp16_ = artist;
		_tmp17_ = stmt;
		_tmp18_ = sqlite3_column_text (_tmp17_, 1);
		_tmp19_ = g_strdup (_tmp18_);
		_g_free0 (_tmp16_->name);
		_tmp16_->name = _tmp19_;
		_tmp20_ = all;
		_tmp21_ = artist;
		gee_abstract_collection_add ((GeeAbstractCollection*) _tmp20_, _tmp21_);
		_g_object_unref0 (artist);
	}
	result = all;
	_g_free0 (sql);
	_sqlite3_finalize0 (stmt);
	return result;
}


gint
services_database_get_tracks_number (ServicesDatabase* self)
{
	gint result = 0;
	g_return_val_if_fail (self != NULL, 0);
	result = 0;
	return result;
}


void
services_database_insert_radio (ServicesDatabase* self,
                                ObjectsRadio* radio)
{
	sqlite3_stmt* stmt = NULL;
	gchar* sql = NULL;
	gint res = 0;
	gchar* _tmp0_;
	sqlite3* _tmp1_;
	const gchar* _tmp2_;
	sqlite3_stmt* _tmp3_ = NULL;
	gint _tmp4_;
	gint _tmp5_;
	sqlite3_stmt* _tmp6_;
	const gchar* _tmp7_;
	const gchar* _tmp8_;
	gchar* _tmp9_;
	GDestroyNotify _tmp10_;
	gint _tmp11_;
	sqlite3_stmt* _tmp12_;
	const gchar* _tmp13_;
	const gchar* _tmp14_;
	gchar* _tmp15_;
	GDestroyNotify _tmp16_;
	gint _tmp17_;
	sqlite3_stmt* _tmp18_;
	const gchar* _tmp19_;
	const gchar* _tmp20_;
	gchar* _tmp21_;
	GDestroyNotify _tmp22_;
	gint _tmp23_;
	sqlite3_stmt* _tmp24_;
	const gchar* _tmp25_;
	const gchar* _tmp26_;
	gchar* _tmp27_;
	GDestroyNotify _tmp28_;
	gint _tmp29_;
	sqlite3_stmt* _tmp30_;
	const gchar* _tmp31_;
	const gchar* _tmp32_;
	gchar* _tmp33_;
	GDestroyNotify _tmp34_;
	gint _tmp35_;
	sqlite3_stmt* _tmp36_;
	const gchar* _tmp37_;
	const gchar* _tmp38_;
	gchar* _tmp39_;
	GDestroyNotify _tmp40_;
	gint _tmp41_;
	sqlite3_stmt* _tmp42_;
	const gchar* _tmp43_;
	const gchar* _tmp44_;
	gchar* _tmp45_;
	GDestroyNotify _tmp46_;
	gint _tmp47_;
	sqlite3_stmt* _tmp48_;
	sqlite3_stmt* _tmp52_;
	gchar* _tmp53_;
	sqlite3* _tmp54_;
	const gchar* _tmp55_;
	sqlite3_stmt* _tmp56_ = NULL;
	gint _tmp57_;
	gint _tmp58_;
	sqlite3_stmt* _tmp59_;
	const gchar* _tmp60_;
	const gchar* _tmp61_;
	gchar* _tmp62_;
	GDestroyNotify _tmp63_;
	gint _tmp64_;
	sqlite3_stmt* _tmp65_;
	sqlite3_stmt* _tmp75_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (radio != NULL);
	_tmp0_ = g_strdup ("\n" \
"            INSERT OR IGNORE INTO radios (name, url, homepage, tags, f" \
"avicon, country, state)\n" \
"            VALUES (?, ?, ?, ?, ?, ?, ?);\n" \
"        ");
	_g_free0 (sql);
	sql = _tmp0_;
	_tmp1_ = self->priv->db;
	_tmp2_ = sql;
	_tmp4_ = sqlite3_prepare_v2 (_tmp1_, _tmp2_, -1, &_tmp3_, NULL);
	_sqlite3_finalize0 (stmt);
	stmt = _tmp3_;
	res = _tmp4_;
	_tmp5_ = res;
	_vala_assert (_tmp5_ == SQLITE_OK, "res == Sqlite.OK");
	_tmp6_ = stmt;
	_tmp7_ = objects_radio_get_name (radio);
	_tmp8_ = _tmp7_;
	_tmp9_ = g_strdup (_tmp8_);
	_tmp10_ = g_free;
	res = sqlite3_bind_text (_tmp6_, 1, _tmp9_, -1, _tmp10_);
	_tmp11_ = res;
	_vala_assert (_tmp11_ == SQLITE_OK, "res == Sqlite.OK");
	_tmp12_ = stmt;
	_tmp13_ = objects_radio_get_url (radio);
	_tmp14_ = _tmp13_;
	_tmp15_ = g_strdup (_tmp14_);
	_tmp16_ = g_free;
	res = sqlite3_bind_text (_tmp12_, 2, _tmp15_, -1, _tmp16_);
	_tmp17_ = res;
	_vala_assert (_tmp17_ == SQLITE_OK, "res == Sqlite.OK");
	_tmp18_ = stmt;
	_tmp19_ = objects_radio_get_homepage (radio);
	_tmp20_ = _tmp19_;
	_tmp21_ = g_strdup (_tmp20_);
	_tmp22_ = g_free;
	res = sqlite3_bind_text (_tmp18_, 3, _tmp21_, -1, _tmp22_);
	_tmp23_ = res;
	_vala_assert (_tmp23_ == SQLITE_OK, "res == Sqlite.OK");
	_tmp24_ = stmt;
	_tmp25_ = objects_radio_get_tags (radio);
	_tmp26_ = _tmp25_;
	_tmp27_ = g_strdup (_tmp26_);
	_tmp28_ = g_free;
	res = sqlite3_bind_text (_tmp24_, 4, _tmp27_, -1, _tmp28_);
	_tmp29_ = res;
	_vala_assert (_tmp29_ == SQLITE_OK, "res == Sqlite.OK");
	_tmp30_ = stmt;
	_tmp31_ = objects_radio_get_favicon (radio);
	_tmp32_ = _tmp31_;
	_tmp33_ = g_strdup (_tmp32_);
	_tmp34_ = g_free;
	res = sqlite3_bind_text (_tmp30_, 5, _tmp33_, -1, _tmp34_);
	_tmp35_ = res;
	_vala_assert (_tmp35_ == SQLITE_OK, "res == Sqlite.OK");
	_tmp36_ = stmt;
	_tmp37_ = objects_radio_get_country (radio);
	_tmp38_ = _tmp37_;
	_tmp39_ = g_strdup (_tmp38_);
	_tmp40_ = g_free;
	res = sqlite3_bind_text (_tmp36_, 6, _tmp39_, -1, _tmp40_);
	_tmp41_ = res;
	_vala_assert (_tmp41_ == SQLITE_OK, "res == Sqlite.OK");
	_tmp42_ = stmt;
	_tmp43_ = objects_radio_get_state (radio);
	_tmp44_ = _tmp43_;
	_tmp45_ = g_strdup (_tmp44_);
	_tmp46_ = g_free;
	res = sqlite3_bind_text (_tmp42_, 7, _tmp45_, -1, _tmp46_);
	_tmp47_ = res;
	_vala_assert (_tmp47_ == SQLITE_OK, "res == Sqlite.OK");
	_tmp48_ = stmt;
	if (sqlite3_step (_tmp48_) != SQLITE_DONE) {
		sqlite3* _tmp49_;
		sqlite3* _tmp50_;
		const gchar* _tmp51_;
		_tmp49_ = self->priv->db;
		_tmp50_ = self->priv->db;
		_tmp51_ = sqlite3_errmsg (_tmp50_);
		g_warning ("Database.vala:1156: Error: %d: %s", sqlite3_errcode (_tmp49_), _tmp51_);
	}
	_tmp52_ = stmt;
	sqlite3_reset (_tmp52_);
	_tmp53_ = g_strdup ("\n            SELECT id FROM radios WHERE url = ?;\n        ");
	_g_free0 (sql);
	sql = _tmp53_;
	_tmp54_ = self->priv->db;
	_tmp55_ = sql;
	_tmp57_ = sqlite3_prepare_v2 (_tmp54_, _tmp55_, -1, &_tmp56_, NULL);
	_sqlite3_finalize0 (stmt);
	stmt = _tmp56_;
	res = _tmp57_;
	_tmp58_ = res;
	_vala_assert (_tmp58_ == SQLITE_OK, "res == Sqlite.OK");
	_tmp59_ = stmt;
	_tmp60_ = objects_radio_get_url (radio);
	_tmp61_ = _tmp60_;
	_tmp62_ = g_strdup (_tmp61_);
	_tmp63_ = g_free;
	res = sqlite3_bind_text (_tmp59_, 1, _tmp62_, -1, _tmp63_);
	_tmp64_ = res;
	_vala_assert (_tmp64_ == SQLITE_OK, "res == Sqlite.OK");
	_tmp65_ = stmt;
	if (sqlite3_step (_tmp65_) == SQLITE_ROW) {
		sqlite3_stmt* _tmp66_;
		Utils* _tmp67_;
		gint _tmp68_;
		gint _tmp69_;
		const gchar* _tmp70_;
		const gchar* _tmp71_;
		_tmp66_ = stmt;
		objects_radio_set_id (radio, sqlite3_column_int (_tmp66_, 0));
		g_signal_emit (self, services_database_signals[SERVICES_DATABASE_ADDEN_NEW_RADIO_SIGNAL], 0, radio);
		_tmp67_ = byte_utils;
		_tmp68_ = objects_radio_get_id (radio);
		_tmp69_ = _tmp68_;
		_tmp70_ = objects_radio_get_favicon (radio);
		_tmp71_ = _tmp70_;
		utils_download_image (_tmp67_, "radio", _tmp69_, _tmp71_);
	} else {
		sqlite3* _tmp72_;
		sqlite3* _tmp73_;
		const gchar* _tmp74_;
		_tmp72_ = self->priv->db;
		_tmp73_ = self->priv->db;
		_tmp74_ = sqlite3_errmsg (_tmp73_);
		g_warning ("Database.vala:1177: Error: %d: %s", sqlite3_errcode (_tmp72_), _tmp74_);
	}
	_tmp75_ = stmt;
	sqlite3_reset (_tmp75_);
	_g_free0 (sql);
	_sqlite3_finalize0 (stmt);
}


GeeArrayList*
services_database_get_all_radios (ServicesDatabase* self)
{
	GeeArrayList* result = NULL;
	sqlite3_stmt* stmt = NULL;
	gchar* sql = NULL;
	gint res = 0;
	gchar* _tmp0_;
	sqlite3* _tmp1_;
	const gchar* _tmp2_;
	sqlite3_stmt* _tmp3_ = NULL;
	gint _tmp4_;
	gint _tmp5_;
	GeeArrayList* all = NULL;
	GeeArrayList* _tmp6_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = g_strdup ("\n            SELECT * FROM radios;\n        ");
	_g_free0 (sql);
	sql = _tmp0_;
	_tmp1_ = self->priv->db;
	_tmp2_ = sql;
	_tmp4_ = sqlite3_prepare_v2 (_tmp1_, _tmp2_, -1, &_tmp3_, NULL);
	_sqlite3_finalize0 (stmt);
	stmt = _tmp3_;
	res = _tmp4_;
	_tmp5_ = res;
	_vala_assert (_tmp5_ == SQLITE_OK, "res == Sqlite.OK");
	_tmp6_ = gee_array_list_new (OBJECTS_TYPE_RADIO, (GBoxedCopyFunc) g_object_ref, (GDestroyNotify) g_object_unref, NULL, NULL, NULL);
	all = _tmp6_;
	while (TRUE) {
		sqlite3_stmt* _tmp7_;
		gint _tmp8_;
		ObjectsRadio* radio = NULL;
		ObjectsRadio* _tmp9_;
		ObjectsRadio* _tmp10_;
		sqlite3_stmt* _tmp11_;
		ObjectsRadio* _tmp12_;
		sqlite3_stmt* _tmp13_;
		const gchar* _tmp14_;
		ObjectsRadio* _tmp15_;
		sqlite3_stmt* _tmp16_;
		const gchar* _tmp17_;
		ObjectsRadio* _tmp18_;
		sqlite3_stmt* _tmp19_;
		const gchar* _tmp20_;
		ObjectsRadio* _tmp21_;
		sqlite3_stmt* _tmp22_;
		const gchar* _tmp23_;
		ObjectsRadio* _tmp24_;
		sqlite3_stmt* _tmp25_;
		const gchar* _tmp26_;
		ObjectsRadio* _tmp27_;
		sqlite3_stmt* _tmp28_;
		const gchar* _tmp29_;
		ObjectsRadio* _tmp30_;
		sqlite3_stmt* _tmp31_;
		const gchar* _tmp32_;
		GeeArrayList* _tmp33_;
		ObjectsRadio* _tmp34_;
		_tmp7_ = stmt;
		res = sqlite3_step (_tmp7_);
		_tmp8_ = res;
		if (!(_tmp8_ == SQLITE_ROW)) {
			break;
		}
		_tmp9_ = objects_radio_new ();
		radio = _tmp9_;
		_tmp10_ = radio;
		_tmp11_ = stmt;
		objects_radio_set_id (_tmp10_, sqlite3_column_int (_tmp11_, 0));
		_tmp12_ = radio;
		_tmp13_ = stmt;
		_tmp14_ = sqlite3_column_text (_tmp13_, 1);
		objects_radio_set_name (_tmp12_, _tmp14_);
		_tmp15_ = radio;
		_tmp16_ = stmt;
		_tmp17_ = sqlite3_column_text (_tmp16_, 2);
		objects_radio_set_url (_tmp15_, _tmp17_);
		_tmp18_ = radio;
		_tmp19_ = stmt;
		_tmp20_ = sqlite3_column_text (_tmp19_, 3);
		objects_radio_set_homepage (_tmp18_, _tmp20_);
		_tmp21_ = radio;
		_tmp22_ = stmt;
		_tmp23_ = sqlite3_column_text (_tmp22_, 4);
		objects_radio_set_tags (_tmp21_, _tmp23_);
		_tmp24_ = radio;
		_tmp25_ = stmt;
		_tmp26_ = sqlite3_column_text (_tmp25_, 5);
		objects_radio_set_favicon (_tmp24_, _tmp26_);
		_tmp27_ = radio;
		_tmp28_ = stmt;
		_tmp29_ = sqlite3_column_text (_tmp28_, 6);
		objects_radio_set_country (_tmp27_, _tmp29_);
		_tmp30_ = radio;
		_tmp31_ = stmt;
		_tmp32_ = sqlite3_column_text (_tmp31_, 7);
		objects_radio_set_state (_tmp30_, _tmp32_);
		_tmp33_ = all;
		_tmp34_ = radio;
		gee_abstract_collection_add ((GeeAbstractCollection*) _tmp33_, _tmp34_);
		_g_object_unref0 (radio);
	}
	result = all;
	_g_free0 (sql);
	_sqlite3_finalize0 (stmt);
	return result;
}


GeeArrayList*
services_database_get_all_playlists (ServicesDatabase* self)
{
	GeeArrayList* result = NULL;
	sqlite3_stmt* stmt = NULL;
	gchar* sql = NULL;
	gint res = 0;
	gchar* _tmp0_;
	sqlite3* _tmp1_;
	const gchar* _tmp2_;
	sqlite3_stmt* _tmp3_ = NULL;
	gint _tmp4_;
	gint _tmp5_;
	GeeArrayList* all = NULL;
	GeeArrayList* _tmp6_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = g_strdup ("\n            SELECT * FROM playlists;\n        ");
	_g_free0 (sql);
	sql = _tmp0_;
	_tmp1_ = self->priv->db;
	_tmp2_ = sql;
	_tmp4_ = sqlite3_prepare_v2 (_tmp1_, _tmp2_, -1, &_tmp3_, NULL);
	_sqlite3_finalize0 (stmt);
	stmt = _tmp3_;
	res = _tmp4_;
	_tmp5_ = res;
	_vala_assert (_tmp5_ == SQLITE_OK, "res == Sqlite.OK");
	_tmp6_ = gee_array_list_new (OBJECTS_TYPE_PLAYLIST, (GBoxedCopyFunc) g_object_ref, (GDestroyNotify) g_object_unref, NULL, NULL, NULL);
	all = _tmp6_;
	while (TRUE) {
		sqlite3_stmt* _tmp7_;
		gint _tmp8_;
		ObjectsPlaylist* playlist = NULL;
		GDateTime* _tmp9_;
		GDateTime* _tmp10_;
		gchar* _tmp11_;
		gchar* _tmp12_;
		GDateTime* _tmp13_;
		GDateTime* _tmp14_;
		gchar* _tmp15_;
		gchar* _tmp16_;
		ObjectsPlaylist* _tmp17_;
		ObjectsPlaylist* _tmp18_;
		ObjectsPlaylist* _tmp19_;
		sqlite3_stmt* _tmp20_;
		ObjectsPlaylist* _tmp21_;
		sqlite3_stmt* _tmp22_;
		const gchar* _tmp23_;
		gchar* _tmp24_;
		ObjectsPlaylist* _tmp25_;
		sqlite3_stmt* _tmp26_;
		const gchar* _tmp27_;
		gchar* _tmp28_;
		ObjectsPlaylist* _tmp29_;
		sqlite3_stmt* _tmp30_;
		const gchar* _tmp31_;
		gchar* _tmp32_;
		ObjectsPlaylist* _tmp33_;
		sqlite3_stmt* _tmp34_;
		const gchar* _tmp35_;
		gchar* _tmp36_;
		GeeArrayList* _tmp37_;
		ObjectsPlaylist* _tmp38_;
		_tmp7_ = stmt;
		res = sqlite3_step (_tmp7_);
		_tmp8_ = res;
		if (!(_tmp8_ == SQLITE_ROW)) {
			break;
		}
		_tmp9_ = g_date_time_new_now_local ();
		_tmp10_ = _tmp9_;
		_tmp11_ = g_date_time_to_string (_tmp10_);
		_tmp12_ = _tmp11_;
		_tmp13_ = g_date_time_new_now_local ();
		_tmp14_ = _tmp13_;
		_tmp15_ = g_date_time_to_string (_tmp14_);
		_tmp16_ = _tmp15_;
		_tmp17_ = objects_playlist_new (0, "", "", _tmp12_, _tmp16_, 0);
		_tmp18_ = _tmp17_;
		_g_free0 (_tmp16_);
		_g_date_time_unref0 (_tmp14_);
		_g_free0 (_tmp12_);
		_g_date_time_unref0 (_tmp10_);
		playlist = _tmp18_;
		_tmp19_ = playlist;
		_tmp20_ = stmt;
		_tmp19_->id = sqlite3_column_int (_tmp20_, 0);
		_tmp21_ = playlist;
		_tmp22_ = stmt;
		_tmp23_ = sqlite3_column_text (_tmp22_, 1);
		_tmp24_ = g_strdup (_tmp23_);
		_g_free0 (_tmp21_->title);
		_tmp21_->title = _tmp24_;
		_tmp25_ = playlist;
		_tmp26_ = stmt;
		_tmp27_ = sqlite3_column_text (_tmp26_, 2);
		_tmp28_ = g_strdup (_tmp27_);
		_g_free0 (_tmp25_->note);
		_tmp25_->note = _tmp28_;
		_tmp29_ = playlist;
		_tmp30_ = stmt;
		_tmp31_ = sqlite3_column_text (_tmp30_, 3);
		_tmp32_ = g_strdup (_tmp31_);
		_g_free0 (_tmp29_->date_added);
		_tmp29_->date_added = _tmp32_;
		_tmp33_ = playlist;
		_tmp34_ = stmt;
		_tmp35_ = sqlite3_column_text (_tmp34_, 4);
		_tmp36_ = g_strdup (_tmp35_);
		_g_free0 (_tmp33_->date_updated);
		_tmp33_->date_updated = _tmp36_;
		_tmp37_ = all;
		_tmp38_ = playlist;
		gee_abstract_collection_add ((GeeAbstractCollection*) _tmp37_, _tmp38_);
		_g_object_unref0 (playlist);
	}
	result = all;
	_g_free0 (sql);
	_sqlite3_finalize0 (stmt);
	return result;
}


gint
services_database_insert_playlist (ServicesDatabase* self,
                                   ObjectsPlaylist* playlist)
{
	gint result = 0;
	sqlite3_stmt* stmt = NULL;
	gchar* sql = NULL;
	gint res = 0;
	gchar* _tmp0_;
	sqlite3* _tmp1_;
	const gchar* _tmp2_;
	sqlite3_stmt* _tmp3_ = NULL;
	gint _tmp4_;
	gint _tmp5_;
	sqlite3_stmt* _tmp6_;
	const gchar* _tmp7_;
	gchar* _tmp8_;
	GDestroyNotify _tmp9_;
	gint _tmp10_;
	sqlite3_stmt* _tmp11_;
	const gchar* _tmp12_;
	gchar* _tmp13_;
	GDestroyNotify _tmp14_;
	gint _tmp15_;
	sqlite3_stmt* _tmp16_;
	const gchar* _tmp17_;
	gchar* _tmp18_;
	GDestroyNotify _tmp19_;
	gint _tmp20_;
	sqlite3_stmt* _tmp21_;
	const gchar* _tmp22_;
	gchar* _tmp23_;
	GDestroyNotify _tmp24_;
	gint _tmp25_;
	sqlite3_stmt* _tmp26_;
	sqlite3_stmt* _tmp30_;
	gchar* _tmp31_;
	sqlite3* _tmp32_;
	const gchar* _tmp33_;
	sqlite3_stmt* _tmp34_ = NULL;
	gint _tmp35_;
	gint _tmp36_;
	sqlite3_stmt* _tmp37_;
	const gchar* _tmp38_;
	gchar* _tmp39_;
	GDestroyNotify _tmp40_;
	gint _tmp41_;
	sqlite3_stmt* _tmp42_;
	g_return_val_if_fail (self != NULL, 0);
	g_return_val_if_fail (playlist != NULL, 0);
	_tmp0_ = g_strdup ("\n" \
"            INSERT OR IGNORE INTO playlists (title, note, date_added, " \
"date_updated)\n" \
"            VALUES (?, ?, ?, ?);\n" \
"        ");
	_g_free0 (sql);
	sql = _tmp0_;
	_tmp1_ = self->priv->db;
	_tmp2_ = sql;
	_tmp4_ = sqlite3_prepare_v2 (_tmp1_, _tmp2_, -1, &_tmp3_, NULL);
	_sqlite3_finalize0 (stmt);
	stmt = _tmp3_;
	res = _tmp4_;
	_tmp5_ = res;
	_vala_assert (_tmp5_ == SQLITE_OK, "res == Sqlite.OK");
	_tmp6_ = stmt;
	_tmp7_ = playlist->title;
	_tmp8_ = g_strdup (_tmp7_);
	_tmp9_ = g_free;
	res = sqlite3_bind_text (_tmp6_, 1, _tmp8_, -1, _tmp9_);
	_tmp10_ = res;
	_vala_assert (_tmp10_ == SQLITE_OK, "res == Sqlite.OK");
	_tmp11_ = stmt;
	_tmp12_ = playlist->note;
	_tmp13_ = g_strdup (_tmp12_);
	_tmp14_ = g_free;
	res = sqlite3_bind_text (_tmp11_, 2, _tmp13_, -1, _tmp14_);
	_tmp15_ = res;
	_vala_assert (_tmp15_ == SQLITE_OK, "res == Sqlite.OK");
	_tmp16_ = stmt;
	_tmp17_ = playlist->date_added;
	_tmp18_ = g_strdup (_tmp17_);
	_tmp19_ = g_free;
	res = sqlite3_bind_text (_tmp16_, 3, _tmp18_, -1, _tmp19_);
	_tmp20_ = res;
	_vala_assert (_tmp20_ == SQLITE_OK, "res == Sqlite.OK");
	_tmp21_ = stmt;
	_tmp22_ = playlist->date_updated;
	_tmp23_ = g_strdup (_tmp22_);
	_tmp24_ = g_free;
	res = sqlite3_bind_text (_tmp21_, 4, _tmp23_, -1, _tmp24_);
	_tmp25_ = res;
	_vala_assert (_tmp25_ == SQLITE_OK, "res == Sqlite.OK");
	_tmp26_ = stmt;
	if (sqlite3_step (_tmp26_) != SQLITE_DONE) {
		sqlite3* _tmp27_;
		sqlite3* _tmp28_;
		const gchar* _tmp29_;
		_tmp27_ = self->priv->db;
		_tmp28_ = self->priv->db;
		_tmp29_ = sqlite3_errmsg (_tmp28_);
		g_warning ("Database.vala:1270: Error: %d: %s", sqlite3_errcode (_tmp27_), _tmp29_);
	}
	_tmp30_ = stmt;
	sqlite3_reset (_tmp30_);
	_tmp31_ = g_strdup ("\n" \
"            SELECT id FROM playlists WHERE date_added = ?;\n" \
"        ");
	_g_free0 (sql);
	sql = _tmp31_;
	_tmp32_ = self->priv->db;
	_tmp33_ = sql;
	_tmp35_ = sqlite3_prepare_v2 (_tmp32_, _tmp33_, -1, &_tmp34_, NULL);
	_sqlite3_finalize0 (stmt);
	stmt = _tmp34_;
	res = _tmp35_;
	_tmp36_ = res;
	_vala_assert (_tmp36_ == SQLITE_OK, "res == Sqlite.OK");
	_tmp37_ = stmt;
	_tmp38_ = playlist->date_added;
	_tmp39_ = g_strdup (_tmp38_);
	_tmp40_ = g_free;
	res = sqlite3_bind_text (_tmp37_, 1, _tmp39_, -1, _tmp40_);
	_tmp41_ = res;
	_vala_assert (_tmp41_ == SQLITE_OK, "res == Sqlite.OK");
	_tmp42_ = stmt;
	if (sqlite3_step (_tmp42_) == SQLITE_ROW) {
		sqlite3_stmt* _tmp43_;
		FILE* _tmp44_;
		gint _tmp45_;
		const gchar* _tmp46_;
		gint _tmp47_;
		_tmp43_ = stmt;
		playlist->id = sqlite3_column_int (_tmp43_, 0);
		_tmp44_ = stdout;
		_tmp45_ = playlist->id;
		_tmp46_ = playlist->title;
		fprintf (_tmp44_, "Playlist ID: %d - %s\n", _tmp45_, _tmp46_);
		g_signal_emit (self, services_database_signals[SERVICES_DATABASE_ADDEN_NEW_PLAYLIST_SIGNAL], 0, playlist);
		_tmp47_ = playlist->id;
		result = _tmp47_;
		_g_free0 (sql);
		_sqlite3_finalize0 (stmt);
		return result;
	} else {
		sqlite3* _tmp48_;
		sqlite3* _tmp49_;
		const gchar* _tmp50_;
		_tmp48_ = self->priv->db;
		_tmp49_ = self->priv->db;
		_tmp50_ = sqlite3_errmsg (_tmp49_);
		g_warning ("Database.vala:1291: Error: %d: %s", sqlite3_errcode (_tmp48_), _tmp50_);
		result = 0;
		_g_free0 (sql);
		_sqlite3_finalize0 (stmt);
		return result;
	}
	_g_free0 (sql);
	_sqlite3_finalize0 (stmt);
}


void
services_database_insert_track_into_playlist (ServicesDatabase* self,
                                              ObjectsPlaylist* playlist,
                                              gint track_id)
{
	sqlite3_stmt* stmt = NULL;
	gchar* sql = NULL;
	gint res = 0;
	gchar* _tmp0_;
	sqlite3* _tmp1_;
	const gchar* _tmp2_;
	sqlite3_stmt* _tmp3_ = NULL;
	gint _tmp4_;
	gint _tmp5_;
	sqlite3_stmt* _tmp6_;
	gint _tmp7_;
	gint _tmp8_;
	sqlite3_stmt* _tmp9_;
	gint _tmp10_;
	sqlite3_stmt* _tmp11_;
	GDateTime* _tmp12_;
	GDateTime* _tmp13_;
	gchar* _tmp14_;
	GDestroyNotify _tmp15_;
	gint _tmp16_;
	sqlite3_stmt* _tmp17_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (playlist != NULL);
	_tmp0_ = g_strdup ("\n" \
"            INSERT INTO playlist_tracks (playlist_id, track_id, date_a" \
"dded) VALUES (?, ?, ?);\n" \
"        ");
	_g_free0 (sql);
	sql = _tmp0_;
	_tmp1_ = self->priv->db;
	_tmp2_ = sql;
	_tmp4_ = sqlite3_prepare_v2 (_tmp1_, _tmp2_, -1, &_tmp3_, NULL);
	_sqlite3_finalize0 (stmt);
	stmt = _tmp3_;
	res = _tmp4_;
	_tmp5_ = res;
	_vala_assert (_tmp5_ == SQLITE_OK, "res == Sqlite.OK");
	_tmp6_ = stmt;
	_tmp7_ = playlist->id;
	res = sqlite3_bind_int (_tmp6_, 1, _tmp7_);
	_tmp8_ = res;
	_vala_assert (_tmp8_ == SQLITE_OK, "res == Sqlite.OK");
	_tmp9_ = stmt;
	res = sqlite3_bind_int (_tmp9_, 2, track_id);
	_tmp10_ = res;
	_vala_assert (_tmp10_ == SQLITE_OK, "res == Sqlite.OK");
	_tmp11_ = stmt;
	_tmp12_ = g_date_time_new_now_local ();
	_tmp13_ = _tmp12_;
	_tmp14_ = g_date_time_to_string (_tmp13_);
	_tmp15_ = g_free;
	res = sqlite3_bind_text (_tmp11_, 3, _tmp14_, -1, _tmp15_);
	_g_date_time_unref0 (_tmp13_);
	_tmp16_ = res;
	_vala_assert (_tmp16_ == SQLITE_OK, "res == Sqlite.OK");
	_tmp17_ = stmt;
	if (sqlite3_step (_tmp17_) == SQLITE_DONE) {
		gchar* _tmp18_;
		gchar* _tmp19_;
		GDateTime* _tmp20_;
		GDateTime* _tmp21_;
		gchar* _tmp22_;
		ServicesDatabase* _tmp23_;
		_tmp18_ = g_strdup_printf ("Track: %i agregado \n", track_id);
		_tmp19_ = _tmp18_;
		g_print ("%s", _tmp19_);
		_g_free0 (_tmp19_);
		_tmp20_ = g_date_time_new_now_local ();
		_tmp21_ = _tmp20_;
		_tmp22_ = g_date_time_to_string (_tmp21_);
		_g_free0 (playlist->date_updated);
		playlist->date_updated = _tmp22_;
		_g_date_time_unref0 (_tmp21_);
		_tmp23_ = byte_database;
		services_database_update_playlist (_tmp23_, playlist);
	}
	_g_free0 (sql);
	_sqlite3_finalize0 (stmt);
}


void
services_database_add_track_count (ServicesDatabase* self,
                                   ObjectsTrack* track)
{
	sqlite3_stmt* stmt = NULL;
	gchar* sql = NULL;
	gint res = 0;
	gchar* _tmp0_;
	sqlite3* _tmp1_;
	const gchar* _tmp2_;
	sqlite3_stmt* _tmp3_ = NULL;
	gint _tmp4_;
	gint _tmp5_;
	sqlite3_stmt* _tmp6_;
	gint _tmp7_;
	gint _tmp8_;
	sqlite3_stmt* _tmp9_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (track != NULL);
	_tmp0_ = g_strdup ("\n            SELECT play_count FROM tracks WHERE id = ?;\n        ");
	_g_free0 (sql);
	sql = _tmp0_;
	_tmp1_ = self->priv->db;
	_tmp2_ = sql;
	_tmp4_ = sqlite3_prepare_v2 (_tmp1_, _tmp2_, -1, &_tmp3_, NULL);
	_sqlite3_finalize0 (stmt);
	stmt = _tmp3_;
	res = _tmp4_;
	_tmp5_ = res;
	_vala_assert (_tmp5_ == SQLITE_OK, "res == Sqlite.OK");
	_tmp6_ = stmt;
	_tmp7_ = track->id;
	res = sqlite3_bind_int (_tmp6_, 1, _tmp7_);
	_tmp8_ = res;
	_vala_assert (_tmp8_ == SQLITE_OK, "res == Sqlite.OK");
	_tmp9_ = stmt;
	if (sqlite3_step (_tmp9_) == SQLITE_ROW) {
		gint count = 0;
		sqlite3_stmt* _tmp10_;
		sqlite3_stmt* _tmp11_;
		gchar* _tmp12_;
		sqlite3* _tmp13_;
		const gchar* _tmp14_;
		sqlite3_stmt* _tmp15_ = NULL;
		gint _tmp16_;
		gint _tmp17_;
		sqlite3_stmt* _tmp18_;
		gint _tmp19_;
		gint _tmp20_;
		sqlite3_stmt* _tmp21_;
		GDateTime* _tmp22_;
		GDateTime* _tmp23_;
		gchar* _tmp24_;
		GDestroyNotify _tmp25_;
		gint _tmp26_;
		sqlite3_stmt* _tmp27_;
		gint _tmp28_;
		gint _tmp29_;
		sqlite3_stmt* _tmp30_;
		gint _tmp31_;
		_tmp10_ = stmt;
		count = sqlite3_column_int (_tmp10_, 0) + 1;
		_tmp11_ = stmt;
		sqlite3_reset (_tmp11_);
		_tmp12_ = g_strdup ("\n" \
"                UPDATE tracks SET play_count = ?, last_played = ? WHER" \
"E id = ?;\n" \
"            ");
		_g_free0 (sql);
		sql = _tmp12_;
		_tmp13_ = self->priv->db;
		_tmp14_ = sql;
		_tmp16_ = sqlite3_prepare_v2 (_tmp13_, _tmp14_, -1, &_tmp15_, NULL);
		_sqlite3_finalize0 (stmt);
		stmt = _tmp15_;
		res = _tmp16_;
		_tmp17_ = res;
		_vala_assert (_tmp17_ == SQLITE_OK, "res == Sqlite.OK");
		_tmp18_ = stmt;
		_tmp19_ = count;
		res = sqlite3_bind_int (_tmp18_, 1, _tmp19_);
		_tmp20_ = res;
		_vala_assert (_tmp20_ == SQLITE_OK, "res == Sqlite.OK");
		_tmp21_ = stmt;
		_tmp22_ = g_date_time_new_now_local ();
		_tmp23_ = _tmp22_;
		_tmp24_ = g_date_time_to_string (_tmp23_);
		_tmp25_ = g_free;
		res = sqlite3_bind_text (_tmp21_, 2, _tmp24_, -1, _tmp25_);
		_g_date_time_unref0 (_tmp23_);
		_tmp26_ = res;
		_vala_assert (_tmp26_ == SQLITE_OK, "res == Sqlite.OK");
		_tmp27_ = stmt;
		_tmp28_ = track->id;
		res = sqlite3_bind_int (_tmp27_, 3, _tmp28_);
		_tmp29_ = res;
		_vala_assert (_tmp29_ == SQLITE_OK, "res == Sqlite.OK");
		_tmp30_ = stmt;
		res = sqlite3_step (_tmp30_);
		_tmp31_ = res;
		if (_tmp31_ == SQLITE_DONE) {
			const gchar* _tmp32_;
			gint _tmp33_;
			gchar* _tmp34_;
			gchar* _tmp35_;
			_tmp32_ = track->title;
			_tmp33_ = count;
			_tmp34_ = g_strdup_printf ("Track: %s - Count: %i\n", _tmp32_, _tmp33_);
			_tmp35_ = _tmp34_;
			g_print ("%s", _tmp35_);
			_g_free0 (_tmp35_);
		}
	} else {
		sqlite3* _tmp36_;
		sqlite3* _tmp37_;
		const gchar* _tmp38_;
		_tmp36_ = self->priv->db;
		_tmp37_ = self->priv->db;
		_tmp38_ = sqlite3_errmsg (_tmp37_);
		g_warning ("Database.vala:1366: Error: %d: %s", sqlite3_errcode (_tmp36_), _tmp38_);
	}
	_g_free0 (sql);
	_sqlite3_finalize0 (stmt);
}


void
services_database_set_track_favorite (ServicesDatabase* self,
                                      ObjectsTrack* track,
                                      gint favorite)
{
	sqlite3_stmt* stmt = NULL;
	gchar* sql = NULL;
	gint res = 0;
	gchar* favorite_added = NULL;
	gchar* _tmp0_;
	gchar* _tmp1_;
	sqlite3* _tmp2_;
	const gchar* _tmp3_;
	sqlite3_stmt* _tmp4_ = NULL;
	gint _tmp5_;
	gint _tmp6_;
	sqlite3_stmt* _tmp7_;
	gint _tmp8_;
	sqlite3_stmt* _tmp12_;
	const gchar* _tmp13_;
	gchar* _tmp14_;
	GDestroyNotify _tmp15_;
	gint _tmp16_;
	sqlite3_stmt* _tmp17_;
	gint _tmp18_;
	gint _tmp19_;
	sqlite3_stmt* _tmp20_;
	gint _tmp21_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (track != NULL);
	_tmp0_ = g_strdup ("");
	favorite_added = _tmp0_;
	_tmp1_ = g_strdup ("\n" \
"            UPDATE tracks SET is_favorite = ?, favorite_added = ? WHER" \
"E id = ?;\n" \
"        ");
	_g_free0 (sql);
	sql = _tmp1_;
	_tmp2_ = self->priv->db;
	_tmp3_ = sql;
	_tmp5_ = sqlite3_prepare_v2 (_tmp2_, _tmp3_, -1, &_tmp4_, NULL);
	_sqlite3_finalize0 (stmt);
	stmt = _tmp4_;
	res = _tmp5_;
	_tmp6_ = res;
	_vala_assert (_tmp6_ == SQLITE_OK, "res == Sqlite.OK");
	_tmp7_ = stmt;
	res = sqlite3_bind_int (_tmp7_, 1, favorite);
	_tmp8_ = res;
	_vala_assert (_tmp8_ == SQLITE_OK, "res == Sqlite.OK");
	if (favorite == 1) {
		GDateTime* _tmp9_;
		GDateTime* _tmp10_;
		gchar* _tmp11_;
		_tmp9_ = g_date_time_new_now_local ();
		_tmp10_ = _tmp9_;
		_tmp11_ = g_date_time_to_string (_tmp10_);
		_g_free0 (favorite_added);
		favorite_added = _tmp11_;
		_g_date_time_unref0 (_tmp10_);
	}
	_tmp12_ = stmt;
	_tmp13_ = favorite_added;
	_tmp14_ = g_strdup (_tmp13_);
	_tmp15_ = g_free;
	res = sqlite3_bind_text (_tmp12_, 2, _tmp14_, -1, _tmp15_);
	_tmp16_ = res;
	_vala_assert (_tmp16_ == SQLITE_OK, "res == Sqlite.OK");
	_tmp17_ = stmt;
	_tmp18_ = track->id;
	res = sqlite3_bind_int (_tmp17_, 3, _tmp18_);
	_tmp19_ = res;
	_vala_assert (_tmp19_ == SQLITE_OK, "res == Sqlite.OK");
	_tmp20_ = stmt;
	res = sqlite3_step (_tmp20_);
	_tmp21_ = res;
	if (_tmp21_ == SQLITE_DONE) {
		const gchar* _tmp22_;
		gchar* _tmp23_;
		gchar* _tmp24_;
		_tmp22_ = track->title;
		_tmp23_ = g_strdup_printf ("Track: %s - Favorite: %i\n", _tmp22_, favorite);
		_tmp24_ = _tmp23_;
		g_print ("%s", _tmp24_);
		_g_free0 (_tmp24_);
		g_signal_emit (self, services_database_signals[SERVICES_DATABASE_UPDATED_TRACK_FAVORITE_SIGNAL], 0, track, favorite);
	}
	_g_free0 (favorite_added);
	_g_free0 (sql);
	_sqlite3_finalize0 (stmt);
}


gint
services_database_is_track_favorite (ServicesDatabase* self,
                                     ObjectsTrack* track)
{
	gint result = 0;
	sqlite3_stmt* stmt = NULL;
	gchar* sql = NULL;
	gint res = 0;
	gchar* _tmp0_;
	sqlite3* _tmp1_;
	const gchar* _tmp2_;
	sqlite3_stmt* _tmp3_ = NULL;
	gint _tmp4_;
	gint _tmp5_;
	sqlite3_stmt* _tmp6_;
	gint _tmp7_;
	gint _tmp8_;
	sqlite3_stmt* _tmp9_;
	g_return_val_if_fail (self != NULL, 0);
	g_return_val_if_fail (track != NULL, 0);
	_tmp0_ = g_strdup ("\n            SELECT is_favorite FROM tracks WHERE id = ?;\n        ");
	_g_free0 (sql);
	sql = _tmp0_;
	_tmp1_ = self->priv->db;
	_tmp2_ = sql;
	_tmp4_ = sqlite3_prepare_v2 (_tmp1_, _tmp2_, -1, &_tmp3_, NULL);
	_sqlite3_finalize0 (stmt);
	stmt = _tmp3_;
	res = _tmp4_;
	_tmp5_ = res;
	_vala_assert (_tmp5_ == SQLITE_OK, "res == Sqlite.OK");
	_tmp6_ = stmt;
	_tmp7_ = track->id;
	res = sqlite3_bind_int (_tmp6_, 1, _tmp7_);
	_tmp8_ = res;
	_vala_assert (_tmp8_ == SQLITE_OK, "res == Sqlite.OK");
	_tmp9_ = stmt;
	if (sqlite3_step (_tmp9_) == SQLITE_ROW) {
		sqlite3_stmt* _tmp10_;
		_tmp10_ = stmt;
		result = sqlite3_column_int (_tmp10_, 0);
		_g_free0 (sql);
		_sqlite3_finalize0 (stmt);
		return result;
	} else {
		result = 0;
		_g_free0 (sql);
		_sqlite3_finalize0 (stmt);
		return result;
	}
	_g_free0 (sql);
	_sqlite3_finalize0 (stmt);
}


void
services_database_remove_from_library (ServicesDatabase* self,
                                       ObjectsTrack* track)
{
	sqlite3_stmt* stmt = NULL;
	gchar* sql = NULL;
	gint res = 0;
	gchar* _tmp0_;
	sqlite3* _tmp1_;
	const gchar* _tmp2_;
	sqlite3_stmt* _tmp3_ = NULL;
	gint _tmp4_;
	gint _tmp5_;
	sqlite3_stmt* _tmp6_;
	gint _tmp7_;
	gint _tmp8_;
	sqlite3_stmt* _tmp9_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (track != NULL);
	_tmp0_ = g_strdup ("\n            DELETE FROM tracks where id = ?;\n        ");
	_g_free0 (sql);
	sql = _tmp0_;
	_tmp1_ = self->priv->db;
	_tmp2_ = sql;
	_tmp4_ = sqlite3_prepare_v2 (_tmp1_, _tmp2_, -1, &_tmp3_, NULL);
	_sqlite3_finalize0 (stmt);
	stmt = _tmp3_;
	res = _tmp4_;
	_tmp5_ = res;
	_vala_assert (_tmp5_ == SQLITE_OK, "res == Sqlite.OK");
	_tmp6_ = stmt;
	_tmp7_ = track->id;
	res = sqlite3_bind_int (_tmp6_, 1, _tmp7_);
	_tmp8_ = res;
	_vala_assert (_tmp8_ == SQLITE_OK, "res == Sqlite.OK");
	_tmp9_ = stmt;
	if (sqlite3_step (_tmp9_) == SQLITE_DONE) {
		sqlite3_stmt* _tmp10_;
		gchar* _tmp11_;
		sqlite3* _tmp12_;
		const gchar* _tmp13_;
		sqlite3_stmt* _tmp14_ = NULL;
		gint _tmp15_;
		gint _tmp16_;
		sqlite3_stmt* _tmp17_;
		const gchar* _tmp18_;
		gchar* _tmp19_;
		GDestroyNotify _tmp20_;
		gint _tmp21_;
		sqlite3_stmt* _tmp22_;
		_tmp10_ = stmt;
		sqlite3_reset (_tmp10_);
		_tmp11_ = g_strdup ("\n" \
"                INSERT INTO blacklist (path) VALUES (?);\n" \
"            ");
		_g_free0 (sql);
		sql = _tmp11_;
		_tmp12_ = self->priv->db;
		_tmp13_ = sql;
		_tmp15_ = sqlite3_prepare_v2 (_tmp12_, _tmp13_, -1, &_tmp14_, NULL);
		_sqlite3_finalize0 (stmt);
		stmt = _tmp14_;
		res = _tmp15_;
		_tmp16_ = res;
		_vala_assert (_tmp16_ == SQLITE_OK, "res == Sqlite.OK");
		_tmp17_ = stmt;
		_tmp18_ = track->path;
		_tmp19_ = g_strdup (_tmp18_);
		_tmp20_ = g_free;
		res = sqlite3_bind_text (_tmp17_, 1, _tmp19_, -1, _tmp20_);
		_tmp21_ = res;
		_vala_assert (_tmp21_ == SQLITE_OK, "res == Sqlite.OK");
		_tmp22_ = stmt;
		if (sqlite3_step (_tmp22_) == SQLITE_DONE) {
			gint _tmp23_;
			_tmp23_ = track->id;
			g_signal_emit (self, services_database_signals[SERVICES_DATABASE_REMOVED_TRACK_SIGNAL], 0, _tmp23_);
		} else {
			sqlite3* _tmp24_;
			sqlite3* _tmp25_;
			const gchar* _tmp26_;
			_tmp24_ = self->priv->db;
			_tmp25_ = self->priv->db;
			_tmp26_ = sqlite3_errmsg (_tmp25_);
			g_warning ("Database.vala:1461: Error: %d: %s", sqlite3_errcode (_tmp24_), _tmp26_);
		}
	}
	_g_free0 (sql);
	_sqlite3_finalize0 (stmt);
}


gboolean
services_database_remove_radio_from_library (ServicesDatabase* self,
                                             ObjectsRadio* radio)
{
	gboolean result = FALSE;
	sqlite3_stmt* stmt = NULL;
	gchar* sql = NULL;
	gint res = 0;
	gchar* _tmp0_;
	sqlite3* _tmp1_;
	const gchar* _tmp2_;
	sqlite3_stmt* _tmp3_ = NULL;
	gint _tmp4_;
	gint _tmp5_;
	sqlite3_stmt* _tmp6_;
	gint _tmp7_;
	gint _tmp8_;
	gint _tmp9_;
	sqlite3_stmt* _tmp10_;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (radio != NULL, FALSE);
	_tmp0_ = g_strdup ("\n            DELETE FROM radios WHERE id = ?;\n        ");
	_g_free0 (sql);
	sql = _tmp0_;
	_tmp1_ = self->priv->db;
	_tmp2_ = sql;
	_tmp4_ = sqlite3_prepare_v2 (_tmp1_, _tmp2_, -1, &_tmp3_, NULL);
	_sqlite3_finalize0 (stmt);
	stmt = _tmp3_;
	res = _tmp4_;
	_tmp5_ = res;
	_vala_assert (_tmp5_ == SQLITE_OK, "res == Sqlite.OK");
	_tmp6_ = stmt;
	_tmp7_ = objects_radio_get_id (radio);
	_tmp8_ = _tmp7_;
	res = sqlite3_bind_int (_tmp6_, 1, _tmp8_);
	_tmp9_ = res;
	_vala_assert (_tmp9_ == SQLITE_OK, "res == Sqlite.OK");
	_tmp10_ = stmt;
	if (sqlite3_step (_tmp10_) == SQLITE_DONE) {
		result = TRUE;
		_g_free0 (sql);
		_sqlite3_finalize0 (stmt);
		return result;
	}
	result = FALSE;
	_g_free0 (sql);
	_sqlite3_finalize0 (stmt);
	return result;
}


gboolean
services_database_remove_playlist_from_library (ServicesDatabase* self,
                                                ObjectsPlaylist* playlist)
{
	gboolean result = FALSE;
	sqlite3_stmt* stmt = NULL;
	gchar* sql = NULL;
	gint res = 0;
	gchar* _tmp0_;
	sqlite3* _tmp1_;
	const gchar* _tmp2_;
	sqlite3_stmt* _tmp3_ = NULL;
	gint _tmp4_;
	gint _tmp5_;
	sqlite3_stmt* _tmp6_;
	gint _tmp7_;
	gint _tmp8_;
	sqlite3_stmt* _tmp9_;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (playlist != NULL, FALSE);
	_tmp0_ = g_strdup ("\n            DELETE FROM playlists WHERE id = ?;\n        ");
	_g_free0 (sql);
	sql = _tmp0_;
	_tmp1_ = self->priv->db;
	_tmp2_ = sql;
	_tmp4_ = sqlite3_prepare_v2 (_tmp1_, _tmp2_, -1, &_tmp3_, NULL);
	_sqlite3_finalize0 (stmt);
	stmt = _tmp3_;
	res = _tmp4_;
	_tmp5_ = res;
	_vala_assert (_tmp5_ == SQLITE_OK, "res == Sqlite.OK");
	_tmp6_ = stmt;
	_tmp7_ = playlist->id;
	res = sqlite3_bind_int (_tmp6_, 1, _tmp7_);
	_tmp8_ = res;
	_vala_assert (_tmp8_ == SQLITE_OK, "res == Sqlite.OK");
	_tmp9_ = stmt;
	if (sqlite3_step (_tmp9_) == SQLITE_DONE) {
		sqlite3_stmt* _tmp10_;
		gchar* _tmp11_;
		sqlite3* _tmp12_;
		const gchar* _tmp13_;
		sqlite3_stmt* _tmp14_ = NULL;
		gint _tmp15_;
		gint _tmp16_;
		sqlite3_stmt* _tmp17_;
		gint _tmp18_;
		gint _tmp19_;
		sqlite3_stmt* _tmp20_;
		_tmp10_ = stmt;
		sqlite3_reset (_tmp10_);
		_tmp11_ = g_strdup ("\n" \
"                DELETE FROM playlist_tracks WHERE playlist_id = ?; \n" \
"            ");
		_g_free0 (sql);
		sql = _tmp11_;
		_tmp12_ = self->priv->db;
		_tmp13_ = sql;
		_tmp15_ = sqlite3_prepare_v2 (_tmp12_, _tmp13_, -1, &_tmp14_, NULL);
		_sqlite3_finalize0 (stmt);
		stmt = _tmp14_;
		res = _tmp15_;
		_tmp16_ = res;
		_vala_assert (_tmp16_ == SQLITE_OK, "res == Sqlite.OK");
		_tmp17_ = stmt;
		_tmp18_ = playlist->id;
		res = sqlite3_bind_int (_tmp17_, 1, _tmp18_);
		_tmp19_ = res;
		_vala_assert (_tmp19_ == SQLITE_OK, "res == Sqlite.OK");
		_tmp20_ = stmt;
		if (sqlite3_step (_tmp20_) == SQLITE_DONE) {
			gint _tmp21_;
			_tmp21_ = playlist->id;
			g_signal_emit (self, services_database_signals[SERVICES_DATABASE_REMOVED_PLAYLIST_SIGNAL], 0, _tmp21_);
			result = TRUE;
			_g_free0 (sql);
			_sqlite3_finalize0 (stmt);
			return result;
		} else {
			sqlite3* _tmp22_;
			sqlite3* _tmp23_;
			const gchar* _tmp24_;
			_tmp22_ = self->priv->db;
			_tmp23_ = self->priv->db;
			_tmp24_ = sqlite3_errmsg (_tmp23_);
			g_warning ("Database.vala:1520: Error: %d: %s", sqlite3_errcode (_tmp22_), _tmp24_);
			result = FALSE;
			_g_free0 (sql);
			_sqlite3_finalize0 (stmt);
			return result;
		}
	}
	result = FALSE;
	_g_free0 (sql);
	_sqlite3_finalize0 (stmt);
	return result;
}


gboolean
services_database_remove_from_playlist (ServicesDatabase* self,
                                        ObjectsTrack* track)
{
	gboolean result = FALSE;
	sqlite3_stmt* stmt = NULL;
	gchar* sql = NULL;
	gint res = 0;
	gchar* _tmp0_;
	sqlite3* _tmp1_;
	const gchar* _tmp2_;
	sqlite3_stmt* _tmp3_ = NULL;
	gint _tmp4_;
	gint _tmp5_;
	sqlite3_stmt* _tmp6_;
	gint _tmp7_;
	gint _tmp8_;
	sqlite3_stmt* _tmp9_;
	gint _tmp10_;
	gint _tmp11_;
	sqlite3_stmt* _tmp12_;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (track != NULL, FALSE);
	_tmp0_ = g_strdup ("\n" \
"            DELETE FROM playlist_tracks where track_id = ? AND playlis" \
"t_id = ?;\n" \
"        ");
	_g_free0 (sql);
	sql = _tmp0_;
	_tmp1_ = self->priv->db;
	_tmp2_ = sql;
	_tmp4_ = sqlite3_prepare_v2 (_tmp1_, _tmp2_, -1, &_tmp3_, NULL);
	_sqlite3_finalize0 (stmt);
	stmt = _tmp3_;
	res = _tmp4_;
	_tmp5_ = res;
	_vala_assert (_tmp5_ == SQLITE_OK, "res == Sqlite.OK");
	_tmp6_ = stmt;
	_tmp7_ = track->id;
	res = sqlite3_bind_int (_tmp6_, 1, _tmp7_);
	_tmp8_ = res;
	_vala_assert (_tmp8_ == SQLITE_OK, "res == Sqlite.OK");
	_tmp9_ = stmt;
	_tmp10_ = track->playlist;
	res = sqlite3_bind_int (_tmp9_, 2, _tmp10_);
	_tmp11_ = res;
	_vala_assert (_tmp11_ == SQLITE_OK, "res == Sqlite.OK");
	_tmp12_ = stmt;
	if (sqlite3_step (_tmp12_) == SQLITE_DONE) {
		result = TRUE;
		_g_free0 (sql);
		_sqlite3_finalize0 (stmt);
		return result;
	} else {
		result = FALSE;
		_g_free0 (sql);
		_sqlite3_finalize0 (stmt);
		return result;
	}
	_g_free0 (sql);
	_sqlite3_finalize0 (stmt);
}


void
services_database_reset_all_library (ServicesDatabase* self)
{
	GFile* db_path = NULL;
	const gchar* _tmp0_;
	GFile* _tmp1_;
	GFile* directory = NULL;
	Utils* _tmp5_;
	const gchar* _tmp6_;
	GFile* _tmp7_;
	GFile* _tmp25_;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->db_path;
	_tmp1_ = g_file_new_for_path (_tmp0_);
	db_path = _tmp1_;
	{
		GFile* _tmp2_;
		_tmp2_ = db_path;
		g_file_delete (_tmp2_, NULL, &_inner_error_);
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			goto __catch6_g_error;
		}
	}
	goto __finally6;
	__catch6_g_error:
	{
		GError* err = NULL;
		GError* _tmp3_;
		const gchar* _tmp4_;
		err = _inner_error_;
		_inner_error_ = NULL;
		_tmp3_ = err;
		_tmp4_ = _tmp3_->message;
		g_warning ("Database.vala:1558: %s", _tmp4_);
		_g_error_free0 (err);
	}
	__finally6:
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		_g_object_unref0 (db_path);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	services_database_create_tables (self);
	g_signal_emit (self, services_database_signals[SERVICES_DATABASE_RESET_LIBRARY_SIGNAL], 0);
	_tmp5_ = byte_utils;
	_tmp6_ = _tmp5_->COVER_FOLDER;
	_tmp7_ = g_file_new_for_path (_tmp6_);
	directory = _tmp7_;
	{
		GFileEnumerator* children = NULL;
		GFile* _tmp8_;
		GFileEnumerator* _tmp9_;
		GFileInfo* file_info = NULL;
		GFileEnumerator* _tmp21_;
		GFileEnumerator* _tmp22_;
		_tmp8_ = directory;
		_tmp9_ = g_file_enumerate_children (_tmp8_, "", 0, NULL, &_inner_error_);
		children = _tmp9_;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			goto __catch7_g_error;
		}
		while (TRUE) {
			GFileInfo* _tmp10_ = NULL;
			GFileEnumerator* _tmp11_;
			GFileInfo* _tmp12_;
			GFileInfo* _tmp13_;
			GFileInfo* _tmp14_;
			Utils* _tmp15_;
			const gchar* _tmp16_;
			GFileInfo* _tmp17_;
			const gchar* _tmp18_;
			gchar* _tmp19_;
			gchar* _tmp20_;
			_tmp11_ = children;
			_tmp12_ = g_file_enumerator_next_file (_tmp11_, NULL, &_inner_error_);
			_tmp10_ = _tmp12_;
			if (G_UNLIKELY (_inner_error_ != NULL)) {
				_g_object_unref0 (file_info);
				_g_object_unref0 (children);
				goto __catch7_g_error;
			}
			_tmp13_ = _tmp10_;
			_tmp10_ = NULL;
			_g_object_unref0 (file_info);
			file_info = _tmp13_;
			_tmp14_ = file_info;
			if (!(_tmp14_ != NULL)) {
				_g_object_unref0 (_tmp10_);
				break;
			}
			_tmp15_ = byte_utils;
			_tmp16_ = _tmp15_->COVER_FOLDER;
			_tmp17_ = file_info;
			_tmp18_ = g_file_info_get_name (_tmp17_);
			_tmp19_ = g_build_filename (_tmp16_, _tmp18_, NULL);
			_tmp20_ = _tmp19_;
			g_remove (_tmp20_);
			_g_free0 (_tmp20_);
			_g_object_unref0 (_tmp10_);
		}
		_tmp21_ = children;
		g_file_enumerator_close (_tmp21_, NULL, &_inner_error_);
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			_g_object_unref0 (file_info);
			_g_object_unref0 (children);
			goto __catch7_g_error;
		}
		_tmp22_ = children;
		g_object_run_dispose ((GObject*) _tmp22_);
		_g_object_unref0 (file_info);
		_g_object_unref0 (children);
	}
	goto __finally7;
	__catch7_g_error:
	{
		GError* err = NULL;
		GError* _tmp23_;
		const gchar* _tmp24_;
		err = _inner_error_;
		_inner_error_ = NULL;
		_tmp23_ = err;
		_tmp24_ = _tmp23_->message;
		g_warning ("Database.vala:1575: %s", _tmp24_);
		_g_error_free0 (err);
	}
	__finally7:
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		_g_object_unref0 (directory);
		_g_object_unref0 (db_path);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	_tmp25_ = directory;
	g_object_run_dispose ((GObject*) _tmp25_);
	_g_object_unref0 (directory);
	_g_object_unref0 (db_path);
}


void
services_database_update_playlist (ServicesDatabase* self,
                                   ObjectsPlaylist* playlist)
{
	sqlite3_stmt* stmt = NULL;
	gchar* sql = NULL;
	gint res = 0;
	gchar* _tmp0_;
	sqlite3* _tmp1_;
	const gchar* _tmp2_;
	sqlite3_stmt* _tmp3_ = NULL;
	gint _tmp4_;
	gint _tmp5_;
	sqlite3_stmt* _tmp6_;
	const gchar* _tmp7_;
	gchar* _tmp8_;
	GDestroyNotify _tmp9_;
	gint _tmp10_;
	sqlite3_stmt* _tmp11_;
	const gchar* _tmp12_;
	gchar* _tmp13_;
	GDestroyNotify _tmp14_;
	gint _tmp15_;
	sqlite3_stmt* _tmp16_;
	const gchar* _tmp17_;
	gchar* _tmp18_;
	GDestroyNotify _tmp19_;
	gint _tmp20_;
	sqlite3_stmt* _tmp21_;
	gint _tmp22_;
	gint _tmp23_;
	sqlite3_stmt* _tmp24_;
	gint _tmp25_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (playlist != NULL);
	_tmp0_ = g_strdup ("\n" \
"            UPDATE playlists SET title = ?, note = ?, date_updated = ?" \
" WHERE id = ?;\n" \
"        ");
	_g_free0 (sql);
	sql = _tmp0_;
	_tmp1_ = self->priv->db;
	_tmp2_ = sql;
	_tmp4_ = sqlite3_prepare_v2 (_tmp1_, _tmp2_, -1, &_tmp3_, NULL);
	_sqlite3_finalize0 (stmt);
	stmt = _tmp3_;
	res = _tmp4_;
	_tmp5_ = res;
	_vala_assert (_tmp5_ == SQLITE_OK, "res == Sqlite.OK");
	_tmp6_ = stmt;
	_tmp7_ = playlist->title;
	_tmp8_ = g_strdup (_tmp7_);
	_tmp9_ = g_free;
	res = sqlite3_bind_text (_tmp6_, 1, _tmp8_, -1, _tmp9_);
	_tmp10_ = res;
	_vala_assert (_tmp10_ == SQLITE_OK, "res == Sqlite.OK");
	_tmp11_ = stmt;
	_tmp12_ = playlist->note;
	_tmp13_ = g_strdup (_tmp12_);
	_tmp14_ = g_free;
	res = sqlite3_bind_text (_tmp11_, 2, _tmp13_, -1, _tmp14_);
	_tmp15_ = res;
	_vala_assert (_tmp15_ == SQLITE_OK, "res == Sqlite.OK");
	_tmp16_ = stmt;
	_tmp17_ = playlist->date_updated;
	_tmp18_ = g_strdup (_tmp17_);
	_tmp19_ = g_free;
	res = sqlite3_bind_text (_tmp16_, 3, _tmp18_, -1, _tmp19_);
	_tmp20_ = res;
	_vala_assert (_tmp20_ == SQLITE_OK, "res == Sqlite.OK");
	_tmp21_ = stmt;
	_tmp22_ = playlist->id;
	res = sqlite3_bind_int (_tmp21_, 4, _tmp22_);
	_tmp23_ = res;
	_vala_assert (_tmp23_ == SQLITE_OK, "res == Sqlite.OK");
	_tmp24_ = stmt;
	res = sqlite3_step (_tmp24_);
	_tmp25_ = res;
	if (_tmp25_ == SQLITE_DONE) {
		g_signal_emit (self, services_database_signals[SERVICES_DATABASE_UPDATED_PLAYLIST_SIGNAL], 0, playlist);
	}
	_g_free0 (sql);
	_sqlite3_finalize0 (stmt);
}


ObjectsPlaylist*
services_database_get_playlist_by_title (ServicesDatabase* self,
                                         const gchar* title)
{
	ObjectsPlaylist* result = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (title != NULL, NULL);
	{
		GeeArrayList* _playlist_list = NULL;
		ServicesDatabase* _tmp0_;
		GeeArrayList* _tmp1_;
		gint _playlist_size = 0;
		GeeArrayList* _tmp2_;
		gint _tmp3_;
		gint _tmp4_;
		gint _playlist_index = 0;
		_tmp0_ = byte_database;
		_tmp1_ = services_database_get_all_playlists (_tmp0_);
		_playlist_list = _tmp1_;
		_tmp2_ = _playlist_list;
		_tmp3_ = gee_abstract_collection_get_size ((GeeAbstractCollection*) _tmp2_);
		_tmp4_ = _tmp3_;
		_playlist_size = _tmp4_;
		_playlist_index = -1;
		while (TRUE) {
			gint _tmp5_;
			gint _tmp6_;
			gint _tmp7_;
			ObjectsPlaylist* playlist = NULL;
			GeeArrayList* _tmp8_;
			gint _tmp9_;
			gpointer _tmp10_;
			ObjectsPlaylist* _tmp11_;
			const gchar* _tmp12_;
			_tmp5_ = _playlist_index;
			_playlist_index = _tmp5_ + 1;
			_tmp6_ = _playlist_index;
			_tmp7_ = _playlist_size;
			if (!(_tmp6_ < _tmp7_)) {
				break;
			}
			_tmp8_ = _playlist_list;
			_tmp9_ = _playlist_index;
			_tmp10_ = gee_abstract_list_get ((GeeAbstractList*) _tmp8_, _tmp9_);
			playlist = (ObjectsPlaylist*) _tmp10_;
			_tmp11_ = playlist;
			_tmp12_ = _tmp11_->title;
			if (g_strcmp0 (_tmp12_, title) == 0) {
				result = playlist;
				_g_object_unref0 (_playlist_list);
				return result;
			}
			_g_object_unref0 (playlist);
		}
		_g_object_unref0 (_playlist_list);
	}
	result = NULL;
	return result;
}


ObjectsPlaylist*
services_database_create_new_playlist (ServicesDatabase* self)
{
	ObjectsPlaylist* result = NULL;
	gchar* new_title = NULL;
	gchar* _tmp0_;
	gchar* next_title = NULL;
	const gchar* _tmp1_;
	gchar* _tmp2_;
	ObjectsPlaylist* playlist = NULL;
	const gchar* _tmp3_;
	ObjectsPlaylist* _tmp4_;
	GDateTime* _tmp13_;
	GDateTime* _tmp14_;
	gchar* _tmp15_;
	gchar* _tmp16_;
	GDateTime* _tmp17_;
	GDateTime* _tmp18_;
	gchar* _tmp19_;
	gchar* _tmp20_;
	ObjectsPlaylist* _tmp21_;
	ObjectsPlaylist* _tmp22_;
	const gchar* _tmp23_;
	gchar* _tmp24_;
	ObjectsPlaylist* _tmp25_;
	ObjectsPlaylist* _tmp26_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = g_strdup (_ ("New Playlist"));
	new_title = _tmp0_;
	_tmp1_ = new_title;
	_tmp2_ = g_strdup (_tmp1_);
	next_title = _tmp2_;
	_tmp3_ = next_title;
	_tmp4_ = services_database_get_playlist_by_title (self, _tmp3_);
	playlist = _tmp4_;
	{
		gint i = 0;
		i = 1;
		{
			gboolean _tmp5_ = FALSE;
			_tmp5_ = TRUE;
			while (TRUE) {
				ObjectsPlaylist* _tmp7_;
				const gchar* _tmp8_;
				gint _tmp9_;
				gchar* _tmp10_;
				const gchar* _tmp11_;
				ObjectsPlaylist* _tmp12_;
				if (!_tmp5_) {
					gint _tmp6_;
					_tmp6_ = i;
					i = _tmp6_ + 1;
				}
				_tmp5_ = FALSE;
				_tmp7_ = playlist;
				if (!(_tmp7_ != NULL)) {
					break;
				}
				_tmp8_ = new_title;
				_tmp9_ = i;
				_tmp10_ = g_strdup_printf ("%s (%d)", _tmp8_, _tmp9_);
				_g_free0 (next_title);
				next_title = _tmp10_;
				_tmp11_ = next_title;
				_tmp12_ = services_database_get_playlist_by_title (self, _tmp11_);
				_g_object_unref0 (playlist);
				playlist = _tmp12_;
			}
		}
	}
	_tmp13_ = g_date_time_new_now_local ();
	_tmp14_ = _tmp13_;
	_tmp15_ = g_date_time_to_string (_tmp14_);
	_tmp16_ = _tmp15_;
	_tmp17_ = g_date_time_new_now_local ();
	_tmp18_ = _tmp17_;
	_tmp19_ = g_date_time_to_string (_tmp18_);
	_tmp20_ = _tmp19_;
	_tmp21_ = objects_playlist_new (0, "", "", _tmp16_, _tmp20_, 0);
	_g_object_unref0 (playlist);
	playlist = _tmp21_;
	_g_free0 (_tmp20_);
	_g_date_time_unref0 (_tmp18_);
	_g_free0 (_tmp16_);
	_g_date_time_unref0 (_tmp14_);
	_tmp22_ = playlist;
	_tmp23_ = next_title;
	_tmp24_ = g_strdup (_tmp23_);
	_g_free0 (_tmp22_->title);
	_tmp22_->title = _tmp24_;
	_tmp25_ = playlist;
	_tmp26_ = playlist;
	_tmp25_->id = services_database_insert_playlist (self, _tmp26_);
	result = playlist;
	_g_free0 (next_title);
	_g_free0 (new_title);
	return result;
}


static void
g_cclosure_user_marshal_VOID__OBJECT_INT (GClosure * closure,
                                          GValue * return_value,
                                          guint n_param_values,
                                          const GValue * param_values,
                                          gpointer invocation_hint,
                                          gpointer marshal_data)
{
	typedef void (*GMarshalFunc_VOID__OBJECT_INT) (gpointer data1, gpointer arg_1, gint arg_2, gpointer data2);
	register GMarshalFunc_VOID__OBJECT_INT callback;
	register GCClosure * cc;
	register gpointer data1;
	register gpointer data2;
	cc = (GCClosure *) closure;
	g_return_if_fail (n_param_values == 3);
	if (G_CCLOSURE_SWAP_DATA (closure)) {
		data1 = closure->data;
		data2 = param_values->data[0].v_pointer;
	} else {
		data1 = param_values->data[0].v_pointer;
		data2 = closure->data;
	}
	callback = (GMarshalFunc_VOID__OBJECT_INT) (marshal_data ? marshal_data : cc->callback);
	callback (data1, g_value_get_object (param_values + 1), g_value_get_int (param_values + 2), data2);
}


static void
services_database_class_init (ServicesDatabaseClass * klass)
{
	services_database_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (ServicesDatabasePrivate));
	G_OBJECT_CLASS (klass)->finalize = services_database_finalize;
	services_database_signals[SERVICES_DATABASE_ADDEN_NEW_TRACK_SIGNAL] = g_signal_new ("adden-new-track", SERVICES_TYPE_DATABASE, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__OBJECT, G_TYPE_NONE, 1, OBJECTS_TYPE_TRACK);
	services_database_signals[SERVICES_DATABASE_ADDED_NEW_ARTIST_SIGNAL] = g_signal_new ("added-new-artist", SERVICES_TYPE_DATABASE, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__OBJECT, G_TYPE_NONE, 1, OBJECTS_TYPE_ARTIST);
	services_database_signals[SERVICES_DATABASE_ADDED_NEW_ALBUM_SIGNAL] = g_signal_new ("added-new-album", SERVICES_TYPE_DATABASE, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__OBJECT, G_TYPE_NONE, 1, OBJECTS_TYPE_ALBUM);
	services_database_signals[SERVICES_DATABASE_ADDEN_NEW_RADIO_SIGNAL] = g_signal_new ("adden-new-radio", SERVICES_TYPE_DATABASE, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__OBJECT, G_TYPE_NONE, 1, OBJECTS_TYPE_RADIO);
	services_database_signals[SERVICES_DATABASE_ADDEN_NEW_PLAYLIST_SIGNAL] = g_signal_new ("adden-new-playlist", SERVICES_TYPE_DATABASE, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__OBJECT, G_TYPE_NONE, 1, OBJECTS_TYPE_PLAYLIST);
	services_database_signals[SERVICES_DATABASE_REMOVED_TRACK_SIGNAL] = g_signal_new ("removed-track", SERVICES_TYPE_DATABASE, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__INT, G_TYPE_NONE, 1, G_TYPE_INT);
	services_database_signals[SERVICES_DATABASE_REMOVED_PLAYLIST_SIGNAL] = g_signal_new ("removed-playlist", SERVICES_TYPE_DATABASE, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__INT, G_TYPE_NONE, 1, G_TYPE_INT);
	services_database_signals[SERVICES_DATABASE_UPDATED_ALBUM_COVER_SIGNAL] = g_signal_new ("updated-album-cover", SERVICES_TYPE_DATABASE, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__INT, G_TYPE_NONE, 1, G_TYPE_INT);
	services_database_signals[SERVICES_DATABASE_UPDATED_TRACK_COVER_SIGNAL] = g_signal_new ("updated-track-cover", SERVICES_TYPE_DATABASE, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__INT, G_TYPE_NONE, 1, G_TYPE_INT);
	services_database_signals[SERVICES_DATABASE_UPDATED_PLAYLIST_COVER_SIGNAL] = g_signal_new ("updated-playlist-cover", SERVICES_TYPE_DATABASE, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__INT, G_TYPE_NONE, 1, G_TYPE_INT);
	services_database_signals[SERVICES_DATABASE_UPDATED_TRACK_FAVORITE_SIGNAL] = g_signal_new ("updated-track-favorite", SERVICES_TYPE_DATABASE, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_user_marshal_VOID__OBJECT_INT, G_TYPE_NONE, 2, OBJECTS_TYPE_TRACK, G_TYPE_INT);
	services_database_signals[SERVICES_DATABASE_UPDATED_PLAYLIST_SIGNAL] = g_signal_new ("updated-playlist", SERVICES_TYPE_DATABASE, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__OBJECT, G_TYPE_NONE, 1, OBJECTS_TYPE_PLAYLIST);
	services_database_signals[SERVICES_DATABASE_RESET_LIBRARY_SIGNAL] = g_signal_new ("reset-library", SERVICES_TYPE_DATABASE, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0);
}


static void
services_database_instance_init (ServicesDatabase * self)
{
	self->priv = SERVICES_DATABASE_GET_PRIVATE (self);
}


static void
services_database_finalize (GObject * obj)
{
	ServicesDatabase * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, SERVICES_TYPE_DATABASE, ServicesDatabase);
	_sqlite3_close0 (self->priv->db);
	_g_free0 (self->priv->db_path);
	G_OBJECT_CLASS (services_database_parent_class)->finalize (obj);
}


GType
services_database_get_type (void)
{
	static volatile gsize services_database_type_id__volatile = 0;
	if (g_once_init_enter (&services_database_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (ServicesDatabaseClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) services_database_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (ServicesDatabase), 0, (GInstanceInitFunc) services_database_instance_init, NULL };
		GType services_database_type_id;
		services_database_type_id = g_type_register_static (G_TYPE_OBJECT, "ServicesDatabase", &g_define_type_info, 0);
		g_once_init_leave (&services_database_type_id__volatile, services_database_type_id);
	}
	return services_database_type_id__volatile;
}



