/* Utils.c generated by valac 0.40.11, the Vala compiler
 * generated from Utils.vala, do not modify */



#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <gee.h>
#include <gio/gio.h>
#include <glib/gstdio.h>
#include <granite.h>
#include <gtk/gtk.h>
#include <glib/gi18n-lib.h>
#include <gdk-pixbuf/gdk-pixbuf.h>
#include <gdk/gdk.h>


#define TYPE_UTILS (utils_get_type ())
#define UTILS(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_UTILS, Utils))
#define UTILS_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_UTILS, UtilsClass))
#define IS_UTILS(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_UTILS))
#define IS_UTILS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_UTILS))
#define UTILS_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_UTILS, UtilsClass))

typedef struct _Utils Utils;
typedef struct _UtilsClass UtilsClass;
typedef struct _UtilsPrivate UtilsPrivate;

#define OBJECTS_TYPE_TRACK (objects_track_get_type ())
#define OBJECTS_TRACK(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), OBJECTS_TYPE_TRACK, ObjectsTrack))
#define OBJECTS_TRACK_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), OBJECTS_TYPE_TRACK, ObjectsTrackClass))
#define OBJECTS_IS_TRACK(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), OBJECTS_TYPE_TRACK))
#define OBJECTS_IS_TRACK_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), OBJECTS_TYPE_TRACK))
#define OBJECTS_TRACK_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), OBJECTS_TYPE_TRACK, ObjectsTrackClass))

typedef struct _ObjectsTrack ObjectsTrack;
typedef struct _ObjectsTrackClass ObjectsTrackClass;
enum  {
	UTILS_0_PROPERTY,
	UTILS_QUEUE_PLAYLIST_PROPERTY,
	UTILS_NUM_PROPERTIES
};
static GParamSpec* utils_properties[UTILS_NUM_PROPERTIES];
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))
typedef struct _ObjectsTrackPrivate ObjectsTrackPrivate;

#define SERVICES_TYPE_PLAYER (services_player_get_type ())
#define SERVICES_PLAYER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SERVICES_TYPE_PLAYER, ServicesPlayer))
#define SERVICES_PLAYER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SERVICES_TYPE_PLAYER, ServicesPlayerClass))
#define SERVICES_IS_PLAYER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SERVICES_TYPE_PLAYER))
#define SERVICES_IS_PLAYER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SERVICES_TYPE_PLAYER))
#define SERVICES_PLAYER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SERVICES_TYPE_PLAYER, ServicesPlayerClass))

typedef struct _ServicesPlayer ServicesPlayer;
typedef struct _ServicesPlayerClass ServicesPlayerClass;
typedef struct _Block1Data Block1Data;
#define _g_main_loop_unref0(var) ((var == NULL) ? NULL : (var = (g_main_loop_unref (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
#define _g_date_time_unref0(var) ((var == NULL) ? NULL : (var = (g_date_time_unref (var), NULL)))
#define _g_time_zone_unref0(var) ((var == NULL) ? NULL : (var = (g_time_zone_unref (var), NULL)))
typedef struct _Block2Data Block2Data;

#define TYPE_BYTE (byte_get_type ())
#define BYTE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_BYTE, Byte))
#define BYTE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_BYTE, ByteClass))
#define IS_BYTE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_BYTE))
#define IS_BYTE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_BYTE))
#define BYTE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_BYTE, ByteClass))

typedef struct _Byte Byte;
typedef struct _ByteClass ByteClass;
typedef struct _BytePrivate BytePrivate;

#define TYPE_MAIN_WINDOW (main_window_get_type ())
#define MAIN_WINDOW(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_MAIN_WINDOW, MainWindow))
#define MAIN_WINDOW_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_MAIN_WINDOW, MainWindowClass))
#define IS_MAIN_WINDOW(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_MAIN_WINDOW))
#define IS_MAIN_WINDOW_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_MAIN_WINDOW))
#define MAIN_WINDOW_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_MAIN_WINDOW, MainWindowClass))

typedef struct _MainWindow MainWindow;
typedef struct _MainWindowClass MainWindowClass;
enum  {
	UTILS_PLAY_ITEMS_SIGNAL,
	UTILS_UPDATE_NEXT_TRACK_SIGNAL,
	UTILS_ADD_NEXT_TRACK_SIGNAL,
	UTILS_ADD_LAST_TRACK_SIGNAL,
	UTILS_RADIO_IMAGE_DOWNLOADED_SIGNAL,
	UTILS_NUM_SIGNALS
};
static guint utils_signals[UTILS_NUM_SIGNALS] = {0};

struct _Utils {
	GObject parent_instance;
	UtilsPrivate * priv;
	gchar* MAIN_FOLDER;
	gchar* COVER_FOLDER;
};

struct _UtilsClass {
	GObjectClass parent_class;
};

struct _UtilsPrivate {
	GeeArrayList* _queue_playlist;
	gboolean dark_mode;
	gchar* colorPrimary;
	gchar* colorAccent;
	gchar* textColorPrimary;
};

struct _ObjectsTrack {
	GObject parent_instance;
	ObjectsTrackPrivate * priv;
	gint track_order;
	gint id;
	gint album_id;
	gint track;
	gint disc;
	gint play_count;
	gint is_favorite;
	gint bitrate;
	gint bpm;
	gint rating;
	gint samplerate;
	gint channels;
	gint year;
	gint playlist;
	guint64 duration;
	gchar* path;
	gchar* title;
	gchar* favorite_added;
	gchar* last_played;
	gchar* album_title;
	gchar* artist_name;
	gchar* composer;
	gchar* grouping;
	gchar* comment;
	gchar* lyrics;
	gchar* genre;
	gchar* album_artist;
	gchar* date_added;
};

struct _ObjectsTrackClass {
	GObjectClass parent_class;
};

struct _Block1Data {
	int _ref_count_;
	Utils* self;
	GFile* file_from_uri;
	GMainLoop* loop;
	gchar* type;
	gint id;
	gchar* url;
};

struct _Block2Data {
	int _ref_count_;
	Utils* self;
	GtkFileChooserDialog* chooser;
	GtkImage* preview_area;
};

struct _Byte {
	GtkApplication parent_instance;
	BytePrivate * priv;
	MainWindow* main_window;
	gchar** argsv;
	gint argsv_length1;
	gboolean has_entry_focus;
	GSimpleAction* toggle_playing_action;
};

struct _ByteClass {
	GtkApplicationClass parent_class;
};


static gpointer utils_parent_class = NULL;
extern GSettings* byte_settings;
extern ServicesPlayer* byte_player;
extern Utils* byte_utils;

GType utils_get_type (void) G_GNUC_CONST;
GType objects_track_get_type (void) G_GNUC_CONST;
#define UTILS_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_UTILS, UtilsPrivate))
Utils* utils_new (void);
Utils* utils_construct (GType object_type);
void utils_set_items (Utils* self,
                      GeeArrayList* all_items,
                      gboolean shuffle_mode,
                      ObjectsTrack* track);
GeeArrayList* utils_generate_shuffle (Utils* self,
                                      GeeArrayList* items);
void utils_set_queue_playlist (Utils* self,
                               GeeArrayList* value);
gint utils_get_track_index_by_id (Utils* self,
                                  gint id,
                                  GeeArrayList* queue_playlist);
GeeArrayList* utils_get_queue_playlist (Utils* self);
GeeArrayList* utils_playlist_order (Utils* self,
                                    GeeArrayList* items);
void utils_shuffle_changed (Utils* self,
                            gboolean shuffle_mode);
GType services_player_get_type (void) G_GNUC_CONST;
ObjectsTrack* services_player_get_current_track (ServicesPlayer* self);
static gboolean utils_track_exists (Utils* self,
                             gint id,
                             GeeArrayList* queue_playlist);
ObjectsTrack* utils_get_next_track (Utils* self,
                                    ObjectsTrack* current_track);
ObjectsTrack* utils_get_prev_track (Utils* self,
                                    ObjectsTrack* current_track);
void utils_remove_track (Utils* self,
                         gint id);
void utils_set_next_track (Utils* self,
                           ObjectsTrack* track);
void utils_set_last_track (Utils* self,
                           ObjectsTrack* track);
void utils_download_image (Utils* self,
                           const gchar* type,
                           gint id,
                           const gchar* url);
static Block1Data* block1_data_ref (Block1Data* _data1_);
static void block1_data_unref (void * _userdata_);
static void __lambda4_ (Utils* self,
                 gint64 current_num_bytes,
                 gint64 total_num_bytes);
static void ___lambda4__gfile_progress_callback (gint64 current_num_bytes,
                                          gint64 total_num_bytes,
                                          gpointer self);
static void __lambda5_ (Block1Data* _data1_,
                 GObject* obj,
                 GAsyncResult* res);
static void ___lambda5__gasync_ready_callback (GObject* source_object,
                                        GAsyncResult* res,
                                        gpointer self);
void utils_create_dir_with_parents (Utils* self,
                                    const gchar* dir);
gchar* utils_get_formated_duration (Utils* self,
                                    guint64 duration);
gchar* utils_get_relative_datetime (Utils* self,
                                    const gchar* date);
gchar* utils_get_relative_duration (Utils* self,
                                    guint64 duration);
gchar* utils_get_cover_file (Utils* self,
                             gint track_id);
gchar* utils_get_cover_radio_file (Utils* self,
                                   gint radio_id);
gchar* utils_choose_new_cover (Utils* self);
static Block2Data* block2_data_ref (Block2Data* _data2_);
static void block2_data_unref (void * _userdata_);
GType byte_get_type (void) G_GNUC_CONST;
Byte* byte_get_instance (void);
GType main_window_get_type (void) G_GNUC_CONST;
static void __lambda6_ (Block2Data* _data2_);
static void ___lambda6__gtk_file_chooser_update_preview (GtkFileChooser* _sender,
                                                  gpointer self);
GdkPixbuf* utils_align_and_scale_pixbuf (Utils* self,
                                         GdkPixbuf* p,
                                         gint size);
void utils_apply_theme (Utils* self,
                        gint id);
static void g_cclosure_user_marshal_VOID__OBJECT_OBJECT (GClosure * closure,
                                                  GValue * return_value,
                                                  guint n_param_values,
                                                  const GValue * param_values,
                                                  gpointer invocation_hint,
                                                  gpointer marshal_data);
static void utils_finalize (GObject * obj);
static void _vala_utils_get_property (GObject * object,
                               guint property_id,
                               GValue * value,
                               GParamSpec * pspec);
static void _vala_utils_set_property (GObject * object,
                               guint property_id,
                               const GValue * value,
                               GParamSpec * pspec);


Utils*
utils_construct (GType object_type)
{
	Utils * self = NULL;
	const gchar* _tmp0_;
	gchar* _tmp1_;
	const gchar* _tmp2_;
	gchar* _tmp3_;
	self = (Utils*) g_object_new (object_type, NULL);
	_tmp0_ = g_get_home_dir ();
	_tmp1_ = g_strconcat (_tmp0_, "/.local/share/com.github.alainm23.byte", NULL);
	_g_free0 (self->MAIN_FOLDER);
	self->MAIN_FOLDER = _tmp1_;
	_tmp2_ = self->MAIN_FOLDER;
	_tmp3_ = g_build_filename (_tmp2_, "covers", NULL);
	_g_free0 (self->COVER_FOLDER);
	self->COVER_FOLDER = _tmp3_;
	return self;
}


Utils*
utils_new (void)
{
	return utils_construct (TYPE_UTILS);
}


void
utils_set_items (Utils* self,
                 GeeArrayList* all_items,
                 gboolean shuffle_mode,
                 ObjectsTrack* track)
{
	gint _tmp0_;
	gint _tmp1_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (all_items != NULL);
	_tmp0_ = gee_abstract_collection_get_size ((GeeAbstractCollection*) all_items);
	_tmp1_ = _tmp0_;
	if (_tmp1_ > 0) {
		GeeArrayList* _tmp15_;
		if (shuffle_mode) {
			GeeArrayList* _tmp2_;
			GeeArrayList* _tmp3_;
			GSettings* _tmp11_;
			_tmp2_ = utils_generate_shuffle (self, all_items);
			_tmp3_ = _tmp2_;
			utils_set_queue_playlist (self, _tmp3_);
			_g_object_unref0 (_tmp3_);
			if (track != NULL) {
				gint index = 0;
				gint _tmp4_;
				GeeArrayList* _tmp5_;
				GeeArrayList* _tmp6_;
				gint _tmp7_;
				gpointer _tmp8_;
				ObjectsTrack* _tmp9_;
				GeeArrayList* _tmp10_;
				_tmp4_ = track->id;
				_tmp5_ = self->priv->_queue_playlist;
				index = utils_get_track_index_by_id (self, _tmp4_, _tmp5_);
				_tmp6_ = self->priv->_queue_playlist;
				_tmp7_ = index;
				_tmp8_ = gee_abstract_list_remove_at ((GeeAbstractList*) _tmp6_, _tmp7_);
				_tmp9_ = (ObjectsTrack*) _tmp8_;
				_g_object_unref0 (_tmp9_);
				_tmp10_ = self->priv->_queue_playlist;
				gee_abstract_list_insert ((GeeAbstractList*) _tmp10_, 0, track);
			}
			_tmp11_ = byte_settings;
			g_settings_set_boolean (_tmp11_, "shuffle-mode", TRUE);
		} else {
			GeeArrayList* _tmp12_;
			GeeArrayList* _tmp13_;
			GSettings* _tmp14_;
			_tmp12_ = utils_playlist_order (self, all_items);
			_tmp13_ = _tmp12_;
			utils_set_queue_playlist (self, _tmp13_);
			_g_object_unref0 (_tmp13_);
			_tmp14_ = byte_settings;
			g_settings_set_boolean (_tmp14_, "shuffle-mode", FALSE);
		}
		_tmp15_ = self->priv->_queue_playlist;
		g_signal_emit (self, utils_signals[UTILS_PLAY_ITEMS_SIGNAL], 0, _tmp15_, track);
	}
}


void
utils_shuffle_changed (Utils* self,
                       gboolean shuffle_mode)
{
	GeeArrayList* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->_queue_playlist;
	if (_tmp0_ != NULL) {
		GeeArrayList* _tmp23_;
		ServicesPlayer* _tmp24_;
		ObjectsTrack* _tmp25_;
		ObjectsTrack* _tmp26_;
		if (shuffle_mode) {
			GeeArrayList* _tmp1_;
			GeeArrayList* _tmp2_;
			GeeArrayList* _tmp3_;
			ServicesPlayer* _tmp4_;
			ObjectsTrack* _tmp5_;
			ObjectsTrack* _tmp6_;
			_tmp1_ = self->priv->_queue_playlist;
			_tmp2_ = utils_generate_shuffle (self, _tmp1_);
			_tmp3_ = _tmp2_;
			utils_set_queue_playlist (self, _tmp3_);
			_g_object_unref0 (_tmp3_);
			_tmp4_ = byte_player;
			_tmp5_ = services_player_get_current_track (_tmp4_);
			_tmp6_ = _tmp5_;
			if (_tmp6_ != NULL) {
				gint index = 0;
				ServicesPlayer* _tmp7_;
				ObjectsTrack* _tmp8_;
				ObjectsTrack* _tmp9_;
				gint _tmp10_;
				GeeArrayList* _tmp11_;
				GeeArrayList* _tmp12_;
				gint _tmp13_;
				gpointer _tmp14_;
				ObjectsTrack* _tmp15_;
				GeeArrayList* _tmp16_;
				ServicesPlayer* _tmp17_;
				ObjectsTrack* _tmp18_;
				ObjectsTrack* _tmp19_;
				_tmp7_ = byte_player;
				_tmp8_ = services_player_get_current_track (_tmp7_);
				_tmp9_ = _tmp8_;
				_tmp10_ = _tmp9_->id;
				_tmp11_ = self->priv->_queue_playlist;
				index = utils_get_track_index_by_id (self, _tmp10_, _tmp11_);
				_tmp12_ = self->priv->_queue_playlist;
				_tmp13_ = index;
				_tmp14_ = gee_abstract_list_remove_at ((GeeAbstractList*) _tmp12_, _tmp13_);
				_tmp15_ = (ObjectsTrack*) _tmp14_;
				_g_object_unref0 (_tmp15_);
				_tmp16_ = self->priv->_queue_playlist;
				_tmp17_ = byte_player;
				_tmp18_ = services_player_get_current_track (_tmp17_);
				_tmp19_ = _tmp18_;
				gee_abstract_list_insert ((GeeAbstractList*) _tmp16_, 0, _tmp19_);
			}
		} else {
			GeeArrayList* _tmp20_;
			GeeArrayList* _tmp21_;
			GeeArrayList* _tmp22_;
			_tmp20_ = self->priv->_queue_playlist;
			_tmp21_ = utils_playlist_order (self, _tmp20_);
			_tmp22_ = _tmp21_;
			utils_set_queue_playlist (self, _tmp22_);
			_g_object_unref0 (_tmp22_);
		}
		_tmp23_ = self->priv->_queue_playlist;
		_tmp24_ = byte_player;
		_tmp25_ = services_player_get_current_track (_tmp24_);
		_tmp26_ = _tmp25_;
		g_signal_emit (self, utils_signals[UTILS_PLAY_ITEMS_SIGNAL], 0, _tmp23_, _tmp26_);
		g_signal_emit (self, utils_signals[UTILS_UPDATE_NEXT_TRACK_SIGNAL], 0);
	}
}


static gpointer
_g_object_ref0 (gpointer self)
{
	return self ? g_object_ref (self) : NULL;
}


gint
utils_get_track_index_by_id (Utils* self,
                             gint id,
                             GeeArrayList* queue_playlist)
{
	gint result = 0;
	gint index = 0;
	g_return_val_if_fail (self != NULL, 0);
	g_return_val_if_fail (queue_playlist != NULL, 0);
	index = 0;
	{
		GeeArrayList* _item_list = NULL;
		GeeArrayList* _tmp0_;
		gint _item_size = 0;
		GeeArrayList* _tmp1_;
		gint _tmp2_;
		gint _tmp3_;
		gint _item_index = 0;
		_tmp0_ = _g_object_ref0 (queue_playlist);
		_item_list = _tmp0_;
		_tmp1_ = _item_list;
		_tmp2_ = gee_abstract_collection_get_size ((GeeAbstractCollection*) _tmp1_);
		_tmp3_ = _tmp2_;
		_item_size = _tmp3_;
		_item_index = -1;
		while (TRUE) {
			gint _tmp4_;
			gint _tmp5_;
			gint _tmp6_;
			ObjectsTrack* item = NULL;
			GeeArrayList* _tmp7_;
			gint _tmp8_;
			gpointer _tmp9_;
			ObjectsTrack* _tmp10_;
			gint _tmp11_;
			gint _tmp12_;
			_tmp4_ = _item_index;
			_item_index = _tmp4_ + 1;
			_tmp5_ = _item_index;
			_tmp6_ = _item_size;
			if (!(_tmp5_ < _tmp6_)) {
				break;
			}
			_tmp7_ = _item_list;
			_tmp8_ = _item_index;
			_tmp9_ = gee_abstract_list_get ((GeeAbstractList*) _tmp7_, _tmp8_);
			item = (ObjectsTrack*) _tmp9_;
			_tmp10_ = item;
			_tmp11_ = _tmp10_->id;
			if (_tmp11_ == id) {
				result = index;
				_g_object_unref0 (item);
				_g_object_unref0 (_item_list);
				return result;
			}
			_tmp12_ = index;
			index = _tmp12_ + 1;
			_g_object_unref0 (item);
		}
		_g_object_unref0 (_item_list);
	}
	result = index;
	return result;
}


static gboolean
utils_track_exists (Utils* self,
                    gint id,
                    GeeArrayList* queue_playlist)
{
	gboolean result = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (queue_playlist != NULL, FALSE);
	{
		GeeArrayList* _item_list = NULL;
		GeeArrayList* _tmp0_;
		gint _item_size = 0;
		GeeArrayList* _tmp1_;
		gint _tmp2_;
		gint _tmp3_;
		gint _item_index = 0;
		_tmp0_ = _g_object_ref0 (queue_playlist);
		_item_list = _tmp0_;
		_tmp1_ = _item_list;
		_tmp2_ = gee_abstract_collection_get_size ((GeeAbstractCollection*) _tmp1_);
		_tmp3_ = _tmp2_;
		_item_size = _tmp3_;
		_item_index = -1;
		while (TRUE) {
			gint _tmp4_;
			gint _tmp5_;
			gint _tmp6_;
			ObjectsTrack* item = NULL;
			GeeArrayList* _tmp7_;
			gint _tmp8_;
			gpointer _tmp9_;
			ObjectsTrack* _tmp10_;
			gint _tmp11_;
			_tmp4_ = _item_index;
			_item_index = _tmp4_ + 1;
			_tmp5_ = _item_index;
			_tmp6_ = _item_size;
			if (!(_tmp5_ < _tmp6_)) {
				break;
			}
			_tmp7_ = _item_list;
			_tmp8_ = _item_index;
			_tmp9_ = gee_abstract_list_get ((GeeAbstractList*) _tmp7_, _tmp8_);
			item = (ObjectsTrack*) _tmp9_;
			_tmp10_ = item;
			_tmp11_ = _tmp10_->id;
			if (_tmp11_ == id) {
				result = TRUE;
				_g_object_unref0 (item);
				_g_object_unref0 (_item_list);
				return result;
			}
			_g_object_unref0 (item);
		}
		_g_object_unref0 (_item_list);
	}
	result = FALSE;
	return result;
}


GeeArrayList*
utils_generate_shuffle (Utils* self,
                        GeeArrayList* items)
{
	GeeArrayList* result = NULL;
	GeeArrayList* _tmp14_;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (items != NULL, NULL);
	{
		gint i = 0;
		gint _tmp0_;
		gint _tmp1_;
		_tmp0_ = gee_abstract_collection_get_size ((GeeAbstractCollection*) items);
		_tmp1_ = _tmp0_;
		i = _tmp1_ - 1;
		{
			gboolean _tmp2_ = FALSE;
			_tmp2_ = TRUE;
			while (TRUE) {
				gint _tmp4_;
				gint random_index = 0;
				gint _tmp5_;
				ObjectsTrack* tmp_track = NULL;
				gint _tmp6_;
				gpointer _tmp7_;
				gint _tmp8_;
				gint _tmp9_;
				gpointer _tmp10_;
				ObjectsTrack* _tmp11_;
				gint _tmp12_;
				ObjectsTrack* _tmp13_;
				if (!_tmp2_) {
					gint _tmp3_;
					_tmp3_ = i;
					i = _tmp3_ - 1;
				}
				_tmp2_ = FALSE;
				_tmp4_ = i;
				if (!(_tmp4_ > 0)) {
					break;
				}
				_tmp5_ = i;
				random_index = (gint) g_random_int_range ((gint32) 0, (gint32) _tmp5_);
				_tmp6_ = random_index;
				_tmp7_ = gee_abstract_list_get ((GeeAbstractList*) items, _tmp6_);
				tmp_track = (ObjectsTrack*) _tmp7_;
				_tmp8_ = random_index;
				_tmp9_ = i;
				_tmp10_ = gee_abstract_list_get ((GeeAbstractList*) items, _tmp9_);
				_tmp11_ = (ObjectsTrack*) _tmp10_;
				gee_abstract_list_set ((GeeAbstractList*) items, _tmp8_, _tmp11_);
				_g_object_unref0 (_tmp11_);
				_tmp12_ = i;
				_tmp13_ = tmp_track;
				gee_abstract_list_set ((GeeAbstractList*) items, _tmp12_, _tmp13_);
				_g_object_unref0 (tmp_track);
			}
		}
	}
	_tmp14_ = _g_object_ref0 (items);
	result = _tmp14_;
	return result;
}


GeeArrayList*
utils_playlist_order (Utils* self,
                      GeeArrayList* items)
{
	GeeArrayList* result = NULL;
	GeeArrayList* _tmp27_;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (items != NULL, NULL);
	{
		gint j = 0;
		j = 0;
		{
			gboolean _tmp0_ = FALSE;
			_tmp0_ = TRUE;
			while (TRUE) {
				gint _tmp2_;
				gint _tmp3_;
				gint _tmp4_;
				if (!_tmp0_) {
					gint _tmp1_;
					_tmp1_ = j;
					j = _tmp1_ + 1;
				}
				_tmp0_ = FALSE;
				_tmp2_ = j;
				_tmp3_ = gee_abstract_collection_get_size ((GeeAbstractCollection*) items);
				_tmp4_ = _tmp3_;
				if (!(_tmp2_ < _tmp4_)) {
					break;
				}
				{
					gint i = 0;
					i = 0;
					{
						gboolean _tmp5_ = FALSE;
						_tmp5_ = TRUE;
						while (TRUE) {
							gint _tmp7_;
							gint _tmp8_;
							gint _tmp9_;
							gint _tmp10_;
							gpointer _tmp11_;
							ObjectsTrack* _tmp12_;
							gint _tmp13_;
							gint _tmp14_;
							gpointer _tmp15_;
							ObjectsTrack* _tmp16_;
							gint _tmp17_;
							gboolean _tmp18_;
							if (!_tmp5_) {
								gint _tmp6_;
								_tmp6_ = i;
								i = _tmp6_ + 1;
							}
							_tmp5_ = FALSE;
							_tmp7_ = i;
							_tmp8_ = gee_abstract_collection_get_size ((GeeAbstractCollection*) items);
							_tmp9_ = _tmp8_;
							if (!(_tmp7_ < (_tmp9_ - 1))) {
								break;
							}
							_tmp10_ = i;
							_tmp11_ = gee_abstract_list_get ((GeeAbstractList*) items, _tmp10_);
							_tmp12_ = (ObjectsTrack*) _tmp11_;
							_tmp13_ = _tmp12_->track_order;
							_tmp14_ = i;
							_tmp15_ = gee_abstract_list_get ((GeeAbstractList*) items, _tmp14_ + 1);
							_tmp16_ = (ObjectsTrack*) _tmp15_;
							_tmp17_ = _tmp16_->track_order;
							_tmp18_ = _tmp13_ > _tmp17_;
							_g_object_unref0 (_tmp16_);
							_g_object_unref0 (_tmp12_);
							if (_tmp18_) {
								ObjectsTrack* tmp_track = NULL;
								gint _tmp19_;
								gpointer _tmp20_;
								gint _tmp21_;
								gint _tmp22_;
								gpointer _tmp23_;
								ObjectsTrack* _tmp24_;
								gint _tmp25_;
								ObjectsTrack* _tmp26_;
								_tmp19_ = i;
								_tmp20_ = gee_abstract_list_get ((GeeAbstractList*) items, _tmp19_ + 1);
								tmp_track = (ObjectsTrack*) _tmp20_;
								_tmp21_ = i;
								_tmp22_ = i;
								_tmp23_ = gee_abstract_list_get ((GeeAbstractList*) items, _tmp22_);
								_tmp24_ = (ObjectsTrack*) _tmp23_;
								gee_abstract_list_set ((GeeAbstractList*) items, _tmp21_ + 1, _tmp24_);
								_g_object_unref0 (_tmp24_);
								_tmp25_ = i;
								_tmp26_ = tmp_track;
								gee_abstract_list_set ((GeeAbstractList*) items, _tmp25_, _tmp26_);
								_g_object_unref0 (tmp_track);
							}
						}
					}
				}
			}
		}
	}
	_tmp27_ = _g_object_ref0 (items);
	result = _tmp27_;
	return result;
}


ObjectsTrack*
utils_get_next_track (Utils* self,
                      ObjectsTrack* current_track)
{
	ObjectsTrack* result = NULL;
	gint index = 0;
	gint _tmp0_;
	GeeArrayList* _tmp1_;
	ObjectsTrack* returned = NULL;
	gint repeat_mode = 0;
	GSettings* _tmp2_;
	gint _tmp3_;
	GeeArrayList* _tmp4_;
	gint _tmp5_;
	gint _tmp6_;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (current_track != NULL, NULL);
	_tmp0_ = current_track->id;
	_tmp1_ = self->priv->_queue_playlist;
	index = utils_get_track_index_by_id (self, _tmp0_, _tmp1_) + 1;
	returned = NULL;
	_tmp2_ = byte_settings;
	repeat_mode = g_settings_get_enum (_tmp2_, "repeat-mode");
	_tmp3_ = index;
	_tmp4_ = self->priv->_queue_playlist;
	_tmp5_ = gee_abstract_collection_get_size ((GeeAbstractCollection*) _tmp4_);
	_tmp6_ = _tmp5_;
	if (_tmp3_ >= _tmp6_) {
		gint _tmp7_;
		_tmp7_ = repeat_mode;
		if (_tmp7_ == 0) {
			_g_object_unref0 (returned);
			returned = NULL;
		} else {
			gint _tmp8_;
			_tmp8_ = repeat_mode;
			if (_tmp8_ == 1) {
				GeeArrayList* _tmp9_;
				gpointer _tmp10_;
				_tmp9_ = self->priv->_queue_playlist;
				_tmp10_ = gee_abstract_list_get ((GeeAbstractList*) _tmp9_, 0);
				_g_object_unref0 (returned);
				returned = (ObjectsTrack*) _tmp10_;
			} else {
				_g_object_unref0 (returned);
				returned = NULL;
			}
		}
	} else {
		GeeArrayList* _tmp11_;
		gint _tmp12_;
		gpointer _tmp13_;
		_tmp11_ = self->priv->_queue_playlist;
		_tmp12_ = index;
		_tmp13_ = gee_abstract_list_get ((GeeAbstractList*) _tmp11_, _tmp12_);
		_g_object_unref0 (returned);
		returned = (ObjectsTrack*) _tmp13_;
	}
	result = returned;
	return result;
}


ObjectsTrack*
utils_get_prev_track (Utils* self,
                      ObjectsTrack* current_track)
{
	ObjectsTrack* result = NULL;
	gint index = 0;
	gint _tmp0_;
	GeeArrayList* _tmp1_;
	gint _tmp2_;
	GeeArrayList* _tmp3_;
	gint _tmp4_;
	gpointer _tmp5_;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (current_track != NULL, NULL);
	_tmp0_ = current_track->id;
	_tmp1_ = self->priv->_queue_playlist;
	index = utils_get_track_index_by_id (self, _tmp0_, _tmp1_) - 1;
	_tmp2_ = index;
	if (_tmp2_ < 0) {
		index = 0;
	}
	_tmp3_ = self->priv->_queue_playlist;
	_tmp4_ = index;
	_tmp5_ = gee_abstract_list_get ((GeeAbstractList*) _tmp3_, _tmp4_);
	result = (ObjectsTrack*) _tmp5_;
	return result;
}


void
utils_remove_track (Utils* self,
                    gint id)
{
	gint index = 0;
	GeeArrayList* _tmp0_;
	GeeArrayList* _tmp1_;
	gpointer _tmp2_;
	ObjectsTrack* _tmp3_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->_queue_playlist;
	index = utils_get_track_index_by_id (self, id, _tmp0_);
	_tmp1_ = self->priv->_queue_playlist;
	_tmp2_ = gee_abstract_list_remove_at ((GeeAbstractList*) _tmp1_, index);
	_tmp3_ = (ObjectsTrack*) _tmp2_;
	_g_object_unref0 (_tmp3_);
	g_signal_emit (self, utils_signals[UTILS_UPDATE_NEXT_TRACK_SIGNAL], 0);
}


void
utils_set_next_track (Utils* self,
                      ObjectsTrack* track)
{
	gint _tmp0_;
	ServicesPlayer* _tmp1_;
	ObjectsTrack* _tmp2_;
	ObjectsTrack* _tmp3_;
	gint _tmp4_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (track != NULL);
	_tmp0_ = track->id;
	_tmp1_ = byte_player;
	_tmp2_ = services_player_get_current_track (_tmp1_);
	_tmp3_ = _tmp2_;
	_tmp4_ = _tmp3_->id;
	if (_tmp0_ != _tmp4_) {
		gboolean track_exists = FALSE;
		gint _tmp5_;
		GeeArrayList* _tmp6_;
		gboolean _tmp7_;
		gint index = 0;
		ServicesPlayer* _tmp14_;
		ObjectsTrack* _tmp15_;
		ObjectsTrack* _tmp16_;
		gint _tmp17_;
		GeeArrayList* _tmp18_;
		gint _tmp19_;
		GeeArrayList* _tmp20_;
		gint _tmp21_;
		GeeArrayList* _tmp22_;
		_tmp5_ = track->id;
		_tmp6_ = self->priv->_queue_playlist;
		track_exists = utils_track_exists (self, _tmp5_, _tmp6_);
		_tmp7_ = track_exists;
		if (_tmp7_) {
			gint remove_index = 0;
			gint _tmp8_;
			GeeArrayList* _tmp9_;
			GeeArrayList* _tmp10_;
			gint _tmp11_;
			gpointer _tmp12_;
			ObjectsTrack* _tmp13_;
			_tmp8_ = track->id;
			_tmp9_ = self->priv->_queue_playlist;
			remove_index = utils_get_track_index_by_id (self, _tmp8_, _tmp9_);
			_tmp10_ = self->priv->_queue_playlist;
			_tmp11_ = remove_index;
			_tmp12_ = gee_abstract_list_remove_at ((GeeAbstractList*) _tmp10_, _tmp11_);
			_tmp13_ = (ObjectsTrack*) _tmp12_;
			_g_object_unref0 (_tmp13_);
		}
		_tmp14_ = byte_player;
		_tmp15_ = services_player_get_current_track (_tmp14_);
		_tmp16_ = _tmp15_;
		_tmp17_ = _tmp16_->id;
		_tmp18_ = self->priv->_queue_playlist;
		index = utils_get_track_index_by_id (self, _tmp17_, _tmp18_) + 1;
		_tmp19_ = index;
		track->track_order = _tmp19_;
		_tmp20_ = self->priv->_queue_playlist;
		_tmp21_ = index;
		gee_abstract_list_insert ((GeeAbstractList*) _tmp20_, _tmp21_, track);
		_tmp22_ = self->priv->_queue_playlist;
		g_signal_emit (self, utils_signals[UTILS_ADD_NEXT_TRACK_SIGNAL], 0, _tmp22_);
	}
}


void
utils_set_last_track (Utils* self,
                      ObjectsTrack* track)
{
	gint _tmp0_;
	ServicesPlayer* _tmp1_;
	ObjectsTrack* _tmp2_;
	ObjectsTrack* _tmp3_;
	gint _tmp4_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (track != NULL);
	_tmp0_ = track->id;
	_tmp1_ = byte_player;
	_tmp2_ = services_player_get_current_track (_tmp1_);
	_tmp3_ = _tmp2_;
	_tmp4_ = _tmp3_->id;
	if (_tmp0_ != _tmp4_) {
		gboolean track_exists = FALSE;
		gint _tmp5_;
		GeeArrayList* _tmp6_;
		gboolean _tmp7_;
		GeeArrayList* _tmp14_;
		gint _tmp15_;
		gint _tmp16_;
		GeeArrayList* _tmp17_;
		GeeArrayList* _tmp18_;
		_tmp5_ = track->id;
		_tmp6_ = self->priv->_queue_playlist;
		track_exists = utils_track_exists (self, _tmp5_, _tmp6_);
		_tmp7_ = track_exists;
		if (_tmp7_) {
			gint remove_index = 0;
			gint _tmp8_;
			GeeArrayList* _tmp9_;
			GeeArrayList* _tmp10_;
			gint _tmp11_;
			gpointer _tmp12_;
			ObjectsTrack* _tmp13_;
			_tmp8_ = track->id;
			_tmp9_ = self->priv->_queue_playlist;
			remove_index = utils_get_track_index_by_id (self, _tmp8_, _tmp9_);
			_tmp10_ = self->priv->_queue_playlist;
			_tmp11_ = remove_index;
			_tmp12_ = gee_abstract_list_remove_at ((GeeAbstractList*) _tmp10_, _tmp11_);
			_tmp13_ = (ObjectsTrack*) _tmp12_;
			_g_object_unref0 (_tmp13_);
		}
		_tmp14_ = self->priv->_queue_playlist;
		_tmp15_ = gee_abstract_collection_get_size ((GeeAbstractCollection*) _tmp14_);
		_tmp16_ = _tmp15_;
		track->track_order = _tmp16_ + 1;
		_tmp17_ = self->priv->_queue_playlist;
		gee_abstract_collection_add ((GeeAbstractCollection*) _tmp17_, track);
		_tmp18_ = self->priv->_queue_playlist;
		g_signal_emit (self, utils_signals[UTILS_ADD_LAST_TRACK_SIGNAL], 0, _tmp18_);
	}
}


static Block1Data*
block1_data_ref (Block1Data* _data1_)
{
	g_atomic_int_inc (&_data1_->_ref_count_);
	return _data1_;
}


static void
block1_data_unref (void * _userdata_)
{
	Block1Data* _data1_;
	_data1_ = (Block1Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data1_->_ref_count_)) {
		Utils* self;
		self = _data1_->self;
		_g_main_loop_unref0 (_data1_->loop);
		_g_object_unref0 (_data1_->file_from_uri);
		_g_free0 (_data1_->type);
		_g_free0 (_data1_->url);
		_g_object_unref0 (self);
		g_slice_free (Block1Data, _data1_);
	}
}


static void
__lambda4_ (Utils* self,
            gint64 current_num_bytes,
            gint64 total_num_bytes)
{
	g_print ("%" G_GINT64_FORMAT " bytes of %" G_GINT64_FORMAT " bytes copied.\n", current_num_bytes, total_num_bytes);
}


static void
___lambda4__gfile_progress_callback (gint64 current_num_bytes,
                                     gint64 total_num_bytes,
                                     gpointer self)
{
	__lambda4_ ((Utils*) self, current_num_bytes, total_num_bytes);
}


static void
__lambda5_ (Block1Data* _data1_,
            GObject* obj,
            GAsyncResult* res)
{
	Utils* self;
	GError * _inner_error_ = NULL;
	self = _data1_->self;
	g_return_if_fail (res != NULL);
	{
		gboolean _tmp0_ = FALSE;
		_tmp0_ = g_file_copy_finish (_data1_->file_from_uri, res, &_inner_error_);
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			goto __catch3_g_error;
		}
		if (_tmp0_) {
			g_print ("Image Downloaded\n");
			if (g_strcmp0 (_data1_->type, "radio") == 0) {
				g_signal_emit (self, utils_signals[UTILS_RADIO_IMAGE_DOWNLOADED_SIGNAL], 0, _data1_->id);
			}
		}
	}
	goto __finally3;
	__catch3_g_error:
	{
		GError* e = NULL;
		GError* _tmp1_;
		const gchar* _tmp2_;
		e = _inner_error_;
		_inner_error_ = NULL;
		utils_download_image (self, _data1_->type, _data1_->id, _data1_->url);
		_tmp1_ = e;
		_tmp2_ = _tmp1_->message;
		g_print ("Error: %s\n", _tmp2_);
		_g_error_free0 (e);
	}
	__finally3:
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	g_main_loop_quit (_data1_->loop);
}


static void
___lambda5__gasync_ready_callback (GObject* source_object,
                                   GAsyncResult* res,
                                   gpointer self)
{
	__lambda5_ (self, source_object, res);
	block1_data_unref (self);
}


void
utils_download_image (Utils* self,
                      const gchar* type,
                      gint id,
                      const gchar* url)
{
	Block1Data* _data1_;
	gchar* _tmp0_;
	gchar* _tmp1_;
	gchar* image_path = NULL;
	Utils* _tmp2_;
	const gchar* _tmp3_;
	gchar* _tmp4_;
	gchar* _tmp5_;
	gchar* _tmp6_;
	gchar* _tmp7_;
	GFile* file_path = NULL;
	GFile* _tmp8_;
	GFile* _tmp9_;
	GMainLoop* _tmp10_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (type != NULL);
	g_return_if_fail (url != NULL);
	_data1_ = g_slice_new0 (Block1Data);
	_data1_->_ref_count_ = 1;
	_data1_->self = g_object_ref (self);
	_tmp0_ = g_strdup (type);
	_g_free0 (_data1_->type);
	_data1_->type = _tmp0_;
	_data1_->id = id;
	_tmp1_ = g_strdup (url);
	_g_free0 (_data1_->url);
	_data1_->url = _tmp1_;
	_tmp2_ = byte_utils;
	_tmp3_ = _tmp2_->COVER_FOLDER;
	_tmp4_ = g_strdup_printf ("%s-%i.jpg", _data1_->type, _data1_->id);
	_tmp5_ = _tmp4_;
	_tmp6_ = g_build_filename (_tmp3_, _tmp5_, NULL);
	_tmp7_ = _tmp6_;
	_g_free0 (_tmp5_);
	image_path = _tmp7_;
	_tmp8_ = g_file_new_for_path (image_path);
	file_path = _tmp8_;
	_tmp9_ = g_file_new_for_uri (_data1_->url);
	_data1_->file_from_uri = _tmp9_;
	_tmp10_ = g_main_loop_new (NULL, FALSE);
	_data1_->loop = _tmp10_;
	g_file_copy_async (_data1_->file_from_uri, file_path, 0, G_PRIORITY_DEFAULT, NULL, ___lambda4__gfile_progress_callback, self, ___lambda5__gasync_ready_callback, block1_data_ref (_data1_));
	g_main_loop_run (_data1_->loop);
	_g_object_unref0 (file_path);
	_g_free0 (image_path);
	block1_data_unref (_data1_);
	_data1_ = NULL;
}


void
utils_create_dir_with_parents (Utils* self,
                               const gchar* dir)
{
	gchar* path = NULL;
	const gchar* _tmp0_;
	gchar* _tmp1_;
	GFile* tmp = NULL;
	const gchar* _tmp2_;
	GFile* _tmp3_;
	GFile* _tmp4_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (dir != NULL);
	_tmp0_ = g_get_home_dir ();
	_tmp1_ = g_strconcat (_tmp0_, dir, NULL);
	path = _tmp1_;
	_tmp2_ = path;
	_tmp3_ = g_file_new_for_path (_tmp2_);
	tmp = _tmp3_;
	_tmp4_ = tmp;
	if (g_file_query_file_type (_tmp4_, 0, NULL) != G_FILE_TYPE_DIRECTORY) {
		const gchar* _tmp5_;
		_tmp5_ = path;
		g_mkdir_with_parents (_tmp5_, 0775);
	}
	_g_object_unref0 (tmp);
	_g_free0 (path);
}


gchar*
utils_get_formated_duration (Utils* self,
                             guint64 duration)
{
	gchar* result = NULL;
	guint seconds = 0U;
	guint _tmp0_;
	guint hours = 0U;
	guint _tmp7_;
	guint _tmp8_;
	guint _tmp9_;
	guint minutes = 0U;
	guint _tmp10_;
	guint _tmp11_;
	guint _tmp12_;
	guint _tmp13_;
	guint _tmp14_;
	guint _tmp15_;
	gchar* _tmp16_;
	g_return_val_if_fail (self != NULL, NULL);
	seconds = (guint) (duration / 1000000000);
	_tmp0_ = seconds;
	if (_tmp0_ < ((guint) 3600)) {
		guint minutes = 0U;
		guint _tmp1_;
		guint _tmp2_;
		guint _tmp3_;
		guint _tmp4_;
		guint _tmp5_;
		gchar* _tmp6_;
		_tmp1_ = seconds;
		minutes = _tmp1_ / 60;
		_tmp2_ = seconds;
		_tmp3_ = minutes;
		seconds = _tmp2_ - (_tmp3_ * 60);
		_tmp4_ = minutes;
		_tmp5_ = seconds;
		_tmp6_ = g_strdup_printf ("%u:%02u", _tmp4_, _tmp5_);
		result = _tmp6_;
		return result;
	}
	_tmp7_ = seconds;
	hours = _tmp7_ / 3600;
	_tmp8_ = seconds;
	_tmp9_ = hours;
	seconds = _tmp8_ - (_tmp9_ * 3600);
	_tmp10_ = seconds;
	minutes = _tmp10_ / 60;
	_tmp11_ = seconds;
	_tmp12_ = minutes;
	seconds = _tmp11_ - (_tmp12_ * 60);
	_tmp13_ = hours;
	_tmp14_ = minutes;
	_tmp15_ = seconds;
	_tmp16_ = g_strdup_printf ("%u:%02u:%02u", _tmp13_, _tmp14_, _tmp15_);
	result = _tmp16_;
	return result;
}


gchar*
utils_get_relative_datetime (Utils* self,
                             const gchar* date)
{
	gchar* result = NULL;
	GTimeZone* _tmp0_;
	GTimeZone* _tmp1_;
	GDateTime* _tmp2_;
	GDateTime* _tmp3_;
	gchar* _tmp4_;
	gchar* _tmp5_;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (date != NULL, NULL);
	_tmp0_ = g_time_zone_new_local ();
	_tmp1_ = _tmp0_;
	_tmp2_ = g_date_time_new_from_iso8601 (date, _tmp1_);
	_tmp3_ = _tmp2_;
	_tmp4_ = granite_date_time_get_relative_datetime (_tmp3_);
	_tmp5_ = _tmp4_;
	_g_date_time_unref0 (_tmp3_);
	_g_time_zone_unref0 (_tmp1_);
	result = _tmp5_;
	return result;
}


gchar*
utils_get_relative_duration (Utils* self,
                             guint64 duration)
{
	gchar* result = NULL;
	guint temp_sec = 0U;
	guint sec = 0U;
	guint _tmp0_;
	guint min = 0U;
	guint _tmp1_;
	guint hour = 0U;
	guint _tmp2_;
	guint day = 0U;
	guint _tmp3_;
	guint _tmp4_;
	g_return_val_if_fail (self != NULL, NULL);
	temp_sec = (guint) (duration / 1000000000);
	_tmp0_ = temp_sec;
	sec = ((guint) _tmp0_) % 60;
	_tmp1_ = temp_sec;
	min = (guint) ((_tmp1_ / 60) % 60);
	_tmp2_ = temp_sec;
	hour = (guint) ((_tmp2_ / (60 * 60)) % 24);
	_tmp3_ = temp_sec;
	day = (guint) ((_tmp3_ / ((24 * 60) * 60)) % 24);
	_tmp4_ = day;
	if (_tmp4_ > ((guint) 0)) {
		guint _tmp5_;
		guint _tmp6_;
		guint _tmp7_;
		guint _tmp8_;
		gchar* _tmp9_;
		_tmp5_ = day;
		_tmp6_ = hour;
		_tmp7_ = min;
		_tmp8_ = sec;
		_tmp9_ = g_strdup_printf ("%ud %uh %um %us", _tmp5_, _tmp6_, _tmp7_, _tmp8_);
		result = _tmp9_;
		return result;
	} else {
		guint _tmp10_;
		_tmp10_ = hour;
		if (_tmp10_ > ((guint) 0)) {
			guint _tmp11_;
			guint _tmp12_;
			guint _tmp13_;
			gchar* _tmp14_;
			_tmp11_ = hour;
			_tmp12_ = min;
			_tmp13_ = sec;
			_tmp14_ = g_strdup_printf ("%uh %um %us", _tmp11_, _tmp12_, _tmp13_);
			result = _tmp14_;
			return result;
		} else {
			guint _tmp15_;
			_tmp15_ = min;
			if (_tmp15_ > ((guint) 0)) {
				guint _tmp16_;
				guint _tmp17_;
				gchar* _tmp18_;
				_tmp16_ = min;
				_tmp17_ = sec;
				_tmp18_ = g_strdup_printf ("%um %us", _tmp16_, _tmp17_);
				result = _tmp18_;
				return result;
			} else {
				guint _tmp19_;
				_tmp19_ = sec;
				if (_tmp19_ > ((guint) 0)) {
					guint _tmp20_;
					gchar* _tmp21_;
					_tmp20_ = sec;
					_tmp21_ = g_strdup_printf ("%us", _tmp20_);
					result = _tmp21_;
					return result;
				} else {
					gchar* _tmp22_;
					_tmp22_ = g_strdup ("");
					result = _tmp22_;
					return result;
				}
			}
		}
	}
}


gchar*
utils_get_cover_file (Utils* self,
                      gint track_id)
{
	gchar* result = NULL;
	gchar* cover_path = NULL;
	Utils* _tmp0_;
	const gchar* _tmp1_;
	gchar* _tmp2_;
	gchar* _tmp3_;
	gchar* _tmp4_;
	gchar* _tmp5_;
	const gchar* _tmp6_;
	GFile* _tmp7_;
	GFile* _tmp8_;
	gboolean _tmp9_;
	gchar* _tmp12_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = byte_utils;
	_tmp1_ = _tmp0_->COVER_FOLDER;
	_tmp2_ = g_strdup_printf ("track-%i.jpg", track_id);
	_tmp3_ = _tmp2_;
	_tmp4_ = g_build_filename (_tmp1_, _tmp3_, NULL);
	_tmp5_ = _tmp4_;
	_g_free0 (_tmp3_);
	cover_path = _tmp5_;
	_tmp6_ = cover_path;
	_tmp7_ = g_file_new_for_path (_tmp6_);
	_tmp8_ = _tmp7_;
	_tmp9_ = g_file_query_exists (_tmp8_, NULL);
	_g_object_unref0 (_tmp8_);
	if (_tmp9_) {
		const gchar* _tmp10_;
		gchar* _tmp11_;
		_tmp10_ = cover_path;
		_tmp11_ = g_strconcat ("file://", _tmp10_, NULL);
		result = _tmp11_;
		_g_free0 (cover_path);
		return result;
	}
	_tmp12_ = g_strdup ("file:///usr/share/com.github.alainm23.byte/track-default-cover.svg");
	result = _tmp12_;
	_g_free0 (cover_path);
	return result;
}


gchar*
utils_get_cover_radio_file (Utils* self,
                            gint radio_id)
{
	gchar* result = NULL;
	gchar* cover_path = NULL;
	Utils* _tmp0_;
	const gchar* _tmp1_;
	gchar* _tmp2_;
	gchar* _tmp3_;
	gchar* _tmp4_;
	gchar* _tmp5_;
	const gchar* _tmp6_;
	GFile* _tmp7_;
	GFile* _tmp8_;
	gboolean _tmp9_;
	gchar* _tmp12_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = byte_utils;
	_tmp1_ = _tmp0_->COVER_FOLDER;
	_tmp2_ = g_strdup_printf ("radio-%i.jpg", radio_id);
	_tmp3_ = _tmp2_;
	_tmp4_ = g_build_filename (_tmp1_, _tmp3_, NULL);
	_tmp5_ = _tmp4_;
	_g_free0 (_tmp3_);
	cover_path = _tmp5_;
	_tmp6_ = cover_path;
	_tmp7_ = g_file_new_for_path (_tmp6_);
	_tmp8_ = _tmp7_;
	_tmp9_ = g_file_query_exists (_tmp8_, NULL);
	_g_object_unref0 (_tmp8_);
	if (_tmp9_) {
		const gchar* _tmp10_;
		gchar* _tmp11_;
		_tmp10_ = cover_path;
		_tmp11_ = g_strconcat ("file://", _tmp10_, NULL);
		result = _tmp11_;
		_g_free0 (cover_path);
		return result;
	}
	_tmp12_ = g_strdup ("file:///usr/share/com.github.alainm23.byte/radio-default-cover.svg");
	result = _tmp12_;
	_g_free0 (cover_path);
	return result;
}


static Block2Data*
block2_data_ref (Block2Data* _data2_)
{
	g_atomic_int_inc (&_data2_->_ref_count_);
	return _data2_;
}


static void
block2_data_unref (void * _userdata_)
{
	Block2Data* _data2_;
	_data2_ = (Block2Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data2_->_ref_count_)) {
		Utils* self;
		self = _data2_->self;
		_g_object_unref0 (_data2_->preview_area);
		_g_object_unref0 (_data2_->chooser);
		_g_object_unref0 (self);
		g_slice_free (Block2Data, _data2_);
	}
}


static void
__lambda6_ (Block2Data* _data2_)
{
	Utils* self;
	gchar* filename = NULL;
	GtkFileChooserDialog* _tmp0_;
	gchar* _tmp1_;
	const gchar* _tmp2_;
	GError * _inner_error_ = NULL;
	self = _data2_->self;
	_tmp0_ = _data2_->chooser;
	_tmp1_ = gtk_file_chooser_get_preview_filename ((GtkFileChooser*) _tmp0_);
	filename = _tmp1_;
	_tmp2_ = filename;
	if (_tmp2_ != NULL) {
		{
			GdkPixbuf* pixbuf = NULL;
			const gchar* _tmp3_;
			GdkPixbuf* _tmp4_;
			GtkImage* _tmp5_;
			GdkPixbuf* _tmp6_;
			GtkImage* _tmp7_;
			_tmp3_ = filename;
			_tmp4_ = gdk_pixbuf_new_from_file_at_scale (_tmp3_, 150, 150, TRUE, &_inner_error_);
			pixbuf = _tmp4_;
			if (G_UNLIKELY (_inner_error_ != NULL)) {
				goto __catch4_g_error;
			}
			_tmp5_ = _data2_->preview_area;
			_tmp6_ = pixbuf;
			gtk_image_set_from_pixbuf (_tmp5_, _tmp6_);
			_tmp7_ = _data2_->preview_area;
			gtk_widget_show ((GtkWidget*) _tmp7_);
			_g_object_unref0 (pixbuf);
		}
		goto __finally4;
		__catch4_g_error:
		{
			GError* e = NULL;
			GtkImage* _tmp8_;
			e = _inner_error_;
			_inner_error_ = NULL;
			_tmp8_ = _data2_->preview_area;
			gtk_widget_hide ((GtkWidget*) _tmp8_);
			_g_error_free0 (e);
		}
		__finally4:
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			_g_free0 (filename);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
	} else {
		GtkImage* _tmp9_;
		_tmp9_ = _data2_->preview_area;
		gtk_widget_hide ((GtkWidget*) _tmp9_);
	}
	_g_free0 (filename);
}


static void
___lambda6__gtk_file_chooser_update_preview (GtkFileChooser* _sender,
                                             gpointer self)
{
	__lambda6_ (self);
}


gchar*
utils_choose_new_cover (Utils* self)
{
	gchar* result = NULL;
	Block2Data* _data2_;
	gchar* return_value = NULL;
	Byte* _tmp0_;
	Byte* _tmp1_;
	MainWindow* _tmp2_;
	GtkFileChooserDialog* _tmp3_;
	GtkFileFilter* filter = NULL;
	GtkFileFilter* _tmp4_;
	GtkFileFilter* _tmp5_;
	GtkFileFilter* _tmp6_;
	GtkFileChooserDialog* _tmp7_;
	GtkFileFilter* _tmp8_;
	GtkFileFilter* _tmp9_;
	GtkImage* _tmp10_;
	GtkFileChooserDialog* _tmp11_;
	GtkImage* _tmp12_;
	GtkFileChooserDialog* _tmp13_;
	GtkFileChooserDialog* _tmp14_;
	GtkFileChooserDialog* _tmp15_;
	GtkFileChooserDialog* _tmp16_;
	GtkFileChooserDialog* _tmp19_;
	g_return_val_if_fail (self != NULL, NULL);
	_data2_ = g_slice_new0 (Block2Data);
	_data2_->_ref_count_ = 1;
	_data2_->self = g_object_ref (self);
	return_value = NULL;
	_tmp0_ = byte_get_instance ();
	_tmp1_ = _tmp0_;
	_tmp2_ = _tmp1_->main_window;
	_tmp3_ = (GtkFileChooserDialog*) gtk_file_chooser_dialog_new (_ ("Choose an image…"), (GtkWindow*) _tmp2_, GTK_FILE_CHOOSER_ACTION_OPEN, _ ("Cancel"), GTK_RESPONSE_CANCEL, _ ("Open"), GTK_RESPONSE_ACCEPT, NULL);
	g_object_ref_sink (_tmp3_);
	_data2_->chooser = _tmp3_;
	_tmp4_ = gtk_file_filter_new ();
	g_object_ref_sink (_tmp4_);
	filter = _tmp4_;
	_tmp5_ = filter;
	gtk_file_filter_set_name (_tmp5_, _ ("Images"));
	_tmp6_ = filter;
	gtk_file_filter_add_mime_type (_tmp6_, "image/*");
	_tmp7_ = _data2_->chooser;
	_tmp8_ = filter;
	_tmp9_ = _g_object_ref0 (_tmp8_);
	gtk_file_chooser_add_filter ((GtkFileChooser*) _tmp7_, _tmp9_);
	_tmp10_ = (GtkImage*) gtk_image_new ();
	g_object_ref_sink (_tmp10_);
	_data2_->preview_area = _tmp10_;
	_tmp11_ = _data2_->chooser;
	_tmp12_ = _data2_->preview_area;
	gtk_file_chooser_set_preview_widget ((GtkFileChooser*) _tmp11_, (GtkWidget*) _tmp12_);
	_tmp13_ = _data2_->chooser;
	gtk_file_chooser_set_use_preview_label ((GtkFileChooser*) _tmp13_, FALSE);
	_tmp14_ = _data2_->chooser;
	gtk_file_chooser_set_select_multiple ((GtkFileChooser*) _tmp14_, FALSE);
	_tmp15_ = _data2_->chooser;
	g_signal_connect_data ((GtkFileChooser*) _tmp15_, "update-preview", (GCallback) ___lambda6__gtk_file_chooser_update_preview, block2_data_ref (_data2_), (GClosureNotify) block2_data_unref, 0);
	_tmp16_ = _data2_->chooser;
	if (gtk_dialog_run ((GtkDialog*) _tmp16_) == ((gint) GTK_RESPONSE_ACCEPT)) {
		GtkFileChooserDialog* _tmp17_;
		gchar* _tmp18_;
		_tmp17_ = _data2_->chooser;
		_tmp18_ = gtk_file_chooser_get_filename ((GtkFileChooser*) _tmp17_);
		_g_free0 (return_value);
		return_value = _tmp18_;
	}
	_tmp19_ = _data2_->chooser;
	gtk_widget_destroy ((GtkWidget*) _tmp19_);
	result = return_value;
	_g_object_unref0 (filter);
	block2_data_unref (_data2_);
	_data2_ = NULL;
	return result;
}


GdkPixbuf*
utils_align_and_scale_pixbuf (Utils* self,
                              GdkPixbuf* p,
                              gint size)
{
	GdkPixbuf* result = NULL;
	GdkPixbuf* pixbuf = NULL;
	GdkPixbuf* _tmp0_;
	GdkPixbuf* _tmp1_;
	gint _tmp2_;
	gint _tmp3_;
	GdkPixbuf* _tmp4_;
	gint _tmp5_;
	gint _tmp6_;
	GdkPixbuf* _tmp43_;
	GdkPixbuf* _tmp44_;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (p != NULL, NULL);
	_tmp0_ = _g_object_ref0 (p);
	pixbuf = _tmp0_;
	_tmp1_ = pixbuf;
	_tmp2_ = gdk_pixbuf_get_width (_tmp1_);
	_tmp3_ = _tmp2_;
	_tmp4_ = pixbuf;
	_tmp5_ = gdk_pixbuf_get_height (_tmp4_);
	_tmp6_ = _tmp5_;
	if (_tmp3_ != _tmp6_) {
		GdkPixbuf* _tmp7_;
		gint _tmp8_;
		gint _tmp9_;
		GdkPixbuf* _tmp10_;
		gint _tmp11_;
		gint _tmp12_;
		_tmp7_ = pixbuf;
		_tmp8_ = gdk_pixbuf_get_width (_tmp7_);
		_tmp9_ = _tmp8_;
		_tmp10_ = pixbuf;
		_tmp11_ = gdk_pixbuf_get_height (_tmp10_);
		_tmp12_ = _tmp11_;
		if (_tmp9_ > _tmp12_) {
			gint dif = 0;
			GdkPixbuf* _tmp13_;
			gint _tmp14_;
			gint _tmp15_;
			GdkPixbuf* _tmp16_;
			gint _tmp17_;
			gint _tmp18_;
			GdkPixbuf* _tmp19_;
			gint _tmp20_;
			GdkPixbuf* _tmp21_;
			gint _tmp22_;
			gint _tmp23_;
			GdkPixbuf* _tmp24_;
			gint _tmp25_;
			gint _tmp26_;
			GdkPixbuf* _tmp27_;
			_tmp13_ = pixbuf;
			_tmp14_ = gdk_pixbuf_get_width (_tmp13_);
			_tmp15_ = _tmp14_;
			_tmp16_ = pixbuf;
			_tmp17_ = gdk_pixbuf_get_height (_tmp16_);
			_tmp18_ = _tmp17_;
			dif = (_tmp15_ - _tmp18_) / 2;
			_tmp19_ = pixbuf;
			_tmp20_ = dif;
			_tmp21_ = pixbuf;
			_tmp22_ = gdk_pixbuf_get_height (_tmp21_);
			_tmp23_ = _tmp22_;
			_tmp24_ = pixbuf;
			_tmp25_ = gdk_pixbuf_get_height (_tmp24_);
			_tmp26_ = _tmp25_;
			_tmp27_ = gdk_pixbuf_new_subpixbuf (_tmp19_, _tmp20_, 0, _tmp23_, _tmp26_);
			_g_object_unref0 (pixbuf);
			pixbuf = _tmp27_;
		} else {
			gint dif = 0;
			GdkPixbuf* _tmp28_;
			gint _tmp29_;
			gint _tmp30_;
			GdkPixbuf* _tmp31_;
			gint _tmp32_;
			gint _tmp33_;
			GdkPixbuf* _tmp34_;
			gint _tmp35_;
			GdkPixbuf* _tmp36_;
			gint _tmp37_;
			gint _tmp38_;
			GdkPixbuf* _tmp39_;
			gint _tmp40_;
			gint _tmp41_;
			GdkPixbuf* _tmp42_;
			_tmp28_ = pixbuf;
			_tmp29_ = gdk_pixbuf_get_height (_tmp28_);
			_tmp30_ = _tmp29_;
			_tmp31_ = pixbuf;
			_tmp32_ = gdk_pixbuf_get_width (_tmp31_);
			_tmp33_ = _tmp32_;
			dif = (_tmp30_ - _tmp33_) / 2;
			_tmp34_ = pixbuf;
			_tmp35_ = dif;
			_tmp36_ = pixbuf;
			_tmp37_ = gdk_pixbuf_get_width (_tmp36_);
			_tmp38_ = _tmp37_;
			_tmp39_ = pixbuf;
			_tmp40_ = gdk_pixbuf_get_width (_tmp39_);
			_tmp41_ = _tmp40_;
			_tmp42_ = gdk_pixbuf_new_subpixbuf (_tmp34_, 0, _tmp35_, _tmp38_, _tmp41_);
			_g_object_unref0 (pixbuf);
			pixbuf = _tmp42_;
		}
	}
	_tmp43_ = pixbuf;
	_tmp44_ = gdk_pixbuf_scale_simple (_tmp43_, size, size, GDK_INTERP_BILINEAR);
	_g_object_unref0 (pixbuf);
	pixbuf = _tmp44_;
	result = pixbuf;
	return result;
}


void
utils_apply_theme (Utils* self,
                   gint id)
{
	GtkSettings* _tmp9_;
	gboolean _tmp10_;
	gchar* THEME_CSS = NULL;
	gchar* _tmp11_;
	GtkCssProvider* provider = NULL;
	GtkCssProvider* _tmp12_;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	if (id == 1) {
		gchar* _tmp0_;
		gchar* _tmp1_;
		gchar* _tmp2_;
		self->priv->dark_mode = FALSE;
		_tmp0_ = g_strdup ("#fe2851");
		_g_free0 (self->priv->colorPrimary);
		self->priv->colorPrimary = _tmp0_;
		_tmp1_ = g_strdup ("#fe2851");
		_g_free0 (self->priv->colorAccent);
		self->priv->colorAccent = _tmp1_;
		_tmp2_ = g_strdup ("#fff");
		_g_free0 (self->priv->textColorPrimary);
		self->priv->textColorPrimary = _tmp2_;
	} else {
		if (id == 2) {
			gchar* _tmp3_;
			gchar* _tmp4_;
			gchar* _tmp5_;
			self->priv->dark_mode = TRUE;
			_tmp3_ = g_strdup ("mix(@BLACK_500, @BLACK_300, 0.5)");
			_g_free0 (self->priv->colorPrimary);
			self->priv->colorPrimary = _tmp3_;
			_tmp4_ = g_strdup ("#fe2851");
			_g_free0 (self->priv->colorAccent);
			self->priv->colorAccent = _tmp4_;
			_tmp5_ = g_strdup ("#fe2851");
			_g_free0 (self->priv->textColorPrimary);
			self->priv->textColorPrimary = _tmp5_;
		} else {
			if (id == 3) {
				gchar* _tmp6_;
				gchar* _tmp7_;
				gchar* _tmp8_;
				self->priv->dark_mode = TRUE;
				_tmp6_ = g_strdup ("#36E683");
				_g_free0 (self->priv->colorPrimary);
				self->priv->colorPrimary = _tmp6_;
				_tmp7_ = g_strdup ("#36E683");
				_g_free0 (self->priv->colorAccent);
				self->priv->colorAccent = _tmp7_;
				_tmp8_ = g_strdup ("#333");
				_g_free0 (self->priv->textColorPrimary);
				self->priv->textColorPrimary = _tmp8_;
			}
		}
	}
	_tmp9_ = gtk_settings_get_default ();
	_tmp10_ = self->priv->dark_mode;
	g_object_set (_tmp9_, "gtk-application-prefer-dark-theme", _tmp10_, NULL);
	_tmp11_ = g_strdup ("\n" \
"            @define-color colorPrimary %s;\n" \
"            @define-color colorAccent %s;\n" \
"            @define-color textColorPrimary %s;\n" \
"        ");
	THEME_CSS = _tmp11_;
	_tmp12_ = gtk_css_provider_new ();
	provider = _tmp12_;
	{
		gchar* theme_css = NULL;
		const gchar* _tmp13_;
		const gchar* _tmp14_;
		const gchar* _tmp15_;
		const gchar* _tmp16_;
		gchar* _tmp17_;
		GtkCssProvider* _tmp18_;
		const gchar* _tmp19_;
		const gchar* _tmp20_;
		gint _tmp21_;
		gint _tmp22_;
		GdkScreen* _tmp23_;
		GtkCssProvider* _tmp24_;
		_tmp13_ = THEME_CSS;
		_tmp14_ = self->priv->colorPrimary;
		_tmp15_ = self->priv->colorAccent;
		_tmp16_ = self->priv->textColorPrimary;
		_tmp17_ = g_strdup_printf (_tmp13_, _tmp14_, _tmp15_, _tmp16_);
		theme_css = _tmp17_;
		_tmp18_ = provider;
		_tmp19_ = theme_css;
		_tmp20_ = theme_css;
		_tmp21_ = strlen (_tmp20_);
		_tmp22_ = _tmp21_;
		gtk_css_provider_load_from_data (_tmp18_, _tmp19_, (gssize) _tmp22_, &_inner_error_);
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			_g_free0 (theme_css);
			goto __catch5_g_error;
		}
		_tmp23_ = gdk_screen_get_default ();
		_tmp24_ = provider;
		gtk_style_context_add_provider_for_screen (_tmp23_, (GtkStyleProvider*) _tmp24_, (guint) GTK_STYLE_PROVIDER_PRIORITY_APPLICATION);
		_g_free0 (theme_css);
	}
	goto __finally5;
	__catch5_g_error:
	{
		GError* e = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		_g_error_free0 (e);
		_g_object_unref0 (provider);
		_g_free0 (THEME_CSS);
		return;
	}
	__finally5:
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		_g_object_unref0 (provider);
		_g_free0 (THEME_CSS);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	_g_object_unref0 (provider);
	_g_free0 (THEME_CSS);
}


GeeArrayList*
utils_get_queue_playlist (Utils* self)
{
	GeeArrayList* result;
	GeeArrayList* _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_queue_playlist;
	result = _tmp0_;
	return result;
}


void
utils_set_queue_playlist (Utils* self,
                          GeeArrayList* value)
{
	g_return_if_fail (self != NULL);
	if (utils_get_queue_playlist (self) != value) {
		GeeArrayList* _tmp0_;
		_tmp0_ = _g_object_ref0 (value);
		_g_object_unref0 (self->priv->_queue_playlist);
		self->priv->_queue_playlist = _tmp0_;
		g_object_notify_by_pspec ((GObject *) self, utils_properties[UTILS_QUEUE_PLAYLIST_PROPERTY]);
	}
}


static void
g_cclosure_user_marshal_VOID__OBJECT_OBJECT (GClosure * closure,
                                             GValue * return_value,
                                             guint n_param_values,
                                             const GValue * param_values,
                                             gpointer invocation_hint,
                                             gpointer marshal_data)
{
	typedef void (*GMarshalFunc_VOID__OBJECT_OBJECT) (gpointer data1, gpointer arg_1, gpointer arg_2, gpointer data2);
	register GMarshalFunc_VOID__OBJECT_OBJECT callback;
	register GCClosure * cc;
	register gpointer data1;
	register gpointer data2;
	cc = (GCClosure *) closure;
	g_return_if_fail (n_param_values == 3);
	if (G_CCLOSURE_SWAP_DATA (closure)) {
		data1 = closure->data;
		data2 = param_values->data[0].v_pointer;
	} else {
		data1 = param_values->data[0].v_pointer;
		data2 = closure->data;
	}
	callback = (GMarshalFunc_VOID__OBJECT_OBJECT) (marshal_data ? marshal_data : cc->callback);
	callback (data1, g_value_get_object (param_values + 1), g_value_get_object (param_values + 2), data2);
}


static void
utils_class_init (UtilsClass * klass)
{
	utils_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (UtilsPrivate));
	G_OBJECT_CLASS (klass)->get_property = _vala_utils_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_utils_set_property;
	G_OBJECT_CLASS (klass)->finalize = utils_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), UTILS_QUEUE_PLAYLIST_PROPERTY, utils_properties[UTILS_QUEUE_PLAYLIST_PROPERTY] = g_param_spec_object ("queue-playlist", "queue-playlist", "queue-playlist", GEE_TYPE_ARRAY_LIST, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE | G_PARAM_WRITABLE));
	utils_signals[UTILS_PLAY_ITEMS_SIGNAL] = g_signal_new ("play-items", TYPE_UTILS, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_user_marshal_VOID__OBJECT_OBJECT, G_TYPE_NONE, 2, GEE_TYPE_ARRAY_LIST, OBJECTS_TYPE_TRACK);
	utils_signals[UTILS_UPDATE_NEXT_TRACK_SIGNAL] = g_signal_new ("update-next-track", TYPE_UTILS, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0);
	utils_signals[UTILS_ADD_NEXT_TRACK_SIGNAL] = g_signal_new ("add-next-track", TYPE_UTILS, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__OBJECT, G_TYPE_NONE, 1, GEE_TYPE_ARRAY_LIST);
	utils_signals[UTILS_ADD_LAST_TRACK_SIGNAL] = g_signal_new ("add-last-track", TYPE_UTILS, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__OBJECT, G_TYPE_NONE, 1, GEE_TYPE_ARRAY_LIST);
	utils_signals[UTILS_RADIO_IMAGE_DOWNLOADED_SIGNAL] = g_signal_new ("radio-image-downloaded", TYPE_UTILS, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__INT, G_TYPE_NONE, 1, G_TYPE_INT);
}


static void
utils_instance_init (Utils * self)
{
	self->priv = UTILS_GET_PRIVATE (self);
}


static void
utils_finalize (GObject * obj)
{
	Utils * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_UTILS, Utils);
	_g_object_unref0 (self->priv->_queue_playlist);
	_g_free0 (self->MAIN_FOLDER);
	_g_free0 (self->COVER_FOLDER);
	_g_free0 (self->priv->colorPrimary);
	_g_free0 (self->priv->colorAccent);
	_g_free0 (self->priv->textColorPrimary);
	G_OBJECT_CLASS (utils_parent_class)->finalize (obj);
}


GType
utils_get_type (void)
{
	static volatile gsize utils_type_id__volatile = 0;
	if (g_once_init_enter (&utils_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (UtilsClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) utils_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (Utils), 0, (GInstanceInitFunc) utils_instance_init, NULL };
		GType utils_type_id;
		utils_type_id = g_type_register_static (G_TYPE_OBJECT, "Utils", &g_define_type_info, 0);
		g_once_init_leave (&utils_type_id__volatile, utils_type_id);
	}
	return utils_type_id__volatile;
}


static void
_vala_utils_get_property (GObject * object,
                          guint property_id,
                          GValue * value,
                          GParamSpec * pspec)
{
	Utils * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, TYPE_UTILS, Utils);
	switch (property_id) {
		case UTILS_QUEUE_PLAYLIST_PROPERTY:
		g_value_set_object (value, utils_get_queue_playlist (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void
_vala_utils_set_property (GObject * object,
                          guint property_id,
                          const GValue * value,
                          GParamSpec * pspec)
{
	Utils * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, TYPE_UTILS, Utils);
	switch (property_id) {
		case UTILS_QUEUE_PLAYLIST_PROPERTY:
		utils_set_queue_playlist (self, g_value_get_object (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}



