/* Lastfm.c generated by valac 0.40.11, the Vala compiler
 * generated from Lastfm.vala, do not modify */



#include <glib.h>
#include <glib-object.h>
#include <libsoup/soup.h>
#include <stdlib.h>
#include <string.h>
#include <gio/gio.h>
#include <json-glib/json-glib.h>


#define SERVICES_TYPE_LASTFM (services_lastfm_get_type ())
#define SERVICES_LASTFM(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SERVICES_TYPE_LASTFM, ServicesLastfm))
#define SERVICES_LASTFM_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SERVICES_TYPE_LASTFM, ServicesLastfmClass))
#define SERVICES_IS_LASTFM(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SERVICES_TYPE_LASTFM))
#define SERVICES_IS_LASTFM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SERVICES_TYPE_LASTFM))
#define SERVICES_LASTFM_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SERVICES_TYPE_LASTFM, ServicesLastfmClass))

typedef struct _ServicesLastfm ServicesLastfm;
typedef struct _ServicesLastfmClass ServicesLastfmClass;
typedef struct _ServicesLastfmPrivate ServicesLastfmPrivate;
enum  {
	SERVICES_LASTFM_0_PROPERTY,
	SERVICES_LASTFM_NUM_PROPERTIES
};
static GParamSpec* services_lastfm_properties[SERVICES_LASTFM_NUM_PROPERTIES];
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))

#define SERVICES_TYPE_PLAYER (services_player_get_type ())
#define SERVICES_PLAYER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SERVICES_TYPE_PLAYER, ServicesPlayer))
#define SERVICES_PLAYER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SERVICES_TYPE_PLAYER, ServicesPlayerClass))
#define SERVICES_IS_PLAYER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SERVICES_TYPE_PLAYER))
#define SERVICES_IS_PLAYER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SERVICES_TYPE_PLAYER))
#define SERVICES_PLAYER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SERVICES_TYPE_PLAYER, ServicesPlayerClass))

typedef struct _ServicesPlayer ServicesPlayer;
typedef struct _ServicesPlayerClass ServicesPlayerClass;

#define OBJECTS_TYPE_TRACK (objects_track_get_type ())
#define OBJECTS_TRACK(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), OBJECTS_TYPE_TRACK, ObjectsTrack))
#define OBJECTS_TRACK_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), OBJECTS_TYPE_TRACK, ObjectsTrackClass))
#define OBJECTS_IS_TRACK(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), OBJECTS_TYPE_TRACK))
#define OBJECTS_IS_TRACK_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), OBJECTS_TYPE_TRACK))
#define OBJECTS_TRACK_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), OBJECTS_TYPE_TRACK, ObjectsTrackClass))

typedef struct _ObjectsTrack ObjectsTrack;
typedef struct _ObjectsTrackClass ObjectsTrackClass;

#define SERVICES_TYPE_SCAN (services_scan_get_type ())
#define SERVICES_SCAN(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SERVICES_TYPE_SCAN, ServicesScan))
#define SERVICES_SCAN_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SERVICES_TYPE_SCAN, ServicesScanClass))
#define SERVICES_IS_SCAN(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SERVICES_TYPE_SCAN))
#define SERVICES_IS_SCAN_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SERVICES_TYPE_SCAN))
#define SERVICES_SCAN_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SERVICES_TYPE_SCAN, ServicesScanClass))

typedef struct _ServicesScan ServicesScan;
typedef struct _ServicesScanClass ServicesScanClass;
typedef struct _ServicesScanPrivate ServicesScanPrivate;

#define TYPE_UTILS (utils_get_type ())
#define UTILS(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_UTILS, Utils))
#define UTILS_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_UTILS, UtilsClass))
#define IS_UTILS(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_UTILS))
#define IS_UTILS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_UTILS))
#define UTILS_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_UTILS, UtilsClass))

typedef struct _Utils Utils;
typedef struct _UtilsClass UtilsClass;
typedef struct _UtilsPrivate UtilsPrivate;
typedef struct _ObjectsTrackPrivate ObjectsTrackPrivate;
#define _g_free0(var) (var = (g_free (var), NULL))
typedef struct _Block9Data Block9Data;
#define __vala_SoupBuffer_free0(var) ((var == NULL) ? NULL : (var = (_vala_SoupBuffer_free (var), NULL)))
#define _json_object_unref0(var) ((var == NULL) ? NULL : (var = (json_object_unref (var), NULL)))
#define _json_array_unref0(var) ((var == NULL) ? NULL : (var = (json_array_unref (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
typedef struct _Block10Data Block10Data;
#define _g_main_loop_unref0(var) ((var == NULL) ? NULL : (var = (g_main_loop_unref (var), NULL)))

#define SERVICES_TYPE_DATABASE (services_database_get_type ())
#define SERVICES_DATABASE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SERVICES_TYPE_DATABASE, ServicesDatabase))
#define SERVICES_DATABASE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SERVICES_TYPE_DATABASE, ServicesDatabaseClass))
#define SERVICES_IS_DATABASE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SERVICES_TYPE_DATABASE))
#define SERVICES_IS_DATABASE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SERVICES_TYPE_DATABASE))
#define SERVICES_DATABASE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SERVICES_TYPE_DATABASE, ServicesDatabaseClass))

typedef struct _ServicesDatabase ServicesDatabase;
typedef struct _ServicesDatabaseClass ServicesDatabaseClass;
#define _g_regex_unref0(var) ((var == NULL) ? NULL : (var = (g_regex_unref (var), NULL)))
enum  {
	SERVICES_LASTFM_RADIO_COVER_TRACK_FOUND_SIGNAL,
	SERVICES_LASTFM_NUM_SIGNALS
};
static guint services_lastfm_signals[SERVICES_LASTFM_NUM_SIGNALS] = {0};

struct _ServicesLastfm {
	GObject parent_instance;
	ServicesLastfmPrivate * priv;
};

struct _ServicesLastfmClass {
	GObjectClass parent_class;
};

struct _ServicesLastfmPrivate {
	SoupSession* session;
};

struct _ServicesScan {
	GObject parent_instance;
	ServicesScanPrivate * priv;
	gint counter;
	gint counter_max;
	gboolean is_sync;
};

struct _ServicesScanClass {
	GObjectClass parent_class;
};

struct _Utils {
	GObject parent_instance;
	UtilsPrivate * priv;
	gchar* MAIN_FOLDER;
	gchar* COVER_FOLDER;
};

struct _UtilsClass {
	GObjectClass parent_class;
};

struct _ObjectsTrack {
	GObject parent_instance;
	ObjectsTrackPrivate * priv;
	gint track_order;
	gint id;
	gint album_id;
	gint track;
	gint disc;
	gint play_count;
	gint is_favorite;
	gint bitrate;
	gint bpm;
	gint rating;
	gint samplerate;
	gint channels;
	gint year;
	gint playlist;
	guint64 duration;
	gchar* path;
	gchar* title;
	gchar* favorite_added;
	gchar* last_played;
	gchar* album_title;
	gchar* artist_name;
	gchar* composer;
	gchar* grouping;
	gchar* comment;
	gchar* lyrics;
	gchar* genre;
	gchar* album_artist;
	gchar* date_added;
};

struct _ObjectsTrackClass {
	GObjectClass parent_class;
};

struct _Block9Data {
	int _ref_count_;
	ServicesLastfm* self;
	ObjectsTrack* track;
};

struct _Block10Data {
	int _ref_count_;
	ServicesLastfm* self;
	gchar* cover_path;
	GFile* file_from_uri;
	GMainLoop* loop;
	ObjectsTrack* track;
};


static gpointer services_lastfm_parent_class = NULL;
extern ServicesPlayer* byte_player;
extern ServicesScan* byte_scan_service;
extern Utils* byte_utils;
extern GSettings* byte_settings;
extern ServicesDatabase* byte_database;

GType services_lastfm_get_type (void) G_GNUC_CONST;
#define SERVICES_LASTFM_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), SERVICES_TYPE_LASTFM, ServicesLastfmPrivate))
#define SERVICES_LASTFM_API_KEY "a33950e8cc5e7130f42697fa957ec42a"
#define SERVICES_LASTFM_ROOT_URL "http://ws.audioscrobbler.com/2.0/"
ServicesLastfm* services_lastfm_new (void);
ServicesLastfm* services_lastfm_construct (GType object_type);
GType services_player_get_type (void) G_GNUC_CONST;
static void __lambda61_ (ServicesLastfm* self,
                  const gchar* title);
void services_lastfm_get_current_radio_cover (ServicesLastfm* self,
                                              const gchar* title);
static void ___lambda61__services_player_current_radio_title_changed (ServicesPlayer* _sender,
                                                               const gchar* title,
                                                               gpointer self);
GType objects_track_get_type (void) G_GNUC_CONST;
static void __lambda63_ (ServicesLastfm* self,
                  ObjectsTrack* track);
GType services_scan_get_type (void) G_GNUC_CONST;
GType utils_get_type (void) G_GNUC_CONST;
void services_lastfm_get_current_track_cover (ServicesLastfm* self,
                                              ObjectsTrack* track);
static void ___lambda63__services_player_current_track_changed (ServicesPlayer* _sender,
                                                         ObjectsTrack* track,
                                                         gpointer self);
static Block9Data* block9_data_ref (Block9Data* _data9_);
static void block9_data_unref (void * _userdata_);
static void ___lambda64_ (Block9Data* _data9_,
                   SoupSession* sess,
                   SoupMessage* mess);
static void _vala_SoupBuffer_free (SoupBuffer* self);
static void services_lastfm_download_cover (ServicesLastfm* self,
                                     ObjectsTrack* track,
                                     const gchar* uri);
static void ____lambda64__soup_session_callback (SoupSession* session,
                                          SoupMessage* msg,
                                          gpointer self);
static Block10Data* block10_data_ref (Block10Data* _data10_);
static void block10_data_unref (void * _userdata_);
static void __lambda65_ (ServicesLastfm* self,
                  gint64 current_num_bytes,
                  gint64 total_num_bytes);
static void ___lambda65__gfile_progress_callback (gint64 current_num_bytes,
                                           gint64 total_num_bytes,
                                           gpointer self);
static void __lambda66_ (Block10Data* _data10_,
                  GObject* obj,
                  GAsyncResult* res);
GType services_database_get_type (void) G_GNUC_CONST;
static void services_lastfm_add_id3_image (ServicesLastfm* self,
                                    ObjectsTrack* track,
                                    const gchar* cover_path);
static void ___lambda66__gasync_ready_callback (GObject* source_object,
                                         GAsyncResult* res,
                                         gpointer self);
static void ____lambda62_ (ServicesLastfm* self,
                    SoupSession* sess,
                    SoupMessage* mess);
static void _____lambda62__soup_session_callback (SoupSession* session,
                                           SoupMessage* msg,
                                           gpointer self);
static void services_lastfm_finalize (GObject * obj);
static void _vala_array_destroy (gpointer array,
                          gint array_length,
                          GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array,
                       gint array_length,
                       GDestroyNotify destroy_func);
static gint _vala_array_length (gpointer array);


static void
__lambda61_ (ServicesLastfm* self,
             const gchar* title)
{
	services_lastfm_get_current_radio_cover (self, title);
}


static void
___lambda61__services_player_current_radio_title_changed (ServicesPlayer* _sender,
                                                          const gchar* title,
                                                          gpointer self)
{
	__lambda61_ ((ServicesLastfm*) self, title);
}


static void
__lambda63_ (ServicesLastfm* self,
             ObjectsTrack* track)
{
	ServicesScan* _tmp0_;
	gboolean _tmp1_;
	_tmp0_ = byte_scan_service;
	_tmp1_ = _tmp0_->is_sync;
	if (_tmp1_ == FALSE) {
		GFile* cover_path = NULL;
		Utils* _tmp2_;
		const gchar* _tmp3_;
		gint _tmp4_;
		gchar* _tmp5_;
		gchar* _tmp6_;
		gchar* _tmp7_;
		gchar* _tmp8_;
		GFile* _tmp9_;
		GFile* _tmp10_;
		GFile* _tmp11_;
		_tmp2_ = byte_utils;
		_tmp3_ = _tmp2_->COVER_FOLDER;
		_tmp4_ = track->id;
		_tmp5_ = g_strdup_printf ("track-%i.jpg", _tmp4_);
		_tmp6_ = _tmp5_;
		_tmp7_ = g_build_filename (_tmp3_, _tmp6_, NULL);
		_tmp8_ = _tmp7_;
		_tmp9_ = g_file_new_for_path (_tmp8_);
		_tmp10_ = _tmp9_;
		_g_free0 (_tmp8_);
		_g_free0 (_tmp6_);
		cover_path = _tmp10_;
		_tmp11_ = cover_path;
		if (g_file_query_exists (_tmp11_, NULL) == FALSE) {
			GSettings* _tmp12_;
			_tmp12_ = byte_settings;
			if (g_settings_get_boolean (_tmp12_, "auto-download-covers")) {
				services_lastfm_get_current_track_cover (self, track);
			}
		}
		_g_object_unref0 (cover_path);
	}
}


static void
___lambda63__services_player_current_track_changed (ServicesPlayer* _sender,
                                                    ObjectsTrack* track,
                                                    gpointer self)
{
	__lambda63_ ((ServicesLastfm*) self, track);
}


ServicesLastfm*
services_lastfm_construct (GType object_type)
{
	ServicesLastfm * self = NULL;
	SoupSession* _tmp0_;
	ServicesPlayer* _tmp1_;
	ServicesPlayer* _tmp2_;
	self = (ServicesLastfm*) g_object_new (object_type, NULL);
	_tmp0_ = soup_session_new ();
	_g_object_unref0 (self->priv->session);
	self->priv->session = _tmp0_;
	_tmp1_ = byte_player;
	g_signal_connect_object (_tmp1_, "current-radio-title-changed", (GCallback) ___lambda61__services_player_current_radio_title_changed, self, 0);
	_tmp2_ = byte_player;
	g_signal_connect_object (_tmp2_, "current-track-changed", (GCallback) ___lambda63__services_player_current_track_changed, self, 0);
	return self;
}


ServicesLastfm*
services_lastfm_new (void)
{
	return services_lastfm_construct (SERVICES_TYPE_LASTFM);
}


static gpointer
_g_object_ref0 (gpointer self)
{
	return self ? g_object_ref (self) : NULL;
}


static Block9Data*
block9_data_ref (Block9Data* _data9_)
{
	g_atomic_int_inc (&_data9_->_ref_count_);
	return _data9_;
}


static void
block9_data_unref (void * _userdata_)
{
	Block9Data* _data9_;
	_data9_ = (Block9Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data9_->_ref_count_)) {
		ServicesLastfm* self;
		self = _data9_->self;
		_g_object_unref0 (_data9_->track);
		_g_object_unref0 (self);
		g_slice_free (Block9Data, _data9_);
	}
}


static void
_vala_SoupBuffer_free (SoupBuffer* self)
{
	g_boxed_free (soup_buffer_get_type (), self);
}


static gpointer
_json_object_ref0 (gpointer self)
{
	return self ? json_object_ref (self) : NULL;
}


static gpointer
_json_array_ref0 (gpointer self)
{
	return self ? json_array_ref (self) : NULL;
}


static void
___lambda64_ (Block9Data* _data9_,
              SoupSession* sess,
              SoupMessage* mess)
{
	ServicesLastfm* self;
	guint _tmp0_;
	guint _tmp1_;
	GError * _inner_error_ = NULL;
	self = _data9_->self;
	g_return_if_fail (sess != NULL);
	g_return_if_fail (mess != NULL);
	g_object_get (mess, "status-code", &_tmp0_, NULL);
	_tmp1_ = _tmp0_;
	if (_tmp1_ == ((guint) 200)) {
		JsonParser* parser = NULL;
		JsonParser* _tmp2_;
		_tmp2_ = json_parser_new ();
		parser = _tmp2_;
		{
			JsonParser* _tmp3_;
			SoupMessageBody* _tmp4_;
			SoupBuffer* _tmp5_;
			SoupBuffer* _tmp6_;
			guint8* _tmp7_;
			gint _tmp7__length1;
			JsonObject* node = NULL;
			JsonParser* _tmp8_;
			JsonNode* _tmp9_;
			JsonObject* _tmp10_;
			JsonObject* _tmp11_;
			JsonObject* track_object = NULL;
			JsonObject* _tmp12_;
			JsonObject* _tmp13_;
			JsonObject* _tmp14_;
			JsonObject* album_object = NULL;
			JsonObject* _tmp15_;
			JsonObject* _tmp16_;
			JsonObject* _tmp17_;
			JsonArray* image = NULL;
			JsonObject* _tmp18_;
			JsonArray* _tmp19_;
			JsonArray* _tmp20_;
			JsonArray* _tmp21_;
			GList* _tmp22_;
			_tmp3_ = parser;
			_tmp4_ = mess->response_body;
			_tmp5_ = soup_message_body_flatten (_tmp4_);
			_tmp6_ = _tmp5_;
			_tmp7_ = _tmp6_->data;
			_tmp7__length1 = (gint) _tmp6_->length;
			json_parser_load_from_data (_tmp3_, (const gchar*) _tmp7_, (gssize) -1, &_inner_error_);
			__vala_SoupBuffer_free0 (_tmp6_);
			if (G_UNLIKELY (_inner_error_ != NULL)) {
				goto __catch22_g_error;
			}
			_tmp8_ = parser;
			_tmp9_ = json_parser_get_root (_tmp8_);
			_tmp10_ = json_node_get_object (_tmp9_);
			_tmp11_ = _json_object_ref0 (_tmp10_);
			node = _tmp11_;
			_tmp12_ = node;
			_tmp13_ = json_object_get_object_member (_tmp12_, "track");
			_tmp14_ = _json_object_ref0 (_tmp13_);
			track_object = _tmp14_;
			_tmp15_ = track_object;
			_tmp16_ = json_object_get_object_member (_tmp15_, "album");
			_tmp17_ = _json_object_ref0 (_tmp16_);
			album_object = _tmp17_;
			_tmp18_ = album_object;
			_tmp19_ = json_object_get_array_member (_tmp18_, "image");
			_tmp20_ = _json_array_ref0 (_tmp19_);
			image = _tmp20_;
			_tmp21_ = image;
			_tmp22_ = json_array_get_elements (_tmp21_);
			{
				GList* item_collection = NULL;
				GList* item_it = NULL;
				item_collection = _tmp22_;
				for (item_it = item_collection; item_it != NULL; item_it = item_it->next) {
					JsonNode* item = NULL;
					item = (JsonNode*) item_it->data;
					{
						JsonObject* object = NULL;
						JsonNode* _tmp23_;
						JsonObject* _tmp24_;
						JsonObject* _tmp25_;
						JsonObject* _tmp26_;
						const gchar* _tmp27_;
						_tmp23_ = item;
						_tmp24_ = json_node_get_object (_tmp23_);
						_tmp25_ = _json_object_ref0 (_tmp24_);
						object = _tmp25_;
						_tmp26_ = object;
						_tmp27_ = json_object_get_string_member (_tmp26_, "size");
						if (g_strcmp0 (_tmp27_, "large") == 0) {
							gboolean _tmp28_ = FALSE;
							JsonObject* _tmp29_;
							const gchar* _tmp30_;
							_tmp29_ = object;
							_tmp30_ = json_object_get_string_member (_tmp29_, "#text");
							if (_tmp30_ != NULL) {
								_tmp28_ = TRUE;
							} else {
								JsonObject* _tmp31_;
								const gchar* _tmp32_;
								_tmp31_ = object;
								_tmp32_ = json_object_get_string_member (_tmp31_, "#text");
								_tmp28_ = g_strcmp0 (_tmp32_, "") != 0;
							}
							if (_tmp28_) {
								JsonObject* _tmp33_;
								const gchar* _tmp34_;
								_tmp33_ = object;
								_tmp34_ = json_object_get_string_member (_tmp33_, "#text");
								services_lastfm_download_cover (self, _data9_->track, _tmp34_);
							}
						}
						_json_object_unref0 (object);
					}
				}
				(item_collection == NULL) ? NULL : (item_collection = (g_list_free (item_collection), NULL));
			}
			_json_array_unref0 (image);
			_json_object_unref0 (album_object);
			_json_object_unref0 (track_object);
			_json_object_unref0 (node);
		}
		goto __finally22;
		__catch22_g_error:
		{
			GError* e = NULL;
			e = _inner_error_;
			_inner_error_ = NULL;
			_g_error_free0 (e);
		}
		__finally22:
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			_g_object_unref0 (parser);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
		_g_object_unref0 (parser);
	} else {
	}
}


static void
____lambda64__soup_session_callback (SoupSession* session,
                                     SoupMessage* msg,
                                     gpointer self)
{
	___lambda64_ (self, session, msg);
	block9_data_unref (self);
}


void
services_lastfm_get_current_track_cover (ServicesLastfm* self,
                                         ObjectsTrack* track)
{
	Block9Data* _data9_;
	ObjectsTrack* _tmp0_;
	gboolean _tmp1_ = FALSE;
	const gchar* _tmp2_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (track != NULL);
	_data9_ = g_slice_new0 (Block9Data);
	_data9_->_ref_count_ = 1;
	_data9_->self = g_object_ref (self);
	_tmp0_ = _g_object_ref0 (track);
	_g_object_unref0 (_data9_->track);
	_data9_->track = _tmp0_;
	_tmp2_ = _data9_->track->title;
	if (g_strcmp0 (_tmp2_, "") != 0) {
		const gchar* _tmp3_;
		_tmp3_ = _data9_->track->artist_name;
		_tmp1_ = g_strcmp0 (_tmp3_, "") != 0;
	} else {
		_tmp1_ = FALSE;
	}
	if (_tmp1_) {
		gchar* url = NULL;
		gchar* _tmp4_;
		const gchar* _tmp5_;
		gchar* _tmp6_;
		const gchar* _tmp7_;
		gchar* _tmp8_;
		gchar* _tmp9_;
		gchar* _tmp10_;
		const gchar* _tmp11_;
		gchar* _tmp12_;
		gchar* _tmp13_;
		const gchar* _tmp14_;
		gchar* _tmp15_;
		const gchar* _tmp16_;
		gchar* _tmp17_;
		gchar* _tmp18_;
		const gchar* _tmp19_;
		gchar* _tmp20_;
		const gchar* _tmp21_;
		gchar* _tmp22_;
		SoupMessage* message = NULL;
		const gchar* _tmp23_;
		SoupMessage* _tmp24_;
		SoupSession* _tmp25_;
		SoupMessage* _tmp26_;
		SoupMessage* _tmp27_;
		_tmp4_ = g_strdup (SERVICES_LASTFM_ROOT_URL);
		url = _tmp4_;
		_tmp5_ = url;
		_tmp6_ = g_strconcat (_tmp5_, "?method=track.getInfo", NULL);
		_g_free0 (url);
		url = _tmp6_;
		_tmp7_ = url;
		_tmp8_ = g_strconcat (_tmp7_, "&api_key=", NULL);
		_tmp9_ = _tmp8_;
		_tmp10_ = g_strconcat (_tmp9_, SERVICES_LASTFM_API_KEY, NULL);
		_g_free0 (url);
		url = _tmp10_;
		_g_free0 (_tmp9_);
		_tmp11_ = url;
		_tmp12_ = g_strconcat (_tmp11_, "&artist=", NULL);
		_tmp13_ = _tmp12_;
		_tmp14_ = _data9_->track->artist_name;
		_tmp15_ = g_strconcat (_tmp13_, _tmp14_, NULL);
		_g_free0 (url);
		url = _tmp15_;
		_g_free0 (_tmp13_);
		_tmp16_ = url;
		_tmp17_ = g_strconcat (_tmp16_, "&track=", NULL);
		_tmp18_ = _tmp17_;
		_tmp19_ = _data9_->track->title;
		_tmp20_ = g_strconcat (_tmp18_, _tmp19_, NULL);
		_g_free0 (url);
		url = _tmp20_;
		_g_free0 (_tmp18_);
		_tmp21_ = url;
		_tmp22_ = g_strconcat (_tmp21_, "&format=json", NULL);
		_g_free0 (url);
		url = _tmp22_;
		_tmp23_ = url;
		_tmp24_ = soup_message_new ("GET", _tmp23_);
		message = _tmp24_;
		_tmp25_ = self->priv->session;
		_tmp26_ = message;
		_tmp27_ = _g_object_ref0 (_tmp26_);
		soup_session_queue_message (_tmp25_, _tmp27_, ____lambda64__soup_session_callback, block9_data_ref (_data9_));
		_g_object_unref0 (message);
		_g_free0 (url);
	}
	block9_data_unref (_data9_);
	_data9_ = NULL;
}


static Block10Data*
block10_data_ref (Block10Data* _data10_)
{
	g_atomic_int_inc (&_data10_->_ref_count_);
	return _data10_;
}


static void
block10_data_unref (void * _userdata_)
{
	Block10Data* _data10_;
	_data10_ = (Block10Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data10_->_ref_count_)) {
		ServicesLastfm* self;
		self = _data10_->self;
		_g_main_loop_unref0 (_data10_->loop);
		_g_object_unref0 (_data10_->file_from_uri);
		_g_free0 (_data10_->cover_path);
		_g_object_unref0 (_data10_->track);
		_g_object_unref0 (self);
		g_slice_free (Block10Data, _data10_);
	}
}


static void
__lambda65_ (ServicesLastfm* self,
             gint64 current_num_bytes,
             gint64 total_num_bytes)
{
	g_print ("%" G_GINT64_FORMAT " bytes of %" G_GINT64_FORMAT " bytes copied.\n", current_num_bytes, total_num_bytes);
}


static void
___lambda65__gfile_progress_callback (gint64 current_num_bytes,
                                      gint64 total_num_bytes,
                                      gpointer self)
{
	__lambda65_ ((ServicesLastfm*) self, current_num_bytes, total_num_bytes);
}


static void
__lambda66_ (Block10Data* _data10_,
             GObject* obj,
             GAsyncResult* res)
{
	ServicesLastfm* self;
	GError * _inner_error_ = NULL;
	self = _data10_->self;
	g_return_if_fail (res != NULL);
	{
		gboolean _tmp0_ = FALSE;
		_tmp0_ = g_file_copy_finish (_data10_->file_from_uri, res, &_inner_error_);
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			goto __catch23_g_error;
		}
		if (_tmp0_) {
			const gchar* _tmp1_;
			gchar* _tmp2_;
			gchar* _tmp3_;
			ServicesDatabase* _tmp4_;
			gint _tmp5_;
			GSettings* _tmp6_;
			_tmp1_ = _data10_->track->title;
			_tmp2_ = g_strdup_printf ("Cover %s was downloaded\n", _tmp1_);
			_tmp3_ = _tmp2_;
			g_print ("%s", _tmp3_);
			_g_free0 (_tmp3_);
			_tmp4_ = byte_database;
			_tmp5_ = _data10_->track->id;
			g_signal_emit_by_name (_tmp4_, "updated-track-cover", _tmp5_);
			_tmp6_ = byte_settings;
			if (g_settings_get_boolean (_tmp6_, "save-id3-tags")) {
				services_lastfm_add_id3_image (self, _data10_->track, _data10_->cover_path);
			}
		}
	}
	goto __finally23;
	__catch23_g_error:
	{
		GError* e = NULL;
		GError* _tmp7_;
		const gchar* _tmp8_;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp7_ = e;
		_tmp8_ = _tmp7_->message;
		g_print ("Error: %s\n", _tmp8_);
		_g_error_free0 (e);
	}
	__finally23:
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	g_main_loop_quit (_data10_->loop);
}


static void
___lambda66__gasync_ready_callback (GObject* source_object,
                                    GAsyncResult* res,
                                    gpointer self)
{
	__lambda66_ (self, source_object, res);
	block10_data_unref (self);
}


static void
services_lastfm_download_cover (ServicesLastfm* self,
                                ObjectsTrack* track,
                                const gchar* uri)
{
	Block10Data* _data10_;
	ObjectsTrack* _tmp0_;
	Utils* _tmp1_;
	const gchar* _tmp2_;
	gint _tmp3_;
	gchar* _tmp4_;
	gchar* _tmp5_;
	gchar* _tmp6_;
	gchar* _tmp7_;
	GFile* file_path = NULL;
	GFile* _tmp8_;
	GFile* _tmp9_;
	GMainLoop* _tmp10_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (track != NULL);
	g_return_if_fail (uri != NULL);
	_data10_ = g_slice_new0 (Block10Data);
	_data10_->_ref_count_ = 1;
	_data10_->self = g_object_ref (self);
	_tmp0_ = _g_object_ref0 (track);
	_g_object_unref0 (_data10_->track);
	_data10_->track = _tmp0_;
	_tmp1_ = byte_utils;
	_tmp2_ = _tmp1_->COVER_FOLDER;
	_tmp3_ = _data10_->track->id;
	_tmp4_ = g_strdup_printf ("track-%i.jpg", _tmp3_);
	_tmp5_ = _tmp4_;
	_tmp6_ = g_build_filename (_tmp2_, _tmp5_, NULL);
	_tmp7_ = _tmp6_;
	_g_free0 (_tmp5_);
	_data10_->cover_path = _tmp7_;
	_tmp8_ = g_file_new_for_path (_data10_->cover_path);
	file_path = _tmp8_;
	_tmp9_ = g_file_new_for_uri (uri);
	_data10_->file_from_uri = _tmp9_;
	_tmp10_ = g_main_loop_new (NULL, FALSE);
	_data10_->loop = _tmp10_;
	g_file_copy_async (_data10_->file_from_uri, file_path, 0, G_PRIORITY_DEFAULT, NULL, ___lambda65__gfile_progress_callback, self, ___lambda66__gasync_ready_callback, block10_data_ref (_data10_));
	g_main_loop_run (_data10_->loop);
	_g_object_unref0 (file_path);
	block10_data_unref (_data10_);
	_data10_ = NULL;
}


static void
____lambda62_ (ServicesLastfm* self,
               SoupSession* sess,
               SoupMessage* mess)
{
	guint _tmp0_;
	guint _tmp1_;
	GError * _inner_error_ = NULL;
	g_return_if_fail (sess != NULL);
	g_return_if_fail (mess != NULL);
	g_object_get (mess, "status-code", &_tmp0_, NULL);
	_tmp1_ = _tmp0_;
	if (_tmp1_ == ((guint) 200)) {
		JsonParser* parser = NULL;
		JsonParser* _tmp2_;
		_tmp2_ = json_parser_new ();
		parser = _tmp2_;
		{
			JsonParser* _tmp3_;
			SoupMessageBody* _tmp4_;
			SoupBuffer* _tmp5_;
			SoupBuffer* _tmp6_;
			guint8* _tmp7_;
			gint _tmp7__length1;
			JsonObject* node = NULL;
			JsonParser* _tmp8_;
			JsonNode* _tmp9_;
			JsonObject* _tmp10_;
			JsonObject* _tmp11_;
			JsonObject* track_object = NULL;
			JsonObject* _tmp12_;
			JsonObject* _tmp13_;
			JsonObject* _tmp14_;
			JsonObject* album_object = NULL;
			JsonObject* _tmp15_;
			JsonObject* _tmp16_;
			JsonObject* _tmp17_;
			JsonArray* image = NULL;
			JsonObject* _tmp18_;
			JsonArray* _tmp19_;
			JsonArray* _tmp20_;
			JsonArray* _tmp21_;
			GList* _tmp22_;
			_tmp3_ = parser;
			_tmp4_ = mess->response_body;
			_tmp5_ = soup_message_body_flatten (_tmp4_);
			_tmp6_ = _tmp5_;
			_tmp7_ = _tmp6_->data;
			_tmp7__length1 = (gint) _tmp6_->length;
			json_parser_load_from_data (_tmp3_, (const gchar*) _tmp7_, (gssize) -1, &_inner_error_);
			__vala_SoupBuffer_free0 (_tmp6_);
			if (G_UNLIKELY (_inner_error_ != NULL)) {
				goto __catch24_g_error;
			}
			_tmp8_ = parser;
			_tmp9_ = json_parser_get_root (_tmp8_);
			_tmp10_ = json_node_get_object (_tmp9_);
			_tmp11_ = _json_object_ref0 (_tmp10_);
			node = _tmp11_;
			_tmp12_ = node;
			_tmp13_ = json_object_get_object_member (_tmp12_, "track");
			_tmp14_ = _json_object_ref0 (_tmp13_);
			track_object = _tmp14_;
			_tmp15_ = track_object;
			_tmp16_ = json_object_get_object_member (_tmp15_, "album");
			_tmp17_ = _json_object_ref0 (_tmp16_);
			album_object = _tmp17_;
			_tmp18_ = album_object;
			_tmp19_ = json_object_get_array_member (_tmp18_, "image");
			_tmp20_ = _json_array_ref0 (_tmp19_);
			image = _tmp20_;
			_tmp21_ = image;
			_tmp22_ = json_array_get_elements (_tmp21_);
			{
				GList* item_collection = NULL;
				GList* item_it = NULL;
				item_collection = _tmp22_;
				for (item_it = item_collection; item_it != NULL; item_it = item_it->next) {
					JsonNode* item = NULL;
					item = (JsonNode*) item_it->data;
					{
						JsonObject* object = NULL;
						JsonNode* _tmp23_;
						JsonObject* _tmp24_;
						JsonObject* _tmp25_;
						JsonObject* _tmp26_;
						const gchar* _tmp27_;
						_tmp23_ = item;
						_tmp24_ = json_node_get_object (_tmp23_);
						_tmp25_ = _json_object_ref0 (_tmp24_);
						object = _tmp25_;
						_tmp26_ = object;
						_tmp27_ = json_object_get_string_member (_tmp26_, "size");
						if (g_strcmp0 (_tmp27_, "large") == 0) {
							gboolean _tmp28_ = FALSE;
							JsonObject* _tmp29_;
							const gchar* _tmp30_;
							_tmp29_ = object;
							_tmp30_ = json_object_get_string_member (_tmp29_, "#text");
							if (_tmp30_ != NULL) {
								_tmp28_ = TRUE;
							} else {
								JsonObject* _tmp31_;
								const gchar* _tmp32_;
								_tmp31_ = object;
								_tmp32_ = json_object_get_string_member (_tmp31_, "#text");
								_tmp28_ = g_strcmp0 (_tmp32_, "") != 0;
							}
							if (_tmp28_) {
								JsonObject* _tmp33_;
								const gchar* _tmp34_;
								_tmp33_ = object;
								_tmp34_ = json_object_get_string_member (_tmp33_, "#text");
								g_signal_emit (self, services_lastfm_signals[SERVICES_LASTFM_RADIO_COVER_TRACK_FOUND_SIGNAL], 0, _tmp34_);
							}
						}
						_json_object_unref0 (object);
					}
				}
				(item_collection == NULL) ? NULL : (item_collection = (g_list_free (item_collection), NULL));
			}
			_json_array_unref0 (image);
			_json_object_unref0 (album_object);
			_json_object_unref0 (track_object);
			_json_object_unref0 (node);
		}
		goto __finally24;
		__catch24_g_error:
		{
			GError* e = NULL;
			e = _inner_error_;
			_inner_error_ = NULL;
			_g_error_free0 (e);
		}
		__finally24:
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			_g_object_unref0 (parser);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
		_g_object_unref0 (parser);
	} else {
	}
}


static void
_____lambda62__soup_session_callback (SoupSession* session,
                                      SoupMessage* msg,
                                      gpointer self)
{
	____lambda62_ ((ServicesLastfm*) self, session, msg);
	g_object_unref (self);
}


void
services_lastfm_get_current_radio_cover (ServicesLastfm* self,
                                         const gchar* title)
{
	g_return_if_fail (self != NULL);
	if (title != NULL) {
		gchar** media = NULL;
		gchar** _tmp0_;
		gchar** _tmp1_;
		gint media_length1;
		gint _media_size_;
		gchar* artist = NULL;
		gchar* _tmp2_;
		gchar* track = NULL;
		gchar* _tmp3_;
		gboolean _tmp4_ = FALSE;
		gchar** _tmp5_;
		gint _tmp5__length1;
		const gchar* _tmp6_;
		_tmp1_ = _tmp0_ = g_strsplit (title, " - ", 0);
		media = _tmp1_;
		media_length1 = _vala_array_length (_tmp0_);
		_media_size_ = media_length1;
		_tmp2_ = g_strdup ("");
		artist = _tmp2_;
		_tmp3_ = g_strdup ("");
		track = _tmp3_;
		_tmp5_ = media;
		_tmp5__length1 = media_length1;
		_tmp6_ = _tmp5_[0];
		if (_tmp6_ != NULL) {
			gchar** _tmp7_;
			gint _tmp7__length1;
			const gchar* _tmp8_;
			_tmp7_ = media;
			_tmp7__length1 = media_length1;
			_tmp8_ = _tmp7_[1];
			_tmp4_ = _tmp8_ != NULL;
		} else {
			_tmp4_ = FALSE;
		}
		if (_tmp4_) {
			gchar** _tmp9_;
			gint _tmp9__length1;
			const gchar* _tmp10_;
			gchar* _tmp11_;
			gchar** _tmp12_;
			gint _tmp12__length1;
			const gchar* _tmp13_;
			gchar* _tmp14_;
			gchar* url = NULL;
			gchar* _tmp15_;
			const gchar* _tmp16_;
			gchar* _tmp17_;
			const gchar* _tmp18_;
			gchar* _tmp19_;
			gchar* _tmp20_;
			gchar* _tmp21_;
			const gchar* _tmp22_;
			gchar* _tmp23_;
			gchar* _tmp24_;
			const gchar* _tmp25_;
			gchar* _tmp26_;
			const gchar* _tmp27_;
			gchar* _tmp28_;
			gchar* _tmp29_;
			const gchar* _tmp30_;
			gchar* _tmp31_;
			const gchar* _tmp32_;
			gchar* _tmp33_;
			SoupMessage* message = NULL;
			const gchar* _tmp34_;
			SoupMessage* _tmp35_;
			SoupSession* _tmp36_;
			SoupMessage* _tmp37_;
			SoupMessage* _tmp38_;
			_tmp9_ = media;
			_tmp9__length1 = media_length1;
			_tmp10_ = _tmp9_[0];
			_tmp11_ = g_strdup (_tmp10_);
			_g_free0 (artist);
			artist = _tmp11_;
			_tmp12_ = media;
			_tmp12__length1 = media_length1;
			_tmp13_ = _tmp12_[1];
			_tmp14_ = g_strdup (_tmp13_);
			_g_free0 (track);
			track = _tmp14_;
			_tmp15_ = g_strdup (SERVICES_LASTFM_ROOT_URL);
			url = _tmp15_;
			_tmp16_ = url;
			_tmp17_ = g_strconcat (_tmp16_, "?method=track.getInfo", NULL);
			_g_free0 (url);
			url = _tmp17_;
			_tmp18_ = url;
			_tmp19_ = g_strconcat (_tmp18_, "&api_key=", NULL);
			_tmp20_ = _tmp19_;
			_tmp21_ = g_strconcat (_tmp20_, SERVICES_LASTFM_API_KEY, NULL);
			_g_free0 (url);
			url = _tmp21_;
			_g_free0 (_tmp20_);
			_tmp22_ = url;
			_tmp23_ = g_strconcat (_tmp22_, "&artist=", NULL);
			_tmp24_ = _tmp23_;
			_tmp25_ = artist;
			_tmp26_ = g_strconcat (_tmp24_, _tmp25_, NULL);
			_g_free0 (url);
			url = _tmp26_;
			_g_free0 (_tmp24_);
			_tmp27_ = url;
			_tmp28_ = g_strconcat (_tmp27_, "&track=", NULL);
			_tmp29_ = _tmp28_;
			_tmp30_ = track;
			_tmp31_ = g_strconcat (_tmp29_, _tmp30_, NULL);
			_g_free0 (url);
			url = _tmp31_;
			_g_free0 (_tmp29_);
			_tmp32_ = url;
			_tmp33_ = g_strconcat (_tmp32_, "&format=json", NULL);
			_g_free0 (url);
			url = _tmp33_;
			_tmp34_ = url;
			_tmp35_ = soup_message_new ("GET", _tmp34_);
			message = _tmp35_;
			_tmp36_ = self->priv->session;
			_tmp37_ = message;
			_tmp38_ = _g_object_ref0 (_tmp37_);
			soup_session_queue_message (_tmp36_, _tmp38_, _____lambda62__soup_session_callback, g_object_ref (self));
			_g_object_unref0 (message);
			_g_free0 (url);
		}
		_g_free0 (track);
		_g_free0 (artist);
		media = (_vala_array_free (media, media_length1, (GDestroyNotify) g_free), NULL);
	}
}


static glong
string_strnlen (gchar* str,
                glong maxlen)
{
	glong result = 0L;
	gchar* end = NULL;
	gchar* _tmp0_;
	gchar* _tmp1_;
	_tmp0_ = memchr (str, 0, (gsize) maxlen);
	end = _tmp0_;
	_tmp1_ = end;
	if (_tmp1_ == NULL) {
		result = maxlen;
		return result;
	} else {
		gchar* _tmp2_;
		_tmp2_ = end;
		result = (glong) (_tmp2_ - str);
		return result;
	}
}


static gchar*
string_substring (const gchar* self,
                  glong offset,
                  glong len)
{
	gchar* result = NULL;
	glong string_length = 0L;
	gboolean _tmp0_ = FALSE;
	glong _tmp6_;
	gchar* _tmp7_;
	g_return_val_if_fail (self != NULL, NULL);
	if (offset >= ((glong) 0)) {
		_tmp0_ = len >= ((glong) 0);
	} else {
		_tmp0_ = FALSE;
	}
	if (_tmp0_) {
		string_length = string_strnlen ((gchar*) self, offset + len);
	} else {
		gint _tmp1_;
		gint _tmp2_;
		_tmp1_ = strlen (self);
		_tmp2_ = _tmp1_;
		string_length = (glong) _tmp2_;
	}
	if (offset < ((glong) 0)) {
		glong _tmp3_;
		_tmp3_ = string_length;
		offset = _tmp3_ + offset;
		g_return_val_if_fail (offset >= ((glong) 0), NULL);
	} else {
		glong _tmp4_;
		_tmp4_ = string_length;
		g_return_val_if_fail (offset <= _tmp4_, NULL);
	}
	if (len < ((glong) 0)) {
		glong _tmp5_;
		_tmp5_ = string_length;
		len = _tmp5_ - offset;
	}
	_tmp6_ = string_length;
	g_return_val_if_fail ((offset + len) <= _tmp6_, NULL);
	_tmp7_ = g_strndup (((gchar*) self) + offset, (gsize) len);
	result = _tmp7_;
	return result;
}


static gchar*
string_replace (const gchar* self,
                const gchar* old,
                const gchar* replacement)
{
	gchar* result = NULL;
	gboolean _tmp0_ = FALSE;
	gboolean _tmp1_ = FALSE;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (old != NULL, NULL);
	g_return_val_if_fail (replacement != NULL, NULL);
	if ((*((gchar*) self)) == '\0') {
		_tmp1_ = TRUE;
	} else {
		_tmp1_ = (*((gchar*) old)) == '\0';
	}
	if (_tmp1_) {
		_tmp0_ = TRUE;
	} else {
		_tmp0_ = g_strcmp0 (old, replacement) == 0;
	}
	if (_tmp0_) {
		gchar* _tmp2_;
		_tmp2_ = g_strdup (self);
		result = _tmp2_;
		return result;
	}
	{
		GRegex* regex = NULL;
		gchar* _tmp3_;
		gchar* _tmp4_;
		GRegex* _tmp5_;
		GRegex* _tmp6_;
		gchar* _tmp7_ = NULL;
		GRegex* _tmp8_;
		gchar* _tmp9_;
		gchar* _tmp10_;
		_tmp3_ = g_regex_escape_string (old, -1);
		_tmp4_ = _tmp3_;
		_tmp5_ = g_regex_new (_tmp4_, 0, 0, &_inner_error_);
		_tmp6_ = _tmp5_;
		_g_free0 (_tmp4_);
		regex = _tmp6_;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			if (_inner_error_->domain == G_REGEX_ERROR) {
				goto __catch25_g_regex_error;
			}
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
		_tmp8_ = regex;
		_tmp9_ = g_regex_replace_literal (_tmp8_, self, (gssize) -1, 0, replacement, 0, &_inner_error_);
		_tmp7_ = _tmp9_;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			_g_regex_unref0 (regex);
			if (_inner_error_->domain == G_REGEX_ERROR) {
				goto __catch25_g_regex_error;
			}
			_g_regex_unref0 (regex);
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
		_tmp10_ = _tmp7_;
		_tmp7_ = NULL;
		result = _tmp10_;
		_g_free0 (_tmp7_);
		_g_regex_unref0 (regex);
		return result;
	}
	goto __finally25;
	__catch25_g_regex_error:
	{
		GError* e = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		g_assert_not_reached ();
		_g_error_free0 (e);
	}
	__finally25:
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
}


static void
services_lastfm_add_id3_image (ServicesLastfm* self,
                               ObjectsTrack* track,
                               const gchar* cover_path)
{
	gchar* track_path = NULL;
	const gchar* _tmp0_;
	gchar* _tmp1_;
	gchar* _tmp2_;
	gchar* _tmp3_;
	gchar* _tmp4_;
	gchar* response = NULL;
	gchar* _tmp5_;
	gchar* command = NULL;
	gchar* _tmp6_;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (track != NULL);
	g_return_if_fail (cover_path != NULL);
	_tmp0_ = track->path;
	_tmp1_ = string_substring (_tmp0_, (glong) 7, (glong) -1);
	_tmp2_ = _tmp1_;
	_tmp3_ = string_replace (_tmp2_, "%20", " ");
	_tmp4_ = _tmp3_;
	_g_free0 (_tmp2_);
	track_path = _tmp4_;
	_tmp5_ = g_strdup ("");
	response = _tmp5_;
	_tmp6_ = g_strdup_printf ("eyeD3 --add-image='%s':FRONT_COVER '%s'", cover_path, track_path);
	command = _tmp6_;
	{
		gchar* _tmp7_ = NULL;
		const gchar* _tmp8_;
		gchar* _tmp9_;
		gchar* _tmp10_;
		g_spawn_command_line_sync (command, &_tmp7_, NULL, NULL, &_inner_error_);
		_g_free0 (response);
		response = _tmp7_;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			if (_inner_error_->domain == G_SPAWN_ERROR) {
				goto __catch26_g_spawn_error;
			}
			_g_free0 (command);
			_g_free0 (response);
			_g_free0 (track_path);
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
		g_print ("---------------------------------\n");
		_tmp8_ = response;
		_tmp9_ = g_strdup_printf ("Error: %s\n", _tmp8_);
		_tmp10_ = _tmp9_;
		g_print ("%s", _tmp10_);
		_g_free0 (_tmp10_);
		g_print ("---------------------------------\n");
	}
	goto __finally26;
	__catch26_g_spawn_error:
	{
		GError* e = NULL;
		GError* _tmp11_;
		const gchar* _tmp12_;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp11_ = e;
		_tmp12_ = _tmp11_->message;
		g_print ("Error: %s\n", _tmp12_);
		_g_error_free0 (e);
	}
	__finally26:
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		_g_free0 (command);
		_g_free0 (response);
		_g_free0 (track_path);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	_g_free0 (command);
	_g_free0 (response);
	_g_free0 (track_path);
}


static void
services_lastfm_class_init (ServicesLastfmClass * klass)
{
	services_lastfm_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (ServicesLastfmPrivate));
	G_OBJECT_CLASS (klass)->finalize = services_lastfm_finalize;
	services_lastfm_signals[SERVICES_LASTFM_RADIO_COVER_TRACK_FOUND_SIGNAL] = g_signal_new ("radio-cover-track-found", SERVICES_TYPE_LASTFM, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__STRING, G_TYPE_NONE, 1, G_TYPE_STRING);
}


static void
services_lastfm_instance_init (ServicesLastfm * self)
{
	self->priv = SERVICES_LASTFM_GET_PRIVATE (self);
}


static void
services_lastfm_finalize (GObject * obj)
{
	ServicesLastfm * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, SERVICES_TYPE_LASTFM, ServicesLastfm);
	_g_object_unref0 (self->priv->session);
	G_OBJECT_CLASS (services_lastfm_parent_class)->finalize (obj);
}


GType
services_lastfm_get_type (void)
{
	static volatile gsize services_lastfm_type_id__volatile = 0;
	if (g_once_init_enter (&services_lastfm_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (ServicesLastfmClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) services_lastfm_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (ServicesLastfm), 0, (GInstanceInitFunc) services_lastfm_instance_init, NULL };
		GType services_lastfm_type_id;
		services_lastfm_type_id = g_type_register_static (G_TYPE_OBJECT, "ServicesLastfm", &g_define_type_info, 0);
		g_once_init_leave (&services_lastfm_type_id__volatile, services_lastfm_type_id);
	}
	return services_lastfm_type_id__volatile;
}


static void
_vala_array_destroy (gpointer array,
                     gint array_length,
                     GDestroyNotify destroy_func)
{
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void
_vala_array_free (gpointer array,
                  gint array_length,
                  GDestroyNotify destroy_func)
{
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}


static gint
_vala_array_length (gpointer array)
{
	int length;
	length = 0;
	if (array) {
		while (((gpointer*) array)[length]) {
			length++;
		}
	}
	return length;
}



